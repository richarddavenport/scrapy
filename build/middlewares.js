var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
import http from "http";
import https from "https";
import zlib from "zlib";
import Stream, { PassThrough, pipeline } from "stream";
import { types } from "util";
import { randomBytes } from "crypto";
import { format } from "url";
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    length += isBlob(value) ? value.size : Buffer.byteLength(String(value));
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = Stream.Readable.from(body.stream());
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof Stream)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve3, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = dataUriToBuffer$1(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve3(response2);
      return;
    }
    const send2 = (options2.protocol === "https:" ? https : http).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof Stream.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send2(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers.get("Location");
        const locationURL = location2 === null ? null : new URL(location2, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve3(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = pipeline(response_, new PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve3(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = pipeline(body, zlib.createGunzip(zlibOptions), reject);
        response = new Response(body, responseOptions);
        resolve3(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = pipeline(response_, new PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? pipeline(body, zlib.createInflate(), reject) : pipeline(body, zlib.createInflateRaw(), reject);
          response = new Response(body, responseOptions);
          resolve3(response);
        });
        return;
      }
      if (codings === "br") {
        body = pipeline(body, zlib.createBrotliDecompress(), reject);
        response = new Response(body, responseOptions);
        resolve3(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve3(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
var commonjsGlobal, src, dataUriToBuffer$1, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _parts, _type, _size, _a, _Blob, Blob, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ponyfill_es2018 = { exports: {} };
    (function(module, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop3() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        const rethrowAssertionErrorRejection = noop3;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F, V, args) {
          if (typeof F !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F, V, args);
        }
        function promiseCall(F, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i !== elements.length || node._next !== void 0) {
              if (i === elements.length) {
                node = node._next;
                elements = node._elements;
                i = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i]);
              ++i;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve3, reject) => {
            reader._closedPromise_resolve = resolve3;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x) {
          return typeof x === "number" && isFinite(x);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x) {
          return typeof x === "object" || typeof x === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x, context) {
          if (typeof x !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        function assertObject(x, context) {
          if (!isObject(x)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x, position, context) {
          if (x === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x, field, context) {
          if (x === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x) {
          return x === 0 ? 0 : x;
        }
        function integerPart(x) {
          return censorNegativeZero(MathTrunc(x));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x = Number(value);
          x = censorNegativeZero(x);
          if (!NumberIsFinite(x)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x) || x === 0) {
            return 0;
          }
          return x;
        }
        function assertReadableStream(x, context) {
          if (!IsReadableStream(x)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve3, reject) => {
              resolvePromise = resolve3;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve3, reject) => {
              resolvePromise = resolve3;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a2) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x) {
          return x !== x;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src2, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src2, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
            return false;
          }
          return x instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableByteStreamControllerError(controller, e);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              readIntoRequest._errorSteps(e);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              throw e;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableByteStreamControllerError(controller, r);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve3, reject) => {
              resolvePromise = resolve3;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x, context) {
          if (!IsWritableStream(x)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a2) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
            return false;
          }
          return x instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a2;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve3, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve3,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve3, reject) => {
            const closeRequest = {
              _resolve: resolve3,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve3, reject) => {
            const writeRequest = {
              _resolve: resolve3,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve3, reject) => {
            writer._closedPromise_resolve = resolve3;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve3, reject) => {
            writer._readyPromise_resolve = resolve3;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a2) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve3, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop3);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve3(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableStreamDefaultControllerError(controller, e);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableStreamDefaultControllerError(controller, r);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve3) => {
            resolveCancelPromise = resolve3;
          });
          function pullAlgorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve3) => {
            resolveCancelPromise = resolve3;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r);
              ReadableByteStreamControllerError(branch2._readableStreamController, r);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, `${context} has member 'readable' that`);
          const writable2 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable2, "writable", "ReadableWritablePair");
          assertWritableStream(writable2, `${context} has member 'writable' that`);
          return { readable, writable: writable2 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
            return false;
          }
          return x instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop3);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e) {
          stream._state = "errored";
          stream._storedError = e;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve3) => {
              startPromise_resolve = resolve3;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
            return false;
          }
          return x instanceof TransformStream;
        }
        function TransformStreamError(stream, e) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve3) => {
            stream._backpressureChangePromise_resolve = resolve3;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
            return false;
          }
          return x instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e) {
          TransformStreamError(controller._controlledTransformStream, e);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r) => {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable2 = stream._writable;
              const state = writable2._state;
              if (state === "erroring") {
                throw writable2._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, (r) => {
            TransformStreamError(stream, r);
            throw readable._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = __require("process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, __require("stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob2 } = __require("buffer");
      if (Blob2 && !Blob2.prototype.stream) {
        Blob2.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = (_a = class {
      constructor(blobParts = [], options2 = {}) {
        __privateAdd(this, _parts, []);
        __privateAdd(this, _type, "");
        __privateAdd(this, _size, 0);
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options2 !== "object" && typeof options2 !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options2 === null)
          options2 = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof _a) {
            part = element;
          } else {
            part = encoder.encode(element);
          }
          __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));
          __privateGet(this, _parts).push(part);
        }
        const type = options2.type === void 0 ? "" : String(options2.type);
        __privateSet(this, _type, /^[\x20-\x7E]*$/.test(type) ? type : "");
      }
      get size() {
        return __privateGet(this, _size);
      }
      get type() {
        return __privateGet(this, _type);
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(__privateGet(this, _parts), false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(__privateGet(this, _parts), false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(__privateGet(this, _parts), true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = __privateGet(this, _parts);
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new _a([], { type: String(type).toLowerCase() });
        __privateSet(blob, _size, span);
        __privateSet(blob, _parts, blobParts);
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    }, _parts = new WeakMap(), _type = new WeakMap(), _size = new WeakMap(), _a);
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob = _Blob;
    Blob$1 = Blob;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => randomBytes(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof Stream)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = Stream.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof Stream) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough({ highWaterMark });
        p2 = new PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof Stream) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        Stream.Readable.from(body.stream()).pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof http.validateHeaderName === "function" ? http.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof http.validateHeaderValue === "function" ? http.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return format(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-node/files/shims.js
import { createRequire } from "module";
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-node/files/shims.js"() {
    init_install_fetch();
    Object.defineProperty(globalThis, "require", {
      enumerable: true,
      value: createRequire(import.meta.url)
    });
  }
});

// node_modules/playwright-core/lib/utils/errors.js
var require_errors = __commonJS({
  "node_modules/playwright-core/lib/utils/errors.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSafeCloseError = isSafeCloseError;
    exports.kBrowserOrContextClosedError = exports.kBrowserClosedError = exports.TimeoutError = void 0;
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    var TimeoutError = class extends CustomError {
    };
    exports.TimeoutError = TimeoutError;
    var kBrowserClosedError = "Browser has been closed";
    exports.kBrowserClosedError = kBrowserClosedError;
    var kBrowserOrContextClosedError = "Target page, context or browser has been closed";
    exports.kBrowserOrContextClosedError = kBrowserOrContextClosedError;
    function isSafeCloseError(error2) {
      return error2.message.endsWith(kBrowserClosedError) || error2.message.endsWith(kBrowserOrContextClosedError);
    }
  }
});

// node_modules/playwright-core/lib/protocol/serializers.js
var require_serializers = __commonJS({
  "node_modules/playwright-core/lib/protocol/serializers.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.serializeError = serializeError;
    exports.parseError = parseError;
    exports.parseSerializedValue = parseSerializedValue;
    exports.serializeValue = serializeValue;
    var _errors = require_errors();
    function serializeError(e) {
      if (isError(e))
        return {
          error: {
            message: e.message,
            stack: e.stack,
            name: e.name
          }
        };
      return {
        value: serializeValue(e, (value) => ({
          fallThrough: value
        }), new Set())
      };
    }
    function parseError(error2) {
      if (!error2.error) {
        if (error2.value === void 0)
          throw new Error("Serialized error must have either an error or a value");
        return parseSerializedValue(error2.value, void 0);
      }
      if (error2.error.name === "TimeoutError") {
        const e2 = new _errors.TimeoutError(error2.error.message);
        e2.stack = error2.error.stack || "";
        return e2;
      }
      const e = new Error(error2.error.message);
      e.stack = error2.error.stack || "";
      e.name = error2.error.name;
      return e;
    }
    function parseSerializedValue(value, handles) {
      if (value.n !== void 0)
        return value.n;
      if (value.s !== void 0)
        return value.s;
      if (value.b !== void 0)
        return value.b;
      if (value.v !== void 0) {
        if (value.v === "undefined")
          return void 0;
        if (value.v === "null")
          return null;
        if (value.v === "NaN")
          return NaN;
        if (value.v === "Infinity")
          return Infinity;
        if (value.v === "-Infinity")
          return -Infinity;
        if (value.v === "-0")
          return -0;
      }
      if (value.d !== void 0)
        return new Date(value.d);
      if (value.r !== void 0)
        return new RegExp(value.r.p, value.r.f);
      if (value.a !== void 0)
        return value.a.map((a) => parseSerializedValue(a, handles));
      if (value.o !== void 0) {
        const result = {};
        for (const {
          k,
          v
        } of value.o)
          result[k] = parseSerializedValue(v, handles);
        return result;
      }
      if (value.h !== void 0) {
        if (handles === void 0)
          throw new Error("Unexpected handle");
        return handles[value.h];
      }
      throw new Error("Unexpected value");
    }
    function serializeValue(value, handleSerializer, visited) {
      const handle = handleSerializer(value);
      if ("fallThrough" in handle)
        value = handle.fallThrough;
      else
        return handle;
      if (visited.has(value))
        throw new Error("Argument is a circular structure");
      if (typeof value === "symbol")
        return {
          v: "undefined"
        };
      if (Object.is(value, void 0))
        return {
          v: "undefined"
        };
      if (Object.is(value, null))
        return {
          v: "null"
        };
      if (Object.is(value, NaN))
        return {
          v: "NaN"
        };
      if (Object.is(value, Infinity))
        return {
          v: "Infinity"
        };
      if (Object.is(value, -Infinity))
        return {
          v: "-Infinity"
        };
      if (Object.is(value, -0))
        return {
          v: "-0"
        };
      if (typeof value === "boolean")
        return {
          b: value
        };
      if (typeof value === "number")
        return {
          n: value
        };
      if (typeof value === "string")
        return {
          s: value
        };
      if (isError(value)) {
        const error2 = value;
        if ("captureStackTrace" in global.Error) {
          return {
            s: error2.stack || ""
          };
        }
        return {
          s: `${error2.name}: ${error2.message}
${error2.stack}`
        };
      }
      if (isDate(value))
        return {
          d: value.toJSON()
        };
      if (isRegExp(value))
        return {
          r: {
            p: value.source,
            f: value.flags
          }
        };
      if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
          a.push(serializeValue(value[i], handleSerializer, visited));
        visited.delete(value);
        return {
          a
        };
      }
      if (typeof value === "object") {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value))
          o.push({
            k: name,
            v: serializeValue(value[name], handleSerializer, visited)
          });
        visited.delete(value);
        return {
          o
        };
      }
      throw new Error("Unexpected value");
    }
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isError(obj) {
      var _obj$__proto__;
      return obj instanceof Error || (obj === null || obj === void 0 ? void 0 : (_obj$__proto__ = obj.__proto__) === null || _obj$__proto__ === void 0 ? void 0 : _obj$__proto__.name) === "Error" || (obj === null || obj === void 0 ? void 0 : obj.__proto__) && isError(obj.__proto__);
    }
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports) {
    init_shims();
    var pathModule = __require("path");
    var isWindows = process.platform === "win32";
    var fs2 = __require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize3 = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base2;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base2 = m[0];
        previous = "";
        if (isWindows && !knownHard[base2]) {
          fs2.lstatSync(base2);
          knownHard[base2] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base2 = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base2] || cache && cache[base2] === base2) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base2)) {
          resolvedLink = cache[base2];
        } else {
          var stat = fs2.lstatSync(base2);
          if (!stat.isSymbolicLink()) {
            knownHard[base2] = true;
            if (cache)
              cache[base2] = base2;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs2.statSync(base2);
            linkTarget = fs2.readlinkSync(base2);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base2] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base2;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base2 = m[0];
        previous = "";
        if (isWindows && !knownHard[base2]) {
          fs2.lstat(base2, function(err) {
            if (err)
              return cb(err);
            knownHard[base2] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base2 = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base2] || cache && cache[base2] === base2) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base2)) {
          return gotResolvedLink(cache[base2]);
        }
        return fs2.lstat(base2, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base2] = true;
          if (cache)
            cache[base2] = base2;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base2);
          }
        }
        fs2.stat(base2, function(err2) {
          if (err2)
            return cb(err2);
          fs2.readlink(base2, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base3) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base3] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports, module) {
    init_shims();
    module.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs2 = __require("fs");
    var origRealpath = fs2.realpath;
    var origRealpathSync = fs2.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs2.realpath = realpath;
      fs2.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs2.realpath = origRealpath;
      fs2.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module) {
    init_shims();
    module.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module) {
    init_shims();
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module) {
    init_shims();
    module.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = { sep: "/" };
    try {
      path = __require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s2) {
      return s2.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options2) {
      options2 = options2 || {};
      return function(p, i, list2) {
        return minimatch(p, pattern, options2);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options2) {
        return orig.minimatch(p, pattern, ext(def, options2));
      };
      m.Minimatch = function Minimatch2(pattern, options2) {
        return new orig.Minimatch(pattern, ext(def, options2));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options2) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options2).match(p);
    }
    function Minimatch(pattern, options2) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options2);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options2;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options2 = this.options;
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options2.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s2) {
        return s2.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s2, si, set2) {
        return s2.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s2) {
        return s2.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options2 = this.options;
      var negateOffset = 0;
      if (options2.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options2) {
      return braceExpand(pattern, options2);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options2) {
      if (!options2) {
        if (this instanceof Minimatch) {
          options2 = this.options;
        } else {
          options2 = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options2.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse3;
    var SUBPARSE = {};
    function parse3(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options2 = this.options;
      if (!options2.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options2.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options2.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options2.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options2) {
      return new Minimatch(pattern, options2 || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options2 = this.options;
      var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
      var flags = options2.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list2, pattern, options2) {
      options2 = options2 || {};
      var mm = new Minimatch(pattern, options2);
      list2 = list2.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern);
      }
      return list2;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options2 = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options2.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options2.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options2.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options2 = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options2.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s2) {
      return s2.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s2) {
      return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    init_shims();
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module) {
    init_shims();
    try {
      util = __require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module.exports = util.inherits;
    } catch (e) {
      module.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports, module) {
    init_shims();
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module.exports = process.platform === "win32" ? win32 : posix;
    module.exports.posix = posix;
    module.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common = __commonJS({
  "node_modules/glob/common.js"(exports) {
    init_shims();
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs2 = __require("fs");
    var path = __require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options2) {
      self2.ignore = options2.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options2) {
      if (!options2)
        options2 = {};
      if (options2.matchBase && pattern.indexOf("/") === -1) {
        if (options2.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options2.silent;
      self2.pattern = pattern;
      self2.strict = options2.strict !== false;
      self2.realpath = !!options2.realpath;
      self2.realpathCache = options2.realpathCache || Object.create(null);
      self2.follow = !!options2.follow;
      self2.dot = !!options2.dot;
      self2.mark = !!options2.mark;
      self2.nodir = !!options2.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options2.sync;
      self2.nounique = !!options2.nounique;
      self2.nonull = !!options2.nonull;
      self2.nosort = !!options2.nosort;
      self2.nocase = !!options2.nocase;
      self2.stat = !!options2.stat;
      self2.noprocess = !!options2.noprocess;
      self2.absolute = !!options2.absolute;
      self2.fs = options2.fs || fs2;
      self2.maxLength = options2.maxLength || Infinity;
      self2.cache = options2.cache || Object.create(null);
      self2.statCache = options2.statCache || Object.create(null);
      self2.symlinks = options2.symlinks || Object.create(null);
      setupIgnores(self2, options2);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options2, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options2.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options2.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options2.nomount;
      options2.nonegate = true;
      options2.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options2);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports, module) {
    init_shims();
    module.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = __require("util");
    var path = __require("path");
    var assert = __require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options2) {
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options2).found;
    }
    function GlobSync(pattern, options2) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options2);
      setopts(this, pattern, options2);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            throw error2;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    init_shims();
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    init_shims();
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports, module) {
    init_shims();
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports, module) {
    init_shims();
    module.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = __require("events").EventEmitter;
    var path = __require("path");
    var assert = __require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = __require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = {};
      if (!options2)
        options2 = {};
      if (options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options2);
      }
      return new Glob(pattern, options2, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options2 = extend({}, options_);
      options2.noprocess = true;
      var g = new Glob(pattern, options2);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = null;
      }
      if (options2 && options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options2);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options2, cb);
      setopts(this, pattern, options2);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            this.emit("error", error2);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/rimraf/rimraf.js"(exports, module) {
    init_shims();
    var assert = __require("assert");
    var path = __require("path");
    var fs2 = __require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options2) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options2[m] = options2[m] || fs2[m];
        m = m + "Sync";
        options2[m] = options2[m] || fs2[m];
      });
      options2.maxBusyTries = options2.maxBusyTries || 3;
      options2.emfileWait = options2.emfileWait || 1e3;
      if (options2.glob === false) {
        options2.disableGlob = true;
      }
      if (options2.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options2.disableGlob = options2.disableGlob || false;
      options2.glob = options2.glob || defaultGlobOpts;
    };
    var rimraf = (p, options2, cb) => {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options2, "rimraf: invalid options argument provided");
      assert.equal(typeof options2, "object", "rimraf: options should be object");
      defaults(options2);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options2.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options2, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options2.emfileWait) {
                return setTimeout(() => rimraf_(p2, options2, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options2, CB);
        });
      };
      if (options2.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options2.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options2.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options2, cb) => {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options2, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options2, er, cb);
        options2.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options2, er2, cb) : rmdir(p, options2, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options2, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options2, er, cb) => {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options2.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options2, er, cb);
            else
              options2.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options2, er) => {
      assert(p);
      assert(options2);
      try {
        options2.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options2.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options2, er);
      else
        options2.unlinkSync(p);
    };
    var rmdir = (p, options2, originalEr, cb) => {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options2, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options2, cb) => {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options2.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path.join(p, f), options2, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options2.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options2) => {
      options2 = options2 || {};
      defaults(options2);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options2, "rimraf: missing options");
      assert.equal(typeof options2, "object", "rimraf: options should be object");
      let results;
      if (options2.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options2.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options2.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options2.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options2, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options2, null);
          else
            options2.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options2, er) : rmdirSync(p2, options2, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options2, er);
        }
      }
    };
    var rmdirSync = (p, options2, originalEr) => {
      assert(p);
      assert(options2);
      try {
        options2.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options2);
      }
    };
    var rmkidsSync = (p, options2) => {
      assert(p);
      assert(options2);
      options2.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options2));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options2.rmdirSync(p, options2);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports) {
    init_shims();
    "use strict";
    var parseUrl = __require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s2) {
      return s2.length <= this.length && this.indexOf(s2, this.length - s2.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/playwright-core/lib/utils/ubuntuVersion.js
var require_ubuntuVersion = __commonJS({
  "node_modules/playwright-core/lib/utils/ubuntuVersion.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getUbuntuVersion = getUbuntuVersion;
    exports.getUbuntuVersionSync = getUbuntuVersionSync;
    var _fs = _interopRequireDefault(__require("fs"));
    var os = _interopRequireWildcard(__require("os"));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ubuntuVersionCached;
    async function getUbuntuVersion() {
      if (ubuntuVersionCached === void 0)
        ubuntuVersionCached = await getUbuntuVersionAsyncInternal();
      return ubuntuVersionCached;
    }
    function getUbuntuVersionSync() {
      if (ubuntuVersionCached === void 0)
        ubuntuVersionCached = getUbuntuVersionSyncInternal();
      return ubuntuVersionCached;
    }
    async function getUbuntuVersionAsyncInternal() {
      if (os.platform() !== "linux")
        return "";
      let osReleaseText = await _fs.default.promises.readFile("/etc/upstream-release/lsb-release", "utf8").catch((e) => "");
      if (!osReleaseText)
        osReleaseText = await _fs.default.promises.readFile("/etc/os-release", "utf8").catch((e) => "");
      if (!osReleaseText)
        return "";
      return parseUbuntuVersion(osReleaseText);
    }
    function getUbuntuVersionSyncInternal() {
      if (os.platform() !== "linux")
        return "";
      try {
        let osReleaseText;
        if (_fs.default.existsSync("/etc/upstream-release/lsb-release"))
          osReleaseText = _fs.default.readFileSync("/etc/upstream-release/lsb-release", "utf8");
        else
          osReleaseText = _fs.default.readFileSync("/etc/os-release", "utf8");
        if (!osReleaseText)
          return "";
        return parseUbuntuVersion(osReleaseText);
      } catch (e) {
        return "";
      }
    }
    function parseUbuntuVersion(osReleaseText) {
      const fields = new Map();
      for (const line of osReleaseText.split("\n")) {
        const tokens = line.split("=");
        const name = tokens.shift();
        let value = tokens.join("=").trim();
        if (value.startsWith('"') && value.endsWith('"'))
          value = value.substring(1, value.length - 1);
        if (!name)
          continue;
        fields.set(name.toLowerCase(), value);
      }
      if (fields.get("distrib_id") && fields.get("distrib_id").toLowerCase() === "ubuntu")
        return fields.get("distrib_release") || "";
      if (!fields.get("name") || fields.get("name").toLowerCase() !== "ubuntu")
        return "";
      return fields.get("version_id") || "";
    }
  }
});

// node_modules/progress/lib/node-progress.js
var require_node_progress = __commonJS({
  "node_modules/progress/lib/node-progress.js"(exports, module) {
    init_shims();
    exports = module.exports = ProgressBar;
    function ProgressBar(fmt, options2) {
      this.stream = options2.stream || process.stderr;
      if (typeof options2 == "number") {
        var total = options2;
        options2 = {};
        options2.total = total;
      } else {
        options2 = options2 || {};
        if (typeof fmt != "string")
          throw new Error("format required");
        if (typeof options2.total != "number")
          throw new Error("total required");
      }
      this.fmt = fmt;
      this.curr = options2.curr || 0;
      this.total = options2.total;
      this.width = options2.width || this.total;
      this.clear = options2.clear;
      this.chars = {
        complete: options2.complete || "=",
        incomplete: options2.incomplete || "-",
        head: options2.head || (options2.complete || "=")
      };
      this.renderThrottle = options2.renderThrottle !== 0 ? options2.renderThrottle || 16 : 0;
      this.lastRender = -Infinity;
      this.callback = options2.callback || function() {
      };
      this.tokens = {};
      this.lastDraw = "";
    }
    ProgressBar.prototype.tick = function(len, tokens) {
      if (len !== 0)
        len = len || 1;
      if (typeof len == "object")
        tokens = len, len = 1;
      if (tokens)
        this.tokens = tokens;
      if (this.curr == 0)
        this.start = new Date();
      this.curr += len;
      this.render();
      if (this.curr >= this.total) {
        this.render(void 0, true);
        this.complete = true;
        this.terminate();
        this.callback(this);
        return;
      }
    };
    ProgressBar.prototype.render = function(tokens, force) {
      force = force !== void 0 ? force : false;
      if (tokens)
        this.tokens = tokens;
      if (!this.stream.isTTY)
        return;
      var now = Date.now();
      var delta = now - this.lastRender;
      if (!force && delta < this.renderThrottle) {
        return;
      } else {
        this.lastRender = now;
      }
      var ratio = this.curr / this.total;
      ratio = Math.min(Math.max(ratio, 0), 1);
      var percent = Math.floor(ratio * 100);
      var incomplete, complete, completeLength;
      var elapsed = new Date() - this.start;
      var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
      var rate = this.curr / (elapsed / 1e3);
      var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
      var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
      if (availableSpace && process.platform === "win32") {
        availableSpace = availableSpace - 1;
      }
      var width = Math.min(this.width, availableSpace);
      completeLength = Math.round(width * ratio);
      complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
      incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
      if (completeLength > 0)
        complete = complete.slice(0, -1) + this.chars.head;
      str = str.replace(":bar", complete + incomplete);
      if (this.tokens)
        for (var key in this.tokens)
          str = str.replace(":" + key, this.tokens[key]);
      if (this.lastDraw !== str) {
        this.stream.cursorTo(0);
        this.stream.write(str);
        this.stream.clearLine(1);
        this.lastDraw = str;
      }
    };
    ProgressBar.prototype.update = function(ratio, tokens) {
      var goal = Math.floor(ratio * this.total);
      var delta = goal - this.curr;
      this.tick(delta, tokens);
    };
    ProgressBar.prototype.interrupt = function(message) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
      this.stream.write(message);
      this.stream.write("\n");
      this.stream.write(this.lastDraw);
    };
    ProgressBar.prototype.terminate = function() {
      if (this.clear) {
        if (this.stream.clearLine) {
          this.stream.clearLine();
          this.stream.cursorTo(0);
        }
      } else {
        this.stream.write("\n");
      }
    };
  }
});

// node_modules/progress/index.js
var require_progress = __commonJS({
  "node_modules/progress/index.js"(exports, module) {
    init_shims();
    module.exports = require_node_progress();
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    init_shims();
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    init_shims();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    init_shims();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = require_common2()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    init_shims();
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init2;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = __require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common2()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    init_shims();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve3, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve3(rtn);
            }
          });
        });
      };
    }
    exports.default = promisify;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports, module) {
    init_shims();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = __require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module.exports = createAgent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    init_shims();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve3, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve3({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports) {
    init_shims();
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = __importDefault(__require("net"));
    var tls_1 = __importDefault(__require("tls"));
    var url_1 = __importDefault(__require("url"));
    var assert_1 = __importDefault(__require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s2) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s2.listenerCount("data") > 0);
            s2.push(buffered);
            s2.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module.exports = createHttpsProxyAgent;
  }
});

// node_modules/playwright-core/package.json
var require_package = __commonJS({
  "node_modules/playwright-core/package.json"(exports, module) {
    module.exports = {
      name: "playwright-core",
      version: "1.17.1",
      description: "A high-level API to automate web browsers",
      repository: "github:Microsoft/playwright",
      homepage: "https://playwright.dev",
      engines: {
        node: ">=12"
      },
      scripts: {
        prepare: 'babel --config-file ../../babel.config.json -s --extensions ".ts" --out-dir lib/utils/ src/utils'
      },
      author: {
        name: "Microsoft Corporation"
      },
      license: "Apache-2.0",
      exports: {
        ".": {
          import: "./index.mjs",
          require: "./index.js"
        },
        "./cli": "./cli.js",
        "./package.json": "./package.json",
        "./lib/grid/gridServer": "./lib/grid/gridServer.js",
        "./lib/grid/gridClient": "./lib/grid/gridClient.js",
        "./lib/grid/dockerGridFactory": "./lib/grid/dockerGridFactory.js",
        "./lib/utils/async": "./lib/utils/async.js",
        "./lib/utils/httpServer": "./lib/utils/httpServer.js",
        "./lib/utils/multimap": "./lib/utils/multimap.js",
        "./lib/utils/processLauncher": "./lib/utils/processLauncher.js",
        "./lib/utils/registry": "./lib/utils/registry.js",
        "./lib/utils/utils": "./lib/utils/utils.js"
      },
      types: "types/types.d.ts",
      bin: {
        playwright: "./cli.js"
      },
      dependencies: {
        commander: "^8.2.0",
        debug: "^4.1.1",
        "extract-zip": "^2.0.1",
        "https-proxy-agent": "^5.0.0",
        "jpeg-js": "^0.4.2",
        mime: "^2.4.6",
        pngjs: "^5.0.0",
        progress: "^2.0.3",
        "proper-lockfile": "^4.1.1",
        "proxy-from-env": "^1.1.0",
        rimraf: "^3.0.2",
        "socks-proxy-agent": "^6.1.0",
        "stack-utils": "^2.0.3",
        ws: "^7.4.6",
        yauzl: "^2.10.0",
        yazl: "^2.5.1"
      }
    };
  }
});

// node_modules/playwright-core/lib/utils/utils.js
var require_utils = __commonJS({
  "node_modules/playwright-core/lib/utils/utils.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fetchData = fetchData;
    exports.download = download;
    exports.spawnAsync = spawnAsync;
    exports.makeWaitForNextTask = makeWaitForNextTask;
    exports.assert = assert;
    exports.debugAssert = debugAssert;
    exports.isString = isString;
    exports.isRegExp = isRegExp;
    exports.isObject = isObject;
    exports.isError = isError;
    exports.debugMode = debugMode;
    exports.setUnderTest = setUnderTest;
    exports.isUnderTest = isUnderTest;
    exports.getFromENV = getFromENV;
    exports.getAsBooleanFromENV = getAsBooleanFromENV;
    exports.mkdirIfNeeded = mkdirIfNeeded;
    exports.headersObjectToArray = headersObjectToArray;
    exports.headersArrayToObject = headersArrayToObject;
    exports.monotonicTime = monotonicTime;
    exports.objectToArray = objectToArray;
    exports.arrayToObject = arrayToObject;
    exports.calculateFileSha1 = calculateFileSha1;
    exports.calculateSha1 = calculateSha1;
    exports.createGuid = createGuid;
    exports.removeFolders = removeFolders;
    exports.canAccessFile = canAccessFile;
    exports.getUserAgent = getUserAgent;
    exports.getPlaywrightVersion = getPlaywrightVersion;
    exports.constructURLBasedOnBaseURL = constructURLBasedOnBaseURL;
    exports.wrapInASCIIBox = wrapInASCIIBox;
    exports.isFilePayload = isFilePayload;
    exports.streamToString = streamToString;
    exports.hostPlatform = exports.existsAsync = void 0;
    var _path = _interopRequireDefault(__require("path"));
    var _fs = _interopRequireDefault(__require("fs"));
    var _stream = _interopRequireDefault(__require("stream"));
    var _rimraf = _interopRequireDefault(require_rimraf());
    var crypto = _interopRequireWildcard(__require("crypto"));
    var _os = _interopRequireDefault(__require("os"));
    var _http = _interopRequireDefault(__require("http"));
    var _https = _interopRequireDefault(__require("https"));
    var _child_process = __require("child_process");
    var _proxyFromEnv = require_proxy_from_env();
    var URL2 = _interopRequireWildcard(__require("url"));
    var _ubuntuVersion = require_ubuntuVersion();
    var _progress = _interopRequireDefault(require_progress());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ProxyAgent = require_dist();
    var existsAsync = (path) => new Promise((resolve3) => _fs.default.stat(path, (err) => resolve3(!err)));
    exports.existsAsync = existsAsync;
    function httpRequest(params, onResponse, onError) {
      const parsedUrl = URL2.parse(params.url);
      let options2 = __spreadValues({}, parsedUrl);
      options2.method = params.method || "GET";
      options2.headers = params.headers;
      const proxyURL = (0, _proxyFromEnv.getProxyForUrl)(params.url);
      if (proxyURL) {
        if (params.url.startsWith("http:")) {
          const proxy = URL2.parse(proxyURL);
          options2 = {
            path: parsedUrl.href,
            host: proxy.hostname,
            port: proxy.port
          };
        } else {
          const parsedProxyURL = URL2.parse(proxyURL);
          parsedProxyURL.secureProxy = parsedProxyURL.protocol === "https:";
          options2.agent = new ProxyAgent(parsedProxyURL);
          options2.rejectUnauthorized = false;
        }
      }
      const requestCallback = (res) => {
        const statusCode = res.statusCode || 0;
        if (statusCode >= 300 && statusCode < 400 && res.headers.location)
          httpRequest(__spreadProps(__spreadValues({}, params), {
            url: res.headers.location
          }), onResponse, onError);
        else
          onResponse(res);
      };
      const request = options2.protocol === "https:" ? _https.default.request(options2, requestCallback) : _http.default.request(options2, requestCallback);
      request.on("error", onError);
      if (params.timeout !== void 0) {
        const rejectOnTimeout = () => {
          onError(new Error(`Request to ${params.url} timed out after ${params.timeout}ms`));
          request.abort();
        };
        if (params.timeout <= 0) {
          rejectOnTimeout();
          return;
        }
        request.setTimeout(params.timeout, rejectOnTimeout);
      }
      request.end(params.data);
    }
    function fetchData(params, onError) {
      return new Promise((resolve3, reject) => {
        httpRequest(params, async (response) => {
          if (response.statusCode !== 200) {
            const error2 = onError ? await onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);
            reject(error2);
            return;
          }
          let body = "";
          response.on("data", (chunk) => body += chunk);
          response.on("error", (error2) => reject(error2));
          response.on("end", () => resolve3(body));
        }, reject);
      });
    }
    function downloadFile(url, destinationPath, options2 = {}) {
      const {
        progressCallback,
        log = () => {
        }
      } = options2;
      log(`running download:`);
      log(`-- from url: ${url}`);
      log(`-- to location: ${destinationPath}`);
      let fulfill = ({
        error: error2
      }) => {
      };
      let downloadedBytes = 0;
      let totalBytes = 0;
      const promise = new Promise((x) => {
        fulfill = x;
      });
      httpRequest({
        url
      }, (response) => {
        log(`-- response status code: ${response.statusCode}`);
        if (response.statusCode !== 200) {
          const error2 = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
          response.resume();
          fulfill({
            error: error2
          });
          return;
        }
        const file = _fs.default.createWriteStream(destinationPath);
        file.on("finish", () => fulfill({
          error: null
        }));
        file.on("error", (error2) => fulfill({
          error: error2
        }));
        response.pipe(file);
        totalBytes = parseInt(response.headers["content-length"] || "0", 10);
        log(`-- total bytes: ${totalBytes}`);
        if (progressCallback)
          response.on("data", onData);
      }, (error2) => fulfill({
        error: error2
      }));
      return promise;
      function onData(chunk) {
        downloadedBytes += chunk.length;
        progressCallback(downloadedBytes, totalBytes);
      }
    }
    async function download(url, destination, options2 = {}) {
      const {
        progressBarName = "file",
        retryCount = 3,
        log = () => {
        }
      } = options2;
      for (let attempt = 1; attempt <= retryCount; ++attempt) {
        log(`downloading ${progressBarName} - attempt #${attempt}`);
        const {
          error: error2
        } = await downloadFile(url, destination, {
          progressCallback: getDownloadProgress(progressBarName),
          log
        });
        if (!error2) {
          log(`SUCCESS downloading ${progressBarName}`);
          break;
        }
        const errorMessage = (error2 === null || error2 === void 0 ? void 0 : error2.message) || "";
        log(`attempt #${attempt} - ERROR: ${errorMessage}`);
        if (attempt < retryCount && (errorMessage.includes("ECONNRESET") || errorMessage.includes("ETIMEDOUT"))) {
          const millis = Math.random() * 200 + 250 * Math.pow(1.5, attempt);
          log(`sleeping ${millis}ms before retry...`);
          await new Promise((c) => setTimeout(c, millis));
        } else {
          throw error2;
        }
      }
    }
    function getDownloadProgress(progressBarName) {
      let progressBar;
      let lastDownloadedBytes = 0;
      return (downloadedBytes, totalBytes) => {
        if (!process.stderr.isTTY)
          return;
        if (!progressBar) {
          progressBar = new _progress.default(`Downloading ${progressBarName} - ${toMegabytes(totalBytes)} [:bar] :percent :etas `, {
            complete: "=",
            incomplete: " ",
            width: 20,
            total: totalBytes
          });
        }
        const delta = downloadedBytes - lastDownloadedBytes;
        lastDownloadedBytes = downloadedBytes;
        progressBar.tick(delta);
      };
    }
    function toMegabytes(bytes) {
      const mb = bytes / 1024 / 1024;
      return `${Math.round(mb * 10) / 10} Mb`;
    }
    function spawnAsync(cmd, args, options2 = {}) {
      const process2 = (0, _child_process.spawn)(cmd, args, options2);
      return new Promise((resolve3) => {
        let stdout = "";
        let stderr = "";
        if (process2.stdout)
          process2.stdout.on("data", (data) => stdout += data);
        if (process2.stderr)
          process2.stderr.on("data", (data) => stderr += data);
        process2.on("close", (code) => resolve3({
          stdout,
          stderr,
          code
        }));
        process2.on("error", (error2) => resolve3({
          stdout,
          stderr,
          code: 0,
          error: error2
        }));
      });
    }
    function makeWaitForNextTask() {
      if (process.versions.electron)
        return (callback) => setTimeout(callback, 0);
      if (parseInt(process.versions.node, 10) >= 11)
        return setImmediate;
      let spinning = false;
      const callbacks = [];
      const loop = () => {
        const callback = callbacks.shift();
        if (!callback) {
          spinning = false;
          return;
        }
        setImmediate(loop);
        callback();
      };
      return (callback) => {
        callbacks.push(callback);
        if (!spinning) {
          spinning = true;
          setImmediate(loop);
        }
      };
    }
    function assert(value, message) {
      if (!value)
        throw new Error(message || "Assertion error");
    }
    function debugAssert(value, message) {
      if (isUnderTest() && !value)
        throw new Error(message);
    }
    function isString(obj) {
      return typeof obj === "string" || obj instanceof String;
    }
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isObject(obj) {
      return typeof obj === "object" && obj !== null;
    }
    function isError(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
    var debugEnv = getFromENV("PWDEBUG") || "";
    function debugMode() {
      if (debugEnv === "console")
        return "console";
      return debugEnv ? "inspector" : "";
    }
    var _isUnderTest = false;
    function setUnderTest() {
      _isUnderTest = true;
    }
    function isUnderTest() {
      return _isUnderTest;
    }
    function getFromENV(name) {
      let value = process.env[name];
      value = value === void 0 ? process.env[`npm_config_${name.toLowerCase()}`] : value;
      value = value === void 0 ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
      return value;
    }
    function getAsBooleanFromENV(name) {
      const value = getFromENV(name);
      return !!value && value !== "false" && value !== "0";
    }
    async function mkdirIfNeeded(filePath) {
      await _fs.default.promises.mkdir(_path.default.dirname(filePath), {
        recursive: true
      }).catch(() => {
      });
    }
    function headersObjectToArray(headers, separator, setCookieSeparator) {
      if (!setCookieSeparator)
        setCookieSeparator = separator;
      const result = [];
      for (const name in headers) {
        const values = headers[name];
        if (separator) {
          const sep = name.toLowerCase() === "set-cookie" ? setCookieSeparator : separator;
          for (const value of values.split(sep))
            result.push({
              name,
              value: value.trim()
            });
        } else {
          result.push({
            name,
            value: values
          });
        }
      }
      return result;
    }
    function headersArrayToObject(headers, lowerCase) {
      const result = {};
      for (const {
        name,
        value
      } of headers)
        result[lowerCase ? name.toLowerCase() : name] = value;
      return result;
    }
    function monotonicTime() {
      const [seconds, nanoseconds] = process.hrtime();
      return seconds * 1e3 + (nanoseconds / 1e3 | 0) / 1e3;
    }
    var HashStream = class extends _stream.default.Writable {
      constructor(...args) {
        super(...args);
        this._hash = crypto.createHash("sha1");
      }
      _write(chunk, encoding, done) {
        this._hash.update(chunk);
        done();
      }
      digest() {
        return this._hash.digest("hex");
      }
    };
    function objectToArray(map) {
      if (!map)
        return void 0;
      const result = [];
      for (const [name, value] of Object.entries(map))
        result.push({
          name,
          value: String(value)
        });
      return result;
    }
    function arrayToObject(array) {
      if (!array)
        return void 0;
      const result = {};
      for (const {
        name,
        value
      } of array)
        result[name] = value;
      return result;
    }
    async function calculateFileSha1(filename) {
      const hashStream = new HashStream();
      const stream = _fs.default.createReadStream(filename);
      stream.on("open", () => stream.pipe(hashStream));
      await new Promise((f, r) => {
        hashStream.on("finish", f);
        hashStream.on("error", r);
      });
      return hashStream.digest();
    }
    function calculateSha1(buffer) {
      const hash2 = crypto.createHash("sha1");
      hash2.update(buffer);
      return hash2.digest("hex");
    }
    function createGuid() {
      return crypto.randomBytes(16).toString("hex");
    }
    async function removeFolders(dirs) {
      return await Promise.all(dirs.map((dir) => {
        return new Promise((fulfill) => {
          (0, _rimraf.default)(dir, {
            maxBusyTries: 10
          }, (error2) => {
            fulfill(error2 !== null && error2 !== void 0 ? error2 : void 0);
          });
        });
      }));
    }
    function canAccessFile(file) {
      if (!file)
        return false;
      try {
        _fs.default.accessSync(file);
        return true;
      } catch (e) {
        return false;
      }
    }
    function getUserAgent() {
      return `Playwright/${getPlaywrightVersion()} (${_os.default.arch()}/${_os.default.platform()}/${_os.default.release()})`;
    }
    function getPlaywrightVersion(majorMinorOnly = false) {
      const packageJson = require_package();
      return majorMinorOnly ? packageJson.version.split(".").slice(0, 2).join(".") : packageJson.version;
    }
    function constructURLBasedOnBaseURL(baseURL, givenURL) {
      try {
        return new URL2.URL(givenURL, baseURL).toString();
      } catch (e) {
        return givenURL;
      }
    }
    var hostPlatform = (() => {
      const platform = _os.default.platform();
      if (platform === "darwin") {
        const ver = _os.default.release().split(".").map((a) => parseInt(a, 10));
        let macVersion = "";
        if (ver[0] < 18) {
          macVersion = "mac10.13";
        } else if (ver[0] === 18) {
          macVersion = "mac10.14";
        } else if (ver[0] === 19) {
          macVersion = "mac10.15";
        } else {
          const LAST_STABLE_MAC_MAJOR_VERSION = 11;
          macVersion = "mac" + Math.min(ver[0] - 9, LAST_STABLE_MAC_MAJOR_VERSION);
          if (_os.default.cpus().some((cpu) => cpu.model.includes("Apple")))
            macVersion += "-arm64";
        }
        return macVersion;
      }
      if (platform === "linux") {
        const ubuntuVersion = (0, _ubuntuVersion.getUbuntuVersionSync)();
        const archSuffix = _os.default.arch() === "arm64" ? "-arm64" : "";
        if (parseInt(ubuntuVersion, 10) <= 19)
          return "ubuntu18.04" + archSuffix;
        return "ubuntu20.04" + archSuffix;
      }
      if (platform === "win32")
        return "win64";
      return platform;
    })();
    exports.hostPlatform = hostPlatform;
    function wrapInASCIIBox(text, padding = 0) {
      const lines = text.split("\n");
      const maxLength = Math.max(...lines.map((line) => line.length));
      return ["\u2554" + "\u2550".repeat(maxLength + padding * 2) + "\u2557", ...lines.map((line) => "\u2551" + " ".repeat(padding) + line + " ".repeat(maxLength - line.length + padding) + "\u2551"), "\u255A" + "\u2550".repeat(maxLength + padding * 2) + "\u255D"].join("\n");
    }
    function isFilePayload(value) {
      return typeof value === "object" && value["name"] && value["mimeType"] && value["buffer"];
    }
    function streamToString(stream) {
      return new Promise((resolve3, reject) => {
        const chunks = [];
        stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
        stream.on("error", reject);
        stream.on("end", () => resolve3(Buffer.concat(chunks).toString("utf8")));
      });
    }
  }
});

// node_modules/playwright-core/lib/protocol/validatorPrimitives.js
var require_validatorPrimitives = __commonJS({
  "node_modules/playwright-core/lib/protocol/validatorPrimitives.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.tEnum = exports.tObject = exports.tArray = exports.tOptional = exports.tAny = exports.tUndefined = exports.tBinary = exports.tString = exports.tBoolean = exports.tNumber = exports.ValidationError = void 0;
    var _utils = require_utils();
    var ValidationError = class extends Error {
    };
    exports.ValidationError = ValidationError;
    var tNumber = (arg, path) => {
      if (arg instanceof Number)
        return arg.valueOf();
      if (typeof arg === "number")
        return arg;
      throw new ValidationError(`${path}: expected number, got ${typeof arg}`);
    };
    exports.tNumber = tNumber;
    var tBoolean = (arg, path) => {
      if (arg instanceof Boolean)
        return arg.valueOf();
      if (typeof arg === "boolean")
        return arg;
      throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);
    };
    exports.tBoolean = tBoolean;
    var tString = (arg, path) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected string, got ${typeof arg}`);
    };
    exports.tString = tString;
    var tBinary = (arg, path) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);
    };
    exports.tBinary = tBinary;
    var tUndefined = (arg, path) => {
      if (Object.is(arg, void 0))
        return arg;
      throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);
    };
    exports.tUndefined = tUndefined;
    var tAny = (arg, path) => {
      return arg;
    };
    exports.tAny = tAny;
    var tOptional = (v) => {
      return (arg, path) => {
        if (Object.is(arg, void 0))
          return arg;
        return v(arg, path);
      };
    };
    exports.tOptional = tOptional;
    var tArray = (v) => {
      return (arg, path) => {
        if (!Array.isArray(arg))
          throw new ValidationError(`${path}: expected array, got ${typeof arg}`);
        return arg.map((x, index) => v(x, path + "[" + index + "]"));
      };
    };
    exports.tArray = tArray;
    var tObject = (s2) => {
      return (arg, path) => {
        if (Object.is(arg, null))
          throw new ValidationError(`${path}: expected object, got null`);
        if (typeof arg !== "object")
          throw new ValidationError(`${path}: expected object, got ${typeof arg}`);
        const result = {};
        for (const [key, v] of Object.entries(s2)) {
          const value = v(arg[key], path ? path + "." + key : key);
          if (!Object.is(value, void 0))
            result[key] = value;
        }
        if ((0, _utils.isUnderTest)()) {
          for (const [key, value] of Object.entries(arg)) {
            if (key.startsWith("__testHook"))
              result[key] = value;
          }
        }
        return result;
      };
    };
    exports.tObject = tObject;
    var tEnum = (e) => {
      return (arg, path) => {
        if (!e.includes(arg))
          throw new ValidationError(`${path}: expected one of (${e.join("|")})`);
        return arg;
      };
    };
    exports.tEnum = tEnum;
  }
});

// node_modules/playwright-core/lib/protocol/validator.js
var require_validator = __commonJS({
  "node_modules/playwright-core/lib/protocol/validator.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createScheme = createScheme;
    Object.defineProperty(exports, "Validator", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.Validator;
      }
    });
    Object.defineProperty(exports, "ValidationError", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.ValidationError;
      }
    });
    var _validatorPrimitives = require_validatorPrimitives();
    function createScheme(tChannel) {
      const scheme2 = {};
      const tType = (name) => {
        return (arg, path) => {
          const v = scheme2[name];
          if (!v)
            throw new _validatorPrimitives.ValidationError(path + ': unknown type "' + name + '"');
          return v(arg, path);
        };
      };
      scheme2.StackFrame = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tString,
        line: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        column: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        function: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.Metadata = (0, _validatorPrimitives.tObject)({
        stack: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("StackFrame"))),
        apiName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        internal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.Point = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber
      });
      scheme2.Rect = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      });
      scheme2.SerializedValue = (0, _validatorPrimitives.tObject)({
        n: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        b: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        s: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        v: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["null", "undefined", "NaN", "Infinity", "-Infinity", "-0"])),
        d: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        r: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          p: _validatorPrimitives.tString,
          f: _validatorPrimitives.tString
        })),
        a: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("SerializedValue"))),
        o: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          k: _validatorPrimitives.tString,
          v: tType("SerializedValue")
        }))),
        h: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.SerializedArgument = (0, _validatorPrimitives.tObject)({
        value: tType("SerializedValue"),
        handles: (0, _validatorPrimitives.tArray)(tChannel("*"))
      });
      scheme2.ExpectedTextValue = (0, _validatorPrimitives.tObject)({
        string: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        matchSubstring: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        normalizeWhiteSpace: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.AXNode = (0, _validatorPrimitives.tObject)({
        role: _validatorPrimitives.tString,
        name: _validatorPrimitives.tString,
        valueString: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        valueNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        description: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        keyshortcuts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        roledescription: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        valuetext: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        disabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expanded: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        multiline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        multiselectable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        readonly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        required: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        checked: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["checked", "unchecked", "mixed"])),
        pressed: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["pressed", "released", "mixed"])),
        level: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        valuemin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        valuemax: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        autocomplete: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        haspopup: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        invalid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        orientation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("AXNode")))
      });
      scheme2.SetNetworkCookie = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString,
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        domain: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        expires: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        httpOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        secure: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        sameSite: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["Strict", "Lax", "None"]))
      });
      scheme2.NetworkCookie = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString,
        domain: _validatorPrimitives.tString,
        path: _validatorPrimitives.tString,
        expires: _validatorPrimitives.tNumber,
        httpOnly: _validatorPrimitives.tBoolean,
        secure: _validatorPrimitives.tBoolean,
        sameSite: (0, _validatorPrimitives.tEnum)(["Strict", "Lax", "None"])
      });
      scheme2.NameValue = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString
      });
      scheme2.OriginStorage = (0, _validatorPrimitives.tObject)({
        origin: _validatorPrimitives.tString,
        localStorage: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme2.SerializedError = (0, _validatorPrimitives.tObject)({
        error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          message: _validatorPrimitives.tString,
          name: _validatorPrimitives.tString,
          stack: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        value: (0, _validatorPrimitives.tOptional)(tType("SerializedValue"))
      });
      scheme2.FormField = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        file: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: _validatorPrimitives.tString,
          buffer: _validatorPrimitives.tBinary
        }))
      });
      scheme2.APIRequestContextFetchParams = (0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        params: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
        jsonData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        formData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        multipartData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("FormField"))),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        failOnStatusCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.APIRequestContextFetchResponseBodyParams = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString
      });
      scheme2.APIRequestContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.APIRequestContextDisposeAPIResponseParams = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString
      });
      scheme2.APIRequestContextDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.APIResponse = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString,
        url: _validatorPrimitives.tString,
        status: _validatorPrimitives.tNumber,
        statusText: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme2.LifecycleEvent = (0, _validatorPrimitives.tEnum)(["load", "domcontentloaded", "networkidle", "commit"]);
      scheme2.RootInitializeParams = (0, _validatorPrimitives.tObject)({
        sdkLanguage: _validatorPrimitives.tString
      });
      scheme2.PlaywrightSocksConnectedParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        host: _validatorPrimitives.tString,
        port: _validatorPrimitives.tNumber
      });
      scheme2.PlaywrightSocksFailedParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        errorCode: _validatorPrimitives.tString
      });
      scheme2.PlaywrightSocksDataParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        data: _validatorPrimitives.tBinary
      });
      scheme2.PlaywrightSocksErrorParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        error: _validatorPrimitives.tString
      });
      scheme2.PlaywrightSocksEndParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString
      });
      scheme2.PlaywrightNewRequestParams = (0, _validatorPrimitives.tObject)({
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          cookies: (0, _validatorPrimitives.tArray)(tType("NetworkCookie")),
          origins: (0, _validatorPrimitives.tArray)(tType("OriginStorage"))
        }))
      });
      scheme2.SelectorsRegisterParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        source: _validatorPrimitives.tString,
        contentScript: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.BrowserTypeConnectParams = (0, _validatorPrimitives.tObject)({
        wsEndpoint: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.BrowserTypeLaunchParams = (0, _validatorPrimitives.tObject)({
        channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        firefoxUserPrefs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.BrowserTypeLaunchPersistentContextParams = (0, _validatorPrimitives.tObject)({
        channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userDataDir: _validatorPrimitives.tString,
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.BrowserTypeConnectOverCDPParams = (0, _validatorPrimitives.tObject)({
        endpointURL: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.BrowserCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserKillForTestsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserNewContextParams = (0, _validatorPrimitives.tObject)({
        noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("SetNetworkCookie"))),
          origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("OriginStorage")))
        }))
      });
      scheme2.BrowserNewBrowserCDPSessionParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserStartTracingParams = (0, _validatorPrimitives.tObject)({
        page: (0, _validatorPrimitives.tOptional)(tChannel("Page")),
        path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        categories: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
      });
      scheme2.BrowserStopTracingParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.EventTargetWaitForEventInfoParams = (0, _validatorPrimitives.tObject)({
        info: (0, _validatorPrimitives.tObject)({
          waitId: _validatorPrimitives.tString,
          phase: (0, _validatorPrimitives.tEnum)(["before", "after", "log"]),
          event: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })
      });
      scheme2.BrowserContextWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme2.PageWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme2.WebSocketWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme2.ElectronApplicationWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme2.AndroidDeviceWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme2.BrowserContextAddCookiesParams = (0, _validatorPrimitives.tObject)({
        cookies: (0, _validatorPrimitives.tArray)(tType("SetNetworkCookie"))
      });
      scheme2.BrowserContextAddInitScriptParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString
      });
      scheme2.BrowserContextClearCookiesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserContextClearPermissionsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserContextCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserContextCookiesParams = (0, _validatorPrimitives.tObject)({
        urls: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
      });
      scheme2.BrowserContextExposeBindingParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.BrowserContextGrantPermissionsParams = (0, _validatorPrimitives.tObject)({
        permissions: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString),
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.BrowserContextNewPageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.BrowserContextSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.BrowserContextSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme2.BrowserContextSetGeolocationParams = (0, _validatorPrimitives.tObject)({
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))
      });
      scheme2.BrowserContextSetHTTPCredentialsParams = (0, _validatorPrimitives.tObject)({
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        }))
      });
      scheme2.BrowserContextSetNetworkInterceptionEnabledParams = (0, _validatorPrimitives.tObject)({
        enabled: _validatorPrimitives.tBoolean
      });
      scheme2.BrowserContextSetOfflineParams = (0, _validatorPrimitives.tObject)({
        offline: _validatorPrimitives.tBoolean
      });
      scheme2.BrowserContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserContextPauseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserContextRecorderSupplementEnableParams = (0, _validatorPrimitives.tObject)({
        language: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        startRecording: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pauseOnNextStatement: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        launchOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        contextOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        device: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        saveStorage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        outputFile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.BrowserContextNewCDPSessionParams = (0, _validatorPrimitives.tObject)({
        page: (0, _validatorPrimitives.tOptional)(tChannel("Page")),
        frame: (0, _validatorPrimitives.tOptional)(tChannel("Frame"))
      });
      scheme2.BrowserContextTracingStartParams = (0, _validatorPrimitives.tObject)({
        name: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        snapshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.BrowserContextTracingStartChunkParams = (0, _validatorPrimitives.tObject)({
        title: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.BrowserContextTracingStopChunkParams = (0, _validatorPrimitives.tObject)({
        save: _validatorPrimitives.tBoolean,
        skipCompress: _validatorPrimitives.tBoolean
      });
      scheme2.BrowserContextTracingStopParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.BrowserContextHarExportParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.PageSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.PageSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.PageSetFileChooserInterceptedNoReplyParams = (0, _validatorPrimitives.tObject)({
        intercepted: _validatorPrimitives.tBoolean
      });
      scheme2.PageAddInitScriptParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString
      });
      scheme2.PageCloseParams = (0, _validatorPrimitives.tObject)({
        runBeforeUnload: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.PageEmulateMediaParams = (0, _validatorPrimitives.tObject)({
        media: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["screen", "print", "null"])),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "null"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference", "null"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none", "null"]))
      });
      scheme2.PageExposeBindingParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.PageGoBackParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme2.PageGoForwardParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme2.PageReloadParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme2.PageScreenshotParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["png", "jpeg"])),
        quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        clip: (0, _validatorPrimitives.tOptional)(tType("Rect"))
      });
      scheme2.PageSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme2.PageSetNetworkInterceptionEnabledParams = (0, _validatorPrimitives.tObject)({
        enabled: _validatorPrimitives.tBoolean
      });
      scheme2.PageSetViewportSizeParams = (0, _validatorPrimitives.tObject)({
        viewportSize: (0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })
      });
      scheme2.PageKeyboardDownParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme2.PageKeyboardUpParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme2.PageKeyboardInsertTextParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString
      });
      scheme2.PageKeyboardTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.PageKeyboardPressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.PageMouseMoveParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        steps: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.PageMouseDownParams = (0, _validatorPrimitives.tObject)({
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.PageMouseUpParams = (0, _validatorPrimitives.tObject)({
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.PageMouseClickParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.PageMouseWheelParams = (0, _validatorPrimitives.tObject)({
        deltaX: _validatorPrimitives.tNumber,
        deltaY: _validatorPrimitives.tNumber
      });
      scheme2.PageTouchscreenTapParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber
      });
      scheme2.PageAccessibilitySnapshotParams = (0, _validatorPrimitives.tObject)({
        interestingOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        root: (0, _validatorPrimitives.tOptional)(tChannel("ElementHandle"))
      });
      scheme2.PagePdfParams = (0, _validatorPrimitives.tObject)({
        scale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        displayHeaderFooter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        headerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        footerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        printBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        landscape: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pageRanges: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        format: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        width: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        height: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        preferCSSPageSize: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        margin: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          top: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          bottom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          left: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          right: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        }))
      });
      scheme2.PageStartJSCoverageParams = (0, _validatorPrimitives.tObject)({
        resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        reportAnonymousScripts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.PageStopJSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.PageStartCSSCoverageParams = (0, _validatorPrimitives.tObject)({
        resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.PageStopCSSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.PageBringToFrontParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.FrameEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.FrameEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.FrameAddScriptTagParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        type: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.FrameAddStyleTagParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.FrameCheckParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameClickParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.FrameDragAndDropParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString,
        target: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        sourcePosition: (0, _validatorPrimitives.tOptional)(tType("Point")),
        targetPosition: (0, _validatorPrimitives.tOptional)(tType("Point"))
      });
      scheme2.FrameDblclickParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameDispatchEventParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        type: _validatorPrimitives.tString,
        eventInit: tType("SerializedArgument"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.FrameEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.FrameFillParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        value: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameFocusParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameFrameElementParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.FrameGetAttributeParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        name: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameGotoParams = (0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent")),
        referer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.FrameHoverParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameInnerHTMLParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameInnerTextParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameInputValueParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameIsCheckedParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameIsDisabledParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameIsEnabledParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameIsHiddenParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameIsVisibleParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameIsEditableParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FramePressParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameQuerySelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme2.FrameSelectOptionParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tChannel("ElementHandle"))),
        options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameSetContentParams = (0, _validatorPrimitives.tObject)({
        html: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme2.FrameSetInputFilesParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          buffer: _validatorPrimitives.tBinary
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameTapParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameTextContentParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameTitleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.FrameTypeParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameUncheckParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameWaitForTimeoutParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme2.FrameWaitForFunctionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        pollingInterval: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.FrameWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["attached", "detached", "visible", "hidden"])),
        omitReturnValue: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.FrameExpectParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        expressionArg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        expectedText: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("ExpectedTextValue"))),
        expectedNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        expectedValue: (0, _validatorPrimitives.tOptional)(tType("SerializedArgument")),
        useInnerText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        isNot: _validatorPrimitives.tBoolean,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.WorkerEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.WorkerEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.JSHandleDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleDisposeParams = tType("JSHandleDisposeParams");
      scheme2.JSHandleEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.ElementHandleEvaluateExpressionParams = tType("JSHandleEvaluateExpressionParams");
      scheme2.JSHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.ElementHandleEvaluateExpressionHandleParams = tType("JSHandleEvaluateExpressionHandleParams");
      scheme2.JSHandleGetPropertyListParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleGetPropertyListParams = tType("JSHandleGetPropertyListParams");
      scheme2.JSHandleGetPropertyParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString
      });
      scheme2.ElementHandleGetPropertyParams = tType("JSHandleGetPropertyParams");
      scheme2.JSHandleJsonValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleJsonValueParams = tType("JSHandleJsonValueParams");
      scheme2.ElementHandleEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.ElementHandleEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.ElementHandleBoundingBoxParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleCheckParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleClickParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleContentFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleDblclickParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleDispatchEventParams = (0, _validatorPrimitives.tObject)({
        type: _validatorPrimitives.tString,
        eventInit: tType("SerializedArgument")
      });
      scheme2.ElementHandleFillParams = (0, _validatorPrimitives.tObject)({
        value: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleFocusParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleGetAttributeParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString
      });
      scheme2.ElementHandleHoverParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleInnerHTMLParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleInnerTextParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleInputValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleIsCheckedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleIsDisabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleIsEditableParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleIsEnabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleIsHiddenParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleIsVisibleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleOwnerFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandlePressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleQuerySelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme2.ElementHandleScreenshotParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["png", "jpeg"])),
        quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleScrollIntoViewIfNeededParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.ElementHandleSelectOptionParams = (0, _validatorPrimitives.tObject)({
        elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tChannel("ElementHandle"))),
        options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleSelectTextParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.ElementHandleSetInputFilesParams = (0, _validatorPrimitives.tObject)({
        files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          buffer: _validatorPrimitives.tBinary
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleTapParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleTextContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElementHandleTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.ElementHandleUncheckParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme2.ElementHandleWaitForElementStateParams = (0, _validatorPrimitives.tObject)({
        state: (0, _validatorPrimitives.tEnum)(["visible", "hidden", "stable", "enabled", "disabled", "editable"]),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.ElementHandleWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["attached", "detached", "visible", "hidden"]))
      });
      scheme2.RequestResponseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.RequestRawRequestHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.RouteAbortParams = (0, _validatorPrimitives.tObject)({
        errorCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.RouteContinueParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)
      });
      scheme2.RouteFulfillParams = (0, _validatorPrimitives.tObject)({
        status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        isBase64: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        fetchResponseUid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.ResourceTiming = (0, _validatorPrimitives.tObject)({
        startTime: _validatorPrimitives.tNumber,
        domainLookupStart: _validatorPrimitives.tNumber,
        domainLookupEnd: _validatorPrimitives.tNumber,
        connectStart: _validatorPrimitives.tNumber,
        secureConnectionStart: _validatorPrimitives.tNumber,
        connectEnd: _validatorPrimitives.tNumber,
        requestStart: _validatorPrimitives.tNumber,
        responseStart: _validatorPrimitives.tNumber
      });
      scheme2.ResponseBodyParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ResponseSecurityDetailsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ResponseServerAddrParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ResponseRawResponseHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ResponseSizesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.SecurityDetails = (0, _validatorPrimitives.tObject)({
        issuer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        protocol: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        subjectName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        validFrom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        validTo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.RequestSizes = (0, _validatorPrimitives.tObject)({
        requestBodySize: _validatorPrimitives.tNumber,
        requestHeadersSize: _validatorPrimitives.tNumber,
        responseBodySize: _validatorPrimitives.tNumber,
        responseHeadersSize: _validatorPrimitives.tNumber
      });
      scheme2.RemoteAddr = (0, _validatorPrimitives.tObject)({
        ipAddress: _validatorPrimitives.tString,
        port: _validatorPrimitives.tNumber
      });
      scheme2.BindingCallRejectParams = (0, _validatorPrimitives.tObject)({
        error: tType("SerializedError")
      });
      scheme2.BindingCallResolveParams = (0, _validatorPrimitives.tObject)({
        result: tType("SerializedArgument")
      });
      scheme2.DialogAcceptParams = (0, _validatorPrimitives.tObject)({
        promptText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.DialogDismissParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ArtifactPathAfterFinishedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ArtifactSaveAsParams = (0, _validatorPrimitives.tObject)({
        path: _validatorPrimitives.tString
      });
      scheme2.ArtifactSaveAsStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ArtifactFailureParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ArtifactStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ArtifactCancelParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ArtifactDeleteParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.StreamReadParams = (0, _validatorPrimitives.tObject)({
        size: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.StreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.CDPSessionSendParams = (0, _validatorPrimitives.tObject)({
        method: _validatorPrimitives.tString,
        params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)
      });
      scheme2.CDPSessionDetachParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.ElectronLaunchParams = (0, _validatorPrimitives.tObject)({
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        cwd: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.ElectronApplicationBrowserWindowParams = (0, _validatorPrimitives.tObject)({
        page: tChannel("Page")
      });
      scheme2.ElectronApplicationEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.ElectronApplicationEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme2.ElectronApplicationCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.AndroidDevicesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.AndroidSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme2.AndroidSocketWriteParams = (0, _validatorPrimitives.tObject)({
        data: _validatorPrimitives.tBinary
      });
      scheme2.AndroidSocketCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.AndroidDeviceWaitParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["gone"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceFillParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        text: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceTapParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        duration: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceDragParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        dest: tType("Point"),
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceFlingParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceLongTapParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDevicePinchCloseParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDevicePinchOpenParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceScrollParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceSwipeParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceInfoParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector")
      });
      scheme2.AndroidDeviceScreenshotParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.AndroidDeviceInputTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString
      });
      scheme2.AndroidDeviceInputPressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme2.AndroidDeviceInputTapParams = (0, _validatorPrimitives.tObject)({
        point: tType("Point")
      });
      scheme2.AndroidDeviceInputSwipeParams = (0, _validatorPrimitives.tObject)({
        segments: (0, _validatorPrimitives.tArray)(tType("Point")),
        steps: _validatorPrimitives.tNumber
      });
      scheme2.AndroidDeviceInputDragParams = (0, _validatorPrimitives.tObject)({
        from: tType("Point"),
        to: tType("Point"),
        steps: _validatorPrimitives.tNumber
      });
      scheme2.AndroidDeviceLaunchBrowserParams = (0, _validatorPrimitives.tObject)({
        pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        }))
      });
      scheme2.AndroidDeviceOpenParams = (0, _validatorPrimitives.tObject)({
        command: _validatorPrimitives.tString
      });
      scheme2.AndroidDeviceShellParams = (0, _validatorPrimitives.tObject)({
        command: _validatorPrimitives.tString
      });
      scheme2.AndroidDeviceInstallApkParams = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tBinary,
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
      });
      scheme2.AndroidDevicePushParams = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tBinary,
        path: _validatorPrimitives.tString,
        mode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme2.AndroidDeviceSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme2.AndroidDeviceConnectToWebViewParams = (0, _validatorPrimitives.tObject)({
        pid: _validatorPrimitives.tNumber
      });
      scheme2.AndroidDeviceCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme2.AndroidWebView = (0, _validatorPrimitives.tObject)({
        pid: _validatorPrimitives.tNumber,
        pkg: _validatorPrimitives.tString
      });
      scheme2.AndroidSelector = (0, _validatorPrimitives.tObject)({
        checkable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        checked: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        clazz: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        clickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        depth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        desc: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        enabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focusable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasChild: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          selector: tType("AndroidSelector")
        })),
        hasDescendant: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          selector: tType("AndroidSelector"),
          maxDepth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        longClickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        res: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        scrollable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme2.AndroidElementInfo = (0, _validatorPrimitives.tObject)({
        children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("AndroidElementInfo"))),
        clazz: _validatorPrimitives.tString,
        desc: _validatorPrimitives.tString,
        res: _validatorPrimitives.tString,
        pkg: _validatorPrimitives.tString,
        text: _validatorPrimitives.tString,
        bounds: tType("Rect"),
        checkable: _validatorPrimitives.tBoolean,
        checked: _validatorPrimitives.tBoolean,
        clickable: _validatorPrimitives.tBoolean,
        enabled: _validatorPrimitives.tBoolean,
        focusable: _validatorPrimitives.tBoolean,
        focused: _validatorPrimitives.tBoolean,
        longClickable: _validatorPrimitives.tBoolean,
        scrollable: _validatorPrimitives.tBoolean,
        selected: _validatorPrimitives.tBoolean
      });
      scheme2.JsonPipeSendParams = (0, _validatorPrimitives.tObject)({
        message: _validatorPrimitives.tAny
      });
      scheme2.JsonPipeCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      return scheme2;
    }
  }
});

// node_modules/playwright-core/lib/protocol/callMetadata.js
var require_callMetadata = __commonJS({
  "node_modules/playwright-core/lib/protocol/callMetadata.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/playwright-core/lib/server/instrumentation.js
var require_instrumentation = __commonJS({
  "node_modules/playwright-core/lib/server/instrumentation.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createInstrumentation = createInstrumentation;
    exports.internalCallMetadata = internalCallMetadata;
    Object.defineProperty(exports, "CallMetadata", {
      enumerable: true,
      get: function() {
        return _callMetadata.CallMetadata;
      }
    });
    exports.SdkObject = void 0;
    var _events = __require("events");
    var _utils = require_utils();
    var _callMetadata = require_callMetadata();
    var SdkObject = class extends _events.EventEmitter {
      constructor(parent, guidPrefix, guid) {
        super();
        this.guid = void 0;
        this.attribution = void 0;
        this.instrumentation = void 0;
        this.guid = guid || `${guidPrefix || ""}@${(0, _utils.createGuid)()}`;
        this.setMaxListeners(0);
        this.attribution = __spreadValues({}, parent.attribution);
        this.instrumentation = parent.instrumentation;
      }
    };
    exports.SdkObject = SdkObject;
    function createInstrumentation() {
      const listeners = [];
      return new Proxy({}, {
        get: (obj, prop) => {
          if (prop === "addListener")
            return (listener) => listeners.push(listener);
          if (prop === "removeListener")
            return (listener) => listeners.splice(listeners.indexOf(listener), 1);
          if (!prop.startsWith("on"))
            return obj[prop];
          return async (...params) => {
            for (const listener of listeners) {
              var _prop, _ref;
              await ((_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, ...params));
            }
          };
        }
      });
    }
    function internalCallMetadata() {
      return {
        id: "",
        wallTime: 0,
        startTime: 0,
        endTime: 0,
        type: "Internal",
        method: "",
        params: {},
        log: [],
        snapshots: []
      };
    }
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module) {
    init_shims();
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/stack-utils/index.js
var require_stack_utils = __commonJS({
  "node_modules/stack-utils/index.js"(exports, module) {
    init_shims();
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var cwd = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".";
    var natives = [].concat(__require("module").builtinModules, "bootstrap_node", "node").map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
    natives.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);
    var StackUtils = class {
      constructor(opts) {
        opts = __spreadValues({
          ignoredPackages: []
        }, opts);
        if ("internals" in opts === false) {
          opts.internals = StackUtils.nodeInternals();
        }
        if ("cwd" in opts === false) {
          opts.cwd = cwd;
        }
        this._cwd = opts.cwd.replace(/\\/g, "/");
        this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));
        this._wrapCallSite = opts.wrapCallSite || false;
      }
      static nodeInternals() {
        return [...natives];
      }
      clean(stack, indent = 0) {
        indent = " ".repeat(indent);
        if (!Array.isArray(stack)) {
          stack = stack.split("\n");
        }
        if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
          stack = stack.slice(1);
        }
        let outdent = false;
        let lastNonAtLine = null;
        const result = [];
        stack.forEach((st) => {
          st = st.replace(/\\/g, "/");
          if (this._internals.some((internal) => internal.test(st))) {
            return;
          }
          const isAtLine = /^\s*at /.test(st);
          if (outdent) {
            st = st.trimEnd().replace(/^(\s+)at /, "$1");
          } else {
            st = st.trim();
            if (isAtLine) {
              st = st.slice(3);
            }
          }
          st = st.replace(`${this._cwd}/`, "");
          if (st) {
            if (isAtLine) {
              if (lastNonAtLine) {
                result.push(lastNonAtLine);
                lastNonAtLine = null;
              }
              result.push(st);
            } else {
              outdent = true;
              lastNonAtLine = st;
            }
          }
        });
        return result.map((line) => `${indent}${line}
`).join("");
      }
      captureString(limit, fn = this.captureString) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { stackTraceLimit } = Error;
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Error.stackTraceLimit = stackTraceLimit;
        return this.clean(stack);
      }
      capture(limit, fn = this.capture) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { prepareStackTrace, stackTraceLimit } = Error;
        Error.prepareStackTrace = (obj2, site) => {
          if (this._wrapCallSite) {
            return site.map(this._wrapCallSite);
          }
          return site;
        };
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Object.assign(Error, { prepareStackTrace, stackTraceLimit });
        return stack;
      }
      at(fn = this.at) {
        const [site] = this.capture(1, fn);
        if (!site) {
          return {};
        }
        const res = {
          line: site.getLineNumber(),
          column: site.getColumnNumber()
        };
        setFile(res, site.getFileName(), this._cwd);
        if (site.isConstructor()) {
          res.constructor = true;
        }
        if (site.isEval()) {
          res.evalOrigin = site.getEvalOrigin();
        }
        if (site.isNative()) {
          res.native = true;
        }
        let typename;
        try {
          typename = site.getTypeName();
        } catch (_) {
        }
        if (typename && typename !== "Object" && typename !== "[object Object]") {
          res.type = typename;
        }
        const fname = site.getFunctionName();
        if (fname) {
          res.function = fname;
        }
        const meth = site.getMethodName();
        if (meth && fname !== meth) {
          res.method = meth;
        }
        return res;
      }
      parseLine(line) {
        const match = line && line.match(re);
        if (!match) {
          return null;
        }
        const ctor = match[1] === "new";
        let fname = match[2];
        const evalOrigin = match[3];
        const evalFile = match[4];
        const evalLine = Number(match[5]);
        const evalCol = Number(match[6]);
        let file = match[7];
        const lnum = match[8];
        const col = match[9];
        const native = match[10] === "native";
        const closeParen = match[11] === ")";
        let method;
        const res = {};
        if (lnum) {
          res.line = Number(lnum);
        }
        if (col) {
          res.column = Number(col);
        }
        if (closeParen && file) {
          let closes = 0;
          for (let i = file.length - 1; i > 0; i--) {
            if (file.charAt(i) === ")") {
              closes++;
            } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
              closes--;
              if (closes === -1 && file.charAt(i - 1) === " ") {
                const before = file.slice(0, i - 1);
                const after = file.slice(i + 1);
                file = after;
                fname += ` (${before}`;
                break;
              }
            }
          }
        }
        if (fname) {
          const methodMatch = fname.match(methodRe);
          if (methodMatch) {
            fname = methodMatch[1];
            method = methodMatch[2];
          }
        }
        setFile(res, file, this._cwd);
        if (ctor) {
          res.constructor = true;
        }
        if (evalOrigin) {
          res.evalOrigin = evalOrigin;
          res.evalLine = evalLine;
          res.evalColumn = evalCol;
          res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
        }
        if (native) {
          res.native = true;
        }
        if (fname) {
          res.function = fname;
        }
        if (method && fname !== method) {
          res.method = method;
        }
        return res;
      }
    };
    function setFile(result, filename, cwd2) {
      if (filename) {
        filename = filename.replace(/\\/g, "/");
        if (filename.startsWith(`${cwd2}/`)) {
          filename = filename.slice(cwd2.length + 1);
        }
        result.file = filename;
      }
    }
    function ignoredPackagesRegExp(ignoredPackages) {
      if (ignoredPackages.length === 0) {
        return [];
      }
      const packages = ignoredPackages.map((mod) => escapeStringRegexp(mod));
      return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
    }
    var re = new RegExp("^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$");
    var methodRe = /^(.*?) \[as (.*?)\]$/;
    module.exports = StackUtils;
  }
});

// node_modules/playwright-core/lib/utils/stackTrace.js
var require_stackTrace = __commonJS({
  "node_modules/playwright-core/lib/utils/stackTrace.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rewriteErrorMessage = rewriteErrorMessage;
    exports.captureStackTrace = captureStackTrace;
    exports.splitErrorMessage = splitErrorMessage;
    var _path = _interopRequireDefault(__require("path"));
    var _stackUtils = _interopRequireDefault(require_stack_utils());
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var stackUtils = new _stackUtils.default();
    function rewriteErrorMessage(e, newMessage) {
      var _e$stack;
      const lines = (((_e$stack = e.stack) === null || _e$stack === void 0 ? void 0 : _e$stack.split("\n")) || []).filter((l) => l.startsWith("    at "));
      e.message = newMessage;
      const errorTitle = `${e.name}: ${e.message}`;
      if (lines.length)
        e.stack = `${errorTitle}
${lines.join("\n")}`;
      return e;
    }
    var CORE_DIR = _path.default.resolve(__dirname, "..", "..");
    var CLIENT_LIB = _path.default.join(CORE_DIR, "lib", "client");
    var CLIENT_SRC = _path.default.join(CORE_DIR, "src", "client");
    var TEST_DIR_SRC = _path.default.resolve(CORE_DIR, "..", "playwright-test");
    var TEST_DIR_LIB = _path.default.resolve(CORE_DIR, "..", "@playwright", "test");
    var WS_LIB = _path.default.relative(process.cwd(), _path.default.dirname(__require.resolve("ws")));
    function captureStackTrace() {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 30;
      const error2 = new Error();
      const stack = error2.stack;
      Error.stackTraceLimit = stackTraceLimit;
      const isTesting = (0, _utils.isUnderTest)();
      let parsedFrames = stack.split("\n").map((line) => {
        var _frame$function;
        const frame = stackUtils.parseLine(line);
        if (!frame || !frame.file)
          return null;
        if (frame.file.startsWith("internal") || frame.file.startsWith("node:"))
          return null;
        if (frame.file === "events.js" && (_frame$function = frame.function) !== null && _frame$function !== void 0 && _frame$function.endsWith(".emit"))
          return null;
        if (frame.file === "_stream_readable.js" || frame.file === "_stream_writable.js")
          return null;
        if (frame.file.startsWith(WS_LIB))
          return null;
        let fileName;
        if (frame.file.startsWith("file://"))
          fileName = new URL(frame.file).pathname;
        else
          fileName = _path.default.resolve(process.cwd(), frame.file);
        if (isTesting && fileName.includes(_path.default.join("playwright", "tests", "config", "coverage.js")))
          return null;
        const inClient = fileName.startsWith(CLIENT_LIB) || fileName.startsWith(CLIENT_SRC);
        const parsed = {
          frame: {
            file: fileName,
            line: frame.line,
            column: frame.column,
            function: frame.function
          },
          frameText: line,
          inClient
        };
        return parsed;
      }).filter(Boolean);
      let apiName = "";
      const allFrames = parsedFrames;
      const TRAP = "__PWTRAP__[";
      const expectIndex = parsedFrames.findIndex((f) => f.frameText.includes(TRAP));
      if (expectIndex !== -1) {
        const text = parsedFrames[expectIndex].frameText;
        const aliasIndex = text.indexOf(TRAP);
        apiName = text.substring(aliasIndex + TRAP.length, text.indexOf("]"));
        parsedFrames = parsedFrames.slice(expectIndex + 3);
      } else {
        for (let i = 0; i < parsedFrames.length - 1; i++) {
          if (parsedFrames[i].inClient && !parsedFrames[i + 1].inClient) {
            const frame = parsedFrames[i].frame;
            apiName = frame.function ? frame.function[0].toLowerCase() + frame.function.slice(1) : "";
            parsedFrames = parsedFrames.slice(i + 1);
            break;
          }
        }
      }
      parsedFrames = parsedFrames.filter((f, i) => {
        if (f.frame.file.startsWith(TEST_DIR_SRC) || f.frame.file.startsWith(TEST_DIR_LIB))
          return false;
        if (i && f.frame.file.startsWith(CORE_DIR))
          return false;
        return true;
      });
      return {
        allFrames: allFrames.map((p) => p.frame),
        frames: parsedFrames.map((p) => p.frame),
        frameTexts: parsedFrames.map((p) => p.frameText),
        apiName
      };
    }
    function splitErrorMessage(message) {
      const separationIdx = message.indexOf(":");
      return {
        name: separationIdx !== -1 ? message.slice(0, separationIdx) : "",
        message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message
      };
    }
  }
});

// node_modules/playwright-core/lib/dispatchers/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/dispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lookupDispatcher = lookupDispatcher;
    exports.existingDispatcher = existingDispatcher;
    exports.lookupNullableDispatcher = lookupNullableDispatcher;
    exports.DispatcherConnection = exports.Root = exports.Dispatcher = exports.dispatcherSymbol = void 0;
    var _events = __require("events");
    var _serializers = require_serializers();
    var _validator = require_validator();
    var _utils = require_utils();
    var _validatorPrimitives = require_validatorPrimitives();
    var _errors = require_errors();
    var _instrumentation = require_instrumentation();
    var _stackTrace = require_stackTrace();
    var dispatcherSymbol = Symbol("dispatcher");
    exports.dispatcherSymbol = dispatcherSymbol;
    function lookupDispatcher(object) {
      const result = object[dispatcherSymbol];
      (0, _utils.debugAssert)(result);
      return result;
    }
    function existingDispatcher(object) {
      return object[dispatcherSymbol];
    }
    function lookupNullableDispatcher(object) {
      return object ? lookupDispatcher(object) : void 0;
    }
    var Dispatcher = class extends _events.EventEmitter {
      constructor(parent, object, type, initializer, isScope) {
        super();
        this._connection = void 0;
        this._isScope = void 0;
        this._parent = void 0;
        this._dispatchers = new Map();
        this._disposed = false;
        this._guid = void 0;
        this._type = void 0;
        this._scope = void 0;
        this._object = void 0;
        this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;
        this._isScope = !!isScope;
        this._parent = parent instanceof DispatcherConnection ? void 0 : parent;
        this._scope = isScope ? this : this._parent;
        const guid = object.guid;
        (0, _utils.assert)(!this._connection._dispatchers.has(guid));
        this._connection._dispatchers.set(guid, this);
        if (this._parent) {
          (0, _utils.assert)(!this._parent._dispatchers.has(guid));
          this._parent._dispatchers.set(guid, this);
        }
        this._type = type;
        this._guid = guid;
        this._object = object;
        object[dispatcherSymbol] = this;
        if (this._parent)
          this._connection.sendMessageToClient(this._parent._guid, type, "__create__", {
            type,
            initializer,
            guid
          }, this._parent._object);
      }
      _dispatchEvent(method, params) {
        if (this._disposed) {
          if ((0, _utils.isUnderTest)())
            throw new Error(`${this._guid} is sending "${method}" event after being disposed`);
          return;
        }
        const sdkObject = this._object instanceof _instrumentation.SdkObject ? this._object : void 0;
        this._connection.sendMessageToClient(this._guid, this._type, method, params, sdkObject);
      }
      _dispose() {
        (0, _utils.assert)(!this._disposed);
        this._disposed = true;
        if (this._parent)
          this._parent._dispatchers.delete(this._guid);
        this._connection._dispatchers.delete(this._guid);
        for (const dispatcher of [...this._dispatchers.values()])
          dispatcher._dispose();
        this._dispatchers.clear();
        if (this._isScope)
          this._connection.sendMessageToClient(this._guid, this._type, "__dispose__", {});
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._dispatchers.values()).map((o) => o._debugScopeState())
        };
      }
      async waitForEventInfo() {
      }
    };
    exports.Dispatcher = Dispatcher;
    var Root2 = class extends Dispatcher {
      constructor(connection, createPlaywright) {
        super(connection, {
          guid: ""
        }, "Root", {}, true);
        this._initialized = false;
        this.createPlaywright = createPlaywright;
      }
      async initialize(params) {
        (0, _utils.assert)(this.createPlaywright);
        (0, _utils.assert)(!this._initialized);
        this._initialized = true;
        return {
          playwright: await this.createPlaywright(this, params)
        };
      }
    };
    exports.Root = Root2;
    var DispatcherConnection = class {
      sendMessageToClient(guid, type, method, params, sdkObject) {
        params = this._replaceDispatchersWithGuids(params);
        if (sdkObject) {
          var _sdkObject$attributio, _sdkObject$attributio2, _sdkObject$attributio3, _sdkObject$attributio4, _sdkObject$instrument;
          const eventMetadata = {
            id: `event@${++lastEventId}`,
            objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
            pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio = sdkObject.attribution) === null || _sdkObject$attributio === void 0 ? void 0 : (_sdkObject$attributio2 = _sdkObject$attributio.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.guid,
            frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio3 = sdkObject.attribution) === null || _sdkObject$attributio3 === void 0 ? void 0 : (_sdkObject$attributio4 = _sdkObject$attributio3.frame) === null || _sdkObject$attributio4 === void 0 ? void 0 : _sdkObject$attributio4.guid,
            wallTime: Date.now(),
            startTime: (0, _utils.monotonicTime)(),
            endTime: 0,
            type,
            method,
            params: params || {},
            log: [],
            snapshots: []
          };
          (_sdkObject$instrument = sdkObject.instrumentation) === null || _sdkObject$instrument === void 0 ? void 0 : _sdkObject$instrument.onEvent(sdkObject, eventMetadata);
        }
        this.onmessage({
          guid,
          method,
          params
        });
      }
      constructor() {
        this._dispatchers = new Map();
        this.onmessage = (message) => {
        };
        this._validateParams = void 0;
        this._validateMetadata = void 0;
        this._waitOperations = new Map();
        const tChannel = (name) => {
          return (arg, path) => {
            if (arg && typeof arg === "object" && typeof arg.guid === "string") {
              const guid = arg.guid;
              const dispatcher = this._dispatchers.get(guid);
              if (!dispatcher)
                throw new _validator.ValidationError(`${path}: no object with guid ${guid}`);
              if (name !== "*" && dispatcher._type !== name)
                throw new _validator.ValidationError(`${path}: object with guid ${guid} has type ${dispatcher._type}, expected ${name}`);
              return dispatcher;
            }
            throw new _validator.ValidationError(`${path}: expected ${name}`);
          };
        };
        const scheme2 = (0, _validator.createScheme)(tChannel);
        this._validateParams = (type, method, params) => {
          const name = type + method[0].toUpperCase() + method.substring(1) + "Params";
          if (!scheme2[name])
            throw new _validator.ValidationError(`Unknown scheme for ${type}.${method}`);
          return scheme2[name](params, "");
        };
        this._validateMetadata = (metadata) => {
          return (0, _validatorPrimitives.tOptional)(scheme2["Metadata"])(metadata, "");
        };
      }
      async dispatch(message) {
        var _sdkObject$attributio5, _sdkObject$attributio6, _sdkObject$attributio7, _sdkObject$attributio8, _params$info;
        const {
          id,
          guid,
          method,
          params,
          metadata
        } = message;
        const dispatcher = this._dispatchers.get(guid);
        if (!dispatcher) {
          this.onmessage({
            id,
            error: (0, _serializers.serializeError)(new Error(_errors.kBrowserOrContextClosedError))
          });
          return;
        }
        if (method === "debugScopeState") {
          const rootDispatcher = this._dispatchers.get("");
          this.onmessage({
            id,
            result: rootDispatcher._debugScopeState()
          });
          return;
        }
        let validParams;
        let validMetadata;
        try {
          validParams = this._validateParams(dispatcher._type, method, params);
          validMetadata = this._validateMetadata(metadata);
          if (typeof dispatcher[method] !== "function")
            throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
        } catch (e) {
          this.onmessage({
            id,
            error: (0, _serializers.serializeError)(e)
          });
          return;
        }
        const sdkObject = dispatcher._object instanceof _instrumentation.SdkObject ? dispatcher._object : void 0;
        const callMetadata = {
          id: `call@${id}`,
          stack: validMetadata.stack,
          apiName: validMetadata.apiName,
          internal: validMetadata.internal,
          objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
          pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio5 = sdkObject.attribution) === null || _sdkObject$attributio5 === void 0 ? void 0 : (_sdkObject$attributio6 = _sdkObject$attributio5.page) === null || _sdkObject$attributio6 === void 0 ? void 0 : _sdkObject$attributio6.guid,
          frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio7 = sdkObject.attribution) === null || _sdkObject$attributio7 === void 0 ? void 0 : (_sdkObject$attributio8 = _sdkObject$attributio7.frame) === null || _sdkObject$attributio8 === void 0 ? void 0 : _sdkObject$attributio8.guid,
          wallTime: Date.now(),
          startTime: (0, _utils.monotonicTime)(),
          endTime: 0,
          type: dispatcher._type,
          method,
          params: params || {},
          log: [],
          snapshots: []
        };
        if (sdkObject && params !== null && params !== void 0 && (_params$info = params.info) !== null && _params$info !== void 0 && _params$info.waitId) {
          const info = params.info;
          switch (info.phase) {
            case "before": {
              this._waitOperations.set(info.waitId, callMetadata);
              await sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
              this.onmessage({
                id
              });
              return;
            }
            case "log": {
              const originalMetadata = this._waitOperations.get(info.waitId);
              originalMetadata.log.push(info.message);
              sdkObject.instrumentation.onCallLog("api", info.message, sdkObject, originalMetadata);
              this.onmessage({
                id
              });
              return;
            }
            case "after": {
              const originalMetadata = this._waitOperations.get(info.waitId);
              originalMetadata.endTime = (0, _utils.monotonicTime)();
              originalMetadata.error = info.error ? {
                error: {
                  name: "Error",
                  message: info.error
                }
              } : void 0;
              this._waitOperations.delete(info.waitId);
              await sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
              this.onmessage({
                id
              });
              return;
            }
          }
        }
        let error2;
        await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata));
        try {
          const result = await dispatcher[method](validParams, callMetadata);
          callMetadata.result = this._replaceDispatchersWithGuids(result);
        } catch (e) {
          callMetadata.error = (0, _serializers.serializeError)(e);
          if (callMetadata.log.length)
            (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(callMetadata.log));
          error2 = (0, _serializers.serializeError)(e);
        } finally {
          callMetadata.endTime = (0, _utils.monotonicTime)();
          await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata));
        }
        const response = {
          id
        };
        if (callMetadata.result)
          response.result = callMetadata.result;
        if (error2)
          response.error = error2;
        this.onmessage(response);
      }
      _replaceDispatchersWithGuids(payload) {
        if (!payload)
          return payload;
        if (payload instanceof Dispatcher)
          return {
            guid: payload._guid
          };
        if (Array.isArray(payload))
          return payload.map((p) => this._replaceDispatchersWithGuids(p));
        if (typeof payload === "object") {
          const result = {};
          for (const key of Object.keys(payload))
            result[key] = this._replaceDispatchersWithGuids(payload[key]);
          return result;
        }
        return payload;
      }
    };
    exports.DispatcherConnection = DispatcherConnection;
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
    var lastEventId = 0;
  }
});

// node_modules/playwright-core/node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/constants.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/playwright-core/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/buffer-util.js"(exports, module) {
    init_shims();
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list2, totalLength) {
      if (list2.length === 0)
        return EMPTY_BUFFER;
      if (list2.length === 1)
        return list2[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list2.length; i++) {
        const buf = list2[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = __require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/playwright-core/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/limiter.js"(exports, module) {
    init_shims();
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module.exports = Limiter;
  }
});

// node_modules/playwright-core/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/permessage-deflate.js"(exports, module) {
    init_shims();
    "use strict";
    var zlib2 = __require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options2, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options2 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw(__spreadProps(__spreadValues({}, this._options.zlibInflateOptions), {
            windowBits
          }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw(__spreadProps(__spreadValues({}, this._options.zlibDeflateOptions), {
            windowBits
          }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/playwright-core/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/validation.js"(exports, module) {
    init_shims();
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = __require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/playwright-core/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/receiver.js"(exports, module) {
    init_shims();
    "use strict";
    var { Writable } = __require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error2(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error2(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error2(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error2(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error2(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error2(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error2(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error2(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error2(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error2(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error2(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error2(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error2(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error2(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error2(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module.exports = Receiver;
    function error2(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error2);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/playwright-core/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/sender.js"(exports, module) {
    init_shims();
    "use strict";
    var net = __require("net");
    var tls = __require("tls");
    var { randomFillSync } = __require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options2) {
        const merge = options2.mask && options2.readOnly;
        let offset = options2.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
        if (options2.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options2.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask: mask2,
          readOnly: false
        }), cb);
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask: mask2,
          readOnly
        }), cb);
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask: mask2,
          readOnly
        }), cb);
      }
      send(data, options2, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options2.binary ? 2 : 1;
        let rsv1 = options2.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options2.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options2.fin,
            rsv1,
            opcode,
            mask: options2.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(buf, {
            fin: options2.fin,
            rsv1: false,
            opcode,
            mask: options2.mask,
            readOnly: toBuffer.readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options2, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options2), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options2.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options2.readOnly = false;
          this.sendFrame(Sender.frame(buf, options2), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list2, cb) {
        if (list2.length === 2) {
          this._socket.cork();
          this._socket.write(list2[0]);
          this._socket.write(list2[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list2[0], cb);
        }
      }
    };
    module.exports = Sender;
  }
});

// node_modules/playwright-core/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/event-target.js"(exports, module) {
    init_shims();
    "use strict";
    var Event = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      constructor(error2, target) {
        super("error", target);
        this.message = error2.message;
        this.error = error2;
      }
    };
    var EventTarget = {
      addEventListener(type, listener, options2) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error2) {
          listener.call(this, new ErrorEvent(error2, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options2 && options2.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module.exports = EventTarget;
  }
});

// node_modules/playwright-core/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/extension.js"(exports, module) {
    init_shims();
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse3(header) {
      const offers = Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format2(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module.exports = { format: format2, parse: parse3 };
  }
});

// node_modules/playwright-core/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/websocket.js"(exports, module) {
    init_shims();
    "use strict";
    var EventEmitter = __require("events");
    var https2 = __require("https");
    var http2 = __require("http");
    var net = __require("net");
    var tls = __require("tls");
    var { randomBytes: randomBytes2, createHash } = __require("crypto");
    var { Readable } = __require("stream");
    var { URL: URL2 } = __require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format: format2, parse: parse3 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options2) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options2 = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options2);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get onclose() {
        return void 0;
      }
      set onclose(listener) {
      }
      get onerror() {
        return void 0;
      }
      set onerror(listener) {
      }
      get onopen() {
        return void 0;
      }
      set onopen(listener) {
      }
      get onmessage() {
        return void 0;
      }
      set onmessage(listener) {
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options2, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = __spreadValues({
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options2);
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options2) {
      const opts = __spreadProps(__spreadValues({
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10
      }, options2), {
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      });
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes2(16).toString("base64");
      const get2 = isSecure ? https2.get : http2.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = __spreadValues({
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      }, opts.headers);
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format2({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req = websocket._req = get2(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location2 = res.headers.location;
        const statusCode = res.statusCode;
        if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location2, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options2);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse3(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options2) {
      options2.path = options2.socketPath;
      return net.connect(options2);
    }
    function tlsConnect(options2) {
      options2.path = void 0;
      if (!options2.servername && options2.servername !== "") {
        options2.servername = net.isIP(options2.host) ? "" : options2.host;
      }
      return tls.connect(options2);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/playwright-core/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/stream.js"(exports, module) {
    init_shims();
    "use strict";
    var { Duplex } = __require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options2) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex(__spreadProps(__spreadValues({}, options2), {
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      }));
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error2(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error2(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module.exports = createWebSocketStream;
  }
});

// node_modules/playwright-core/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/playwright-core/node_modules/ws/lib/websocket-server.js"(exports, module) {
    init_shims();
    "use strict";
    var EventEmitter = __require("events");
    var http2 = __require("http");
    var https2 = __require("https");
    var net = __require("net");
    var tls = __require("tls");
    var { createHash } = __require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket = require_websocket();
    var { format: format2, parse: parse3 } = require_extension();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      constructor(options2, callback) {
        super();
        options2 = __spreadValues({
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null
        }, options2);
        if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options2.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options2.port, options2.host, options2.backlog, callback);
        } else if (options2.server) {
          this._server = options2.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options2.perMessageDeflate === true)
          options2.perMessageDeflate = {};
        if (options2.clientTracking)
          this.clients = new Set();
        this.options = options2;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = parse3(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format2({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http2.STATUS_CODES[code];
        headers = __spreadValues({
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message)
        }, headers);
        socket.write(`HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/playwright-core/node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/playwright-core/node_modules/ws/index.js"(exports, module) {
    init_shims();
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module.exports = WebSocket;
  }
});

// node_modules/playwright-core/lib/utils/timeoutSettings.js
var require_timeoutSettings = __commonJS({
  "node_modules/playwright-core/lib/utils/timeoutSettings.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TimeoutSettings = exports.DEFAULT_TIMEOUT = void 0;
    var _utils = require_utils();
    var DEFAULT_TIMEOUT = 3e4;
    exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var TIMEOUT = (0, _utils.debugMode)() ? 0 : DEFAULT_TIMEOUT;
    var TimeoutSettings = class {
      constructor(parent) {
        this._parent = void 0;
        this._defaultTimeout = void 0;
        this._defaultNavigationTimeout = void 0;
        this._parent = parent;
      }
      setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
      }
      setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
      }
      navigationTimeout(options2) {
        if (typeof options2.timeout === "number")
          return options2.timeout;
        if (this._defaultNavigationTimeout !== void 0)
          return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== void 0)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.navigationTimeout(options2);
        return TIMEOUT;
      }
      timeout(options2) {
        if (typeof options2.timeout === "number")
          return options2.timeout;
        if (this._defaultTimeout !== void 0)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.timeout(options2);
        return TIMEOUT;
      }
      static timeout(options2) {
        if (typeof options2.timeout === "number")
          return options2.timeout;
        return TIMEOUT;
      }
    };
    exports.TimeoutSettings = TimeoutSettings;
  }
});

// node_modules/playwright-core/lib/utils/debugLogger.js
var require_debugLogger = __commonJS({
  "node_modules/playwright-core/lib/utils/debugLogger.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RecentLogsCollector = exports.debugLogger = void 0;
    var _debug = _interopRequireDefault(require_src());
    var _fs = _interopRequireDefault(__require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debugLoggerColorMap = {
      "api": 45,
      "protocol": 34,
      "install": 34,
      "download": 34,
      "browser": 0,
      "proxy": 92,
      "error": 160,
      "channel:command": 33,
      "channel:response": 202,
      "channel:event": 207
    };
    var DebugLogger = class {
      constructor() {
        this._debuggers = new Map();
        if (process.env.DEBUG_FILE) {
          const ansiRegex = new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"), "g");
          const stream = _fs.default.createWriteStream(process.env.DEBUG_FILE);
          _debug.default.log = (data) => {
            stream.write(data.replace(ansiRegex, ""));
            stream.write("\n");
          };
        }
      }
      log(name, message) {
        let cachedDebugger = this._debuggers.get(name);
        if (!cachedDebugger) {
          cachedDebugger = (0, _debug.default)(`pw:${name}`);
          this._debuggers.set(name, cachedDebugger);
          cachedDebugger.color = debugLoggerColorMap[name];
        }
        cachedDebugger(message);
      }
      isEnabled(name) {
        return _debug.default.enabled(`pw:${name}`);
      }
    };
    var debugLogger = new DebugLogger();
    exports.debugLogger = debugLogger;
    var kLogCount = 150;
    var RecentLogsCollector = class {
      constructor() {
        this._logs = [];
      }
      log(message) {
        this._logs.push(message);
        if (this._logs.length === kLogCount * 2)
          this._logs.splice(0, kLogCount);
      }
      recentLogs() {
        if (this._logs.length > kLogCount)
          return this._logs.slice(-kLogCount);
        return this._logs;
      }
    };
    exports.RecentLogsCollector = RecentLogsCollector;
  }
});

// node_modules/playwright-core/lib/utils/eventsHelper.js
var require_eventsHelper = __commonJS({
  "node_modules/playwright-core/lib/utils/eventsHelper.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.eventsHelper = void 0;
    var EventsHelper = class {
      static addEventListener(emitter, eventName, handler) {
        emitter.on(eventName, handler);
        return {
          emitter,
          eventName,
          handler
        };
      }
      static removeEventListeners(listeners) {
        for (const listener of listeners)
          listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
      }
    };
    var eventsHelper = EventsHelper;
    exports.eventsHelper = eventsHelper;
  }
});

// node_modules/playwright-core/lib/server/helper.js
var require_helper = __commonJS({
  "node_modules/playwright-core/lib/server/helper.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.helper = void 0;
    var _debugLogger = require_debugLogger();
    var _eventsHelper = require_eventsHelper();
    var Helper = class {
      static completeUserURL(urlString) {
        if (urlString.startsWith("localhost") || urlString.startsWith("127.0.0.1"))
          urlString = "http://" + urlString;
        return urlString;
      }
      static enclosingIntRect(rect) {
        const x = Math.floor(rect.x + 1e-3);
        const y = Math.floor(rect.y + 1e-3);
        const x2 = Math.ceil(rect.x + rect.width - 1e-3);
        const y2 = Math.ceil(rect.y + rect.height - 1e-3);
        return {
          x,
          y,
          width: x2 - x,
          height: y2 - y
        };
      }
      static enclosingIntSize(size) {
        return {
          width: Math.floor(size.width + 1e-3),
          height: Math.floor(size.height + 1e-3)
        };
      }
      static getViewportSizeFromWindowFeatures(features) {
        const widthString = features.find((f) => f.startsWith("width="));
        const heightString = features.find((f) => f.startsWith("height="));
        const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
        const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
        if (!Number.isNaN(width) && !Number.isNaN(height))
          return {
            width,
            height
          };
        return null;
      }
      static waitForEvent(progress, emitter, event, predicate) {
        const listeners = [];
        const promise = new Promise((resolve3, reject) => {
          listeners.push(_eventsHelper.eventsHelper.addEventListener(emitter, event, (eventArg) => {
            try {
              if (predicate && !predicate(eventArg))
                return;
              _eventsHelper.eventsHelper.removeEventListeners(listeners);
              resolve3(eventArg);
            } catch (e) {
              _eventsHelper.eventsHelper.removeEventListeners(listeners);
              reject(e);
            }
          }));
        });
        const dispose = () => _eventsHelper.eventsHelper.removeEventListeners(listeners);
        if (progress)
          progress.cleanupWhenAborted(dispose);
        return {
          promise,
          dispose
        };
      }
      static secondsToRoundishMillis(value) {
        return (value * 1e6 | 0) / 1e3;
      }
      static millisToRoundishMillis(value) {
        return (value * 1e3 | 0) / 1e3;
      }
      static debugProtocolLogger(protocolLogger) {
        return (direction, message) => {
          if (protocolLogger)
            protocolLogger(direction, message);
          if (_debugLogger.debugLogger.isEnabled("protocol"))
            _debugLogger.debugLogger.log("protocol", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message));
        };
      }
      static formatBrowserLogs(logs) {
        if (!logs.length)
          return "";
        return "\n" + "=".repeat(20) + " Browser output: " + "=".repeat(20) + "\n" + logs.join("\n");
      }
    };
    var helper = Helper;
    exports.helper = helper;
  }
});

// node_modules/playwright-core/lib/utils/async.js
var require_async = __commonJS({
  "node_modules/playwright-core/lib/utils/async.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.raceAgainstDeadline = raceAgainstDeadline;
    exports.ManualPromise = exports.DeadlineRunner = void 0;
    var _utils = require_utils();
    var _Symbol$species;
    var _Symbol$toStringTag;
    var DeadlineRunner = class {
      constructor(promise, deadline) {
        this._timer = void 0;
        this.result = new ManualPromise();
        promise.then((result) => {
          this._finish({
            result
          });
        }).catch((e) => {
          this._finish(void 0, e);
        });
        this.updateDeadline(deadline);
      }
      _finish(success, error2) {
        if (this.result.isDone())
          return;
        this.updateDeadline(0);
        if (success)
          this.result.resolve(success);
        else
          this.result.reject(error2);
      }
      interrupt() {
        this.updateDeadline(-1);
      }
      updateDeadline(deadline) {
        if (this._timer) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
        if (deadline === 0)
          return;
        const timeout = deadline - (0, _utils.monotonicTime)();
        if (timeout <= 0)
          this._finish({
            timedOut: true
          });
        else
          this._timer = setTimeout(() => this._finish({
            timedOut: true
          }), timeout);
      }
    };
    exports.DeadlineRunner = DeadlineRunner;
    async function raceAgainstDeadline(promise, deadline) {
      return new DeadlineRunner(promise, deadline).result;
    }
    _Symbol$species = Symbol.species;
    _Symbol$toStringTag = Symbol.toStringTag;
    var ManualPromise = class extends Promise {
      constructor() {
        let resolve3;
        let reject;
        super((f, r) => {
          resolve3 = f;
          reject = r;
        });
        this._resolve = void 0;
        this._reject = void 0;
        this._isDone = void 0;
        this._isDone = false;
        this._resolve = resolve3;
        this._reject = reject;
      }
      isDone() {
        return this._isDone;
      }
      resolve(t) {
        this._isDone = true;
        this._resolve(t);
      }
      reject(e) {
        this._isDone = true;
        this._reject(e);
      }
      static get [_Symbol$species]() {
        return Promise;
      }
      get [_Symbol$toStringTag]() {
        return "ManualPromise";
      }
    };
    exports.ManualPromise = ManualPromise;
  }
});

// node_modules/ip/lib/ip.js
var require_ip = __commonJS({
  "node_modules/ip/lib/ip.js"(exports) {
    init_shims();
    "use strict";
    var ip = exports;
    var Buffer2 = __require("buffer").Buffer;
    var os = __require("os");
    ip.toBuffer = function(ip2, buff, offset) {
      offset = ~~offset;
      var result;
      if (this.isV4Format(ip2)) {
        result = buff || new Buffer2(offset + 4);
        ip2.split(/\./g).map(function(byte) {
          result[offset++] = parseInt(byte, 10) & 255;
        });
      } else if (this.isV6Format(ip2)) {
        var sections = ip2.split(":", 8);
        var i;
        for (i = 0; i < sections.length; i++) {
          var isv4 = this.isV4Format(sections[i]);
          var v4Buffer;
          if (isv4) {
            v4Buffer = this.toBuffer(sections[i]);
            sections[i] = v4Buffer.slice(0, 2).toString("hex");
          }
          if (v4Buffer && ++i < 8) {
            sections.splice(i, 0, v4Buffer.slice(2, 4).toString("hex"));
          }
        }
        if (sections[0] === "") {
          while (sections.length < 8)
            sections.unshift("0");
        } else if (sections[sections.length - 1] === "") {
          while (sections.length < 8)
            sections.push("0");
        } else if (sections.length < 8) {
          for (i = 0; i < sections.length && sections[i] !== ""; i++)
            ;
          var argv = [i, 1];
          for (i = 9 - sections.length; i > 0; i--) {
            argv.push("0");
          }
          sections.splice.apply(sections, argv);
        }
        result = buff || new Buffer2(offset + 16);
        for (i = 0; i < sections.length; i++) {
          var word = parseInt(sections[i], 16);
          result[offset++] = word >> 8 & 255;
          result[offset++] = word & 255;
        }
      }
      if (!result) {
        throw Error("Invalid ip address: " + ip2);
      }
      return result;
    };
    ip.toString = function(buff, offset, length) {
      offset = ~~offset;
      length = length || buff.length - offset;
      var result = [];
      if (length === 4) {
        for (var i = 0; i < length; i++) {
          result.push(buff[offset + i]);
        }
        result = result.join(".");
      } else if (length === 16) {
        for (var i = 0; i < length; i += 2) {
          result.push(buff.readUInt16BE(offset + i).toString(16));
        }
        result = result.join(":");
        result = result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
        result = result.replace(/:{3,4}/, "::");
      }
      return result;
    };
    var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
    var ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
    ip.isV4Format = function(ip2) {
      return ipv4Regex.test(ip2);
    };
    ip.isV6Format = function(ip2) {
      return ipv6Regex.test(ip2);
    };
    function _normalizeFamily(family) {
      return family ? family.toLowerCase() : "ipv4";
    }
    ip.fromPrefixLen = function(prefixlen, family) {
      if (prefixlen > 32) {
        family = "ipv6";
      } else {
        family = _normalizeFamily(family);
      }
      var len = 4;
      if (family === "ipv6") {
        len = 16;
      }
      var buff = new Buffer2(len);
      for (var i = 0, n = buff.length; i < n; ++i) {
        var bits = 8;
        if (prefixlen < 8) {
          bits = prefixlen;
        }
        prefixlen -= bits;
        buff[i] = ~(255 >> bits) & 255;
      }
      return ip.toString(buff);
    };
    ip.mask = function(addr, mask) {
      addr = ip.toBuffer(addr);
      mask = ip.toBuffer(mask);
      var result = new Buffer2(Math.max(addr.length, mask.length));
      var i = 0;
      if (addr.length === mask.length) {
        for (i = 0; i < addr.length; i++) {
          result[i] = addr[i] & mask[i];
        }
      } else if (mask.length === 4) {
        for (i = 0; i < mask.length; i++) {
          result[i] = addr[addr.length - 4 + i] & mask[i];
        }
      } else {
        for (var i = 0; i < result.length - 6; i++) {
          result[i] = 0;
        }
        result[10] = 255;
        result[11] = 255;
        for (i = 0; i < addr.length; i++) {
          result[i + 12] = addr[i] & mask[i + 12];
        }
        i = i + 12;
      }
      for (; i < result.length; i++)
        result[i] = 0;
      return ip.toString(result);
    };
    ip.cidr = function(cidrString) {
      var cidrParts = cidrString.split("/");
      var addr = cidrParts[0];
      if (cidrParts.length !== 2)
        throw new Error("invalid CIDR subnet: " + addr);
      var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
      return ip.mask(addr, mask);
    };
    ip.subnet = function(addr, mask) {
      var networkAddress = ip.toLong(ip.mask(addr, mask));
      var maskBuffer = ip.toBuffer(mask);
      var maskLength = 0;
      for (var i = 0; i < maskBuffer.length; i++) {
        if (maskBuffer[i] === 255) {
          maskLength += 8;
        } else {
          var octet = maskBuffer[i] & 255;
          while (octet) {
            octet = octet << 1 & 255;
            maskLength++;
          }
        }
      }
      var numberOfAddresses = Math.pow(2, 32 - maskLength);
      return {
        networkAddress: ip.fromLong(networkAddress),
        firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
        lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),
        broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
        subnetMask: mask,
        subnetMaskLength: maskLength,
        numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,
        length: numberOfAddresses,
        contains: function(other) {
          return networkAddress === ip.toLong(ip.mask(other, mask));
        }
      };
    };
    ip.cidrSubnet = function(cidrString) {
      var cidrParts = cidrString.split("/");
      var addr = cidrParts[0];
      if (cidrParts.length !== 2)
        throw new Error("invalid CIDR subnet: " + addr);
      var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
      return ip.subnet(addr, mask);
    };
    ip.not = function(addr) {
      var buff = ip.toBuffer(addr);
      for (var i = 0; i < buff.length; i++) {
        buff[i] = 255 ^ buff[i];
      }
      return ip.toString(buff);
    };
    ip.or = function(a, b) {
      a = ip.toBuffer(a);
      b = ip.toBuffer(b);
      if (a.length === b.length) {
        for (var i = 0; i < a.length; ++i) {
          a[i] |= b[i];
        }
        return ip.toString(a);
      } else {
        var buff = a;
        var other = b;
        if (b.length > a.length) {
          buff = b;
          other = a;
        }
        var offset = buff.length - other.length;
        for (var i = offset; i < buff.length; ++i) {
          buff[i] |= other[i - offset];
        }
        return ip.toString(buff);
      }
    };
    ip.isEqual = function(a, b) {
      a = ip.toBuffer(a);
      b = ip.toBuffer(b);
      if (a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
          if (a[i] !== b[i])
            return false;
        }
        return true;
      }
      if (b.length === 4) {
        var t = b;
        b = a;
        a = t;
      }
      for (var i = 0; i < 10; i++) {
        if (b[i] !== 0)
          return false;
      }
      var word = b.readUInt16BE(10);
      if (word !== 0 && word !== 65535)
        return false;
      for (var i = 0; i < 4; i++) {
        if (a[i] !== b[i + 12])
          return false;
      }
      return true;
    };
    ip.isPrivate = function(addr) {
      return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    };
    ip.isPublic = function(addr) {
      return !ip.isPrivate(addr);
    };
    ip.isLoopback = function(addr) {
      return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    };
    ip.loopback = function(family) {
      family = _normalizeFamily(family);
      if (family !== "ipv4" && family !== "ipv6") {
        throw new Error("family must be ipv4 or ipv6");
      }
      return family === "ipv4" ? "127.0.0.1" : "fe80::1";
    };
    ip.address = function(name, family) {
      var interfaces = os.networkInterfaces();
      var all;
      family = _normalizeFamily(family);
      if (name && name !== "private" && name !== "public") {
        var res = interfaces[name].filter(function(details) {
          var itemFamily = details.family.toLowerCase();
          return itemFamily === family;
        });
        if (res.length === 0)
          return void 0;
        return res[0].address;
      }
      var all = Object.keys(interfaces).map(function(nic) {
        var addresses = interfaces[nic].filter(function(details) {
          details.family = details.family.toLowerCase();
          if (details.family !== family || ip.isLoopback(details.address)) {
            return false;
          } else if (!name) {
            return true;
          }
          return name === "public" ? ip.isPrivate(details.address) : ip.isPublic(details.address);
        });
        return addresses.length ? addresses[0].address : void 0;
      }).filter(Boolean);
      return !all.length ? ip.loopback(family) : all[0];
    };
    ip.toLong = function(ip2) {
      var ipl = 0;
      ip2.split(".").forEach(function(octet) {
        ipl <<= 8;
        ipl += parseInt(octet);
      });
      return ipl >>> 0;
    };
    ip.fromLong = function(ipl) {
      return (ipl >>> 24) + "." + (ipl >> 16 & 255) + "." + (ipl >> 8 & 255) + "." + (ipl & 255);
    };
  }
});

// node_modules/smart-buffer/build/utils.js
var require_utils2 = __commonJS({
  "node_modules/smart-buffer/build/utils.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = __require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "node_modules/smart-buffer/build/smartbuffer.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class {
      constructor(options2) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (SmartBuffer.isSmartBufferOptions(options2)) {
          if (options2.encoding) {
            utils_1.checkEncoding(options2.encoding);
            this._encoding = options2.encoding;
          }
          if (options2.size) {
            if (utils_1.isFiniteInteger(options2.size) && options2.size > 0) {
              this._buff = Buffer.allocUnsafe(options2.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options2.buff) {
            if (Buffer.isBuffer(options2.buff)) {
              this._buff = options2.buff;
              this.length = options2.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options2 !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      static fromOptions(options2) {
        return new this(options2);
      }
      static isSmartBufferOptions(options2) {
        const castOptions = options2;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      readBufferNT() {
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      remaining() {
        return this.length - this._readOffset;
      }
      get readOffset() {
        return this._readOffset;
      }
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      get writeOffset() {
        return this._writeOffset;
      }
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      get encoding() {
        return this._encoding;
      }
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      get internalBuffer() {
        return this._buff;
      }
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      destroy() {
        this.clear();
        return this;
      }
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports.SmartBuffer = SmartBuffer;
  }
});

// node_modules/socks/build/common/constants.js
var require_constants2 = __commonJS({
  "node_modules/socks/build/common/constants.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SOCKS5_NO_ACCEPTABLE_AUTH = exports.SOCKS5_CUSTOM_AUTH_END = exports.SOCKS5_CUSTOM_AUTH_START = exports.SOCKS_INCOMING_PACKET_SIZES = exports.SocksClientState = exports.Socks5Response = exports.Socks5HostType = exports.Socks5Auth = exports.Socks4Response = exports.SocksCommand = exports.ERRORS = exports.DEFAULT_TIMEOUT = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var ERRORS = {
      InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
      InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
      InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
      InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
      InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
      InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
      InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
      InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
      InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
      InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
      NegotiationError: "Negotiation error",
      SocketClosed: "Socket closed",
      ProxyConnectionTimedOut: "Proxy connection timed out",
      InternalError: "SocksClient internal error (this should not happen)",
      InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
      Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
      InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
      Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
      InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
      InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
      InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
      InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
      Socks5AuthenticationFailed: "Socks5 Authentication failed",
      InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
      InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
      InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
      Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
    };
    exports.ERRORS = ERRORS;
    var SOCKS_INCOMING_PACKET_SIZES = {
      Socks5InitialHandshakeResponse: 2,
      Socks5UserPassAuthenticationResponse: 2,
      Socks5ResponseHeader: 5,
      Socks5ResponseIPv4: 10,
      Socks5ResponseIPv6: 22,
      Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
      Socks4Response: 8
    };
    exports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
      SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
      SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
    })(SocksCommand || (SocksCommand = {}));
    exports.SocksCommand = SocksCommand;
    var Socks4Response;
    (function(Socks4Response2) {
      Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
      Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
      Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
      Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
    })(Socks4Response || (Socks4Response = {}));
    exports.Socks4Response = Socks4Response;
    var Socks5Auth;
    (function(Socks5Auth2) {
      Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
      Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
      Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
    })(Socks5Auth || (Socks5Auth = {}));
    exports.Socks5Auth = Socks5Auth;
    var SOCKS5_CUSTOM_AUTH_START = 128;
    exports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
    var SOCKS5_CUSTOM_AUTH_END = 254;
    exports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
    var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
    exports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
    var Socks5Response;
    (function(Socks5Response2) {
      Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
      Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
      Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
      Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
      Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
      Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
      Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
      Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
    })(Socks5Response || (Socks5Response = {}));
    exports.Socks5Response = Socks5Response;
    var Socks5HostType;
    (function(Socks5HostType2) {
      Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
      Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
      Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
    })(Socks5HostType || (Socks5HostType = {}));
    exports.Socks5HostType = Socks5HostType;
    var SocksClientState;
    (function(SocksClientState2) {
      SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
      SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
      SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
      SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
      SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
      SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
      SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
      SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
      SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
      SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
      SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
      SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
      SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
    })(SocksClientState || (SocksClientState = {}));
    exports.SocksClientState = SocksClientState;
  }
});

// node_modules/socks/build/common/util.js
var require_util = __commonJS({
  "node_modules/socks/build/common/util.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffleArray = exports.SocksClientError = void 0;
    var SocksClientError = class extends Error {
      constructor(message, options2) {
        super(message);
        this.options = options2;
      }
    };
    exports.SocksClientError = SocksClientError;
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    exports.shuffleArray = shuffleArray;
  }
});

// node_modules/socks/build/common/helpers.js
var require_helpers = __commonJS({
  "node_modules/socks/build/common/helpers.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSocksClientChainOptions = exports.validateSocksClientOptions = void 0;
    var util_1 = require_util();
    var constants_1 = require_constants2();
    var stream = __require("stream");
    function validateSocksClientOptions(options2, acceptedCommands = ["connect", "bind", "associate"]) {
      if (!constants_1.SocksCommand[options2.command]) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options2);
      }
      if (acceptedCommands.indexOf(options2.command) === -1) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options2);
      }
      if (!isValidSocksRemoteHost(options2.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options2);
      }
      if (!isValidSocksProxy(options2.proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options2);
      }
      validateCustomProxyAuth(options2.proxy, options2);
      if (options2.timeout && !isValidTimeoutValue(options2.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options2);
      }
      if (options2.existing_socket && !(options2.existing_socket instanceof stream.Duplex)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options2);
      }
    }
    exports.validateSocksClientOptions = validateSocksClientOptions;
    function validateSocksClientChainOptions(options2) {
      if (options2.command !== "connect") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options2);
      }
      if (!isValidSocksRemoteHost(options2.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options2);
      }
      if (!(options2.proxies && Array.isArray(options2.proxies) && options2.proxies.length >= 2)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options2);
      }
      options2.proxies.forEach((proxy) => {
        if (!isValidSocksProxy(proxy)) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options2);
        }
        validateCustomProxyAuth(proxy, options2);
      });
      if (options2.timeout && !isValidTimeoutValue(options2.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options2);
      }
    }
    exports.validateSocksClientChainOptions = validateSocksClientChainOptions;
    function validateCustomProxyAuth(proxy, options2) {
      if (proxy.custom_auth_method !== void 0) {
        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options2);
        }
        if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options2);
        }
        if (proxy.custom_auth_response_size === void 0) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options2);
        }
        if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options2);
        }
      }
    }
    function isValidSocksRemoteHost(remoteHost) {
      return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
    }
    function isValidSocksProxy(proxy) {
      return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
    }
    function isValidTimeoutValue(value) {
      return typeof value === "number" && value > 0;
    }
  }
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS({
  "node_modules/socks/build/common/receivebuffer.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReceiveBuffer = void 0;
    var ReceiveBuffer = class {
      constructor(size = 4096) {
        this.buffer = Buffer.allocUnsafe(size);
        this.offset = 0;
        this.originalSize = size;
      }
      get length() {
        return this.offset;
      }
      append(data) {
        if (!Buffer.isBuffer(data)) {
          throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
        }
        if (this.offset + data.length >= this.buffer.length) {
          const tmp = this.buffer;
          this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
          tmp.copy(this.buffer);
        }
        data.copy(this.buffer, this.offset);
        return this.offset += data.length;
      }
      peek(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        return this.buffer.slice(0, length);
      }
      get(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        const value = Buffer.allocUnsafe(length);
        this.buffer.slice(0, length).copy(value);
        this.buffer.copyWithin(0, length, length + this.offset - length);
        this.offset -= length;
        return value;
      }
    };
    exports.ReceiveBuffer = ReceiveBuffer;
  }
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS({
  "node_modules/socks/build/client/socksclient.js"(exports) {
    init_shims();
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocksClientError = exports.SocksClient = void 0;
    var events_1 = __require("events");
    var net = __require("net");
    var ip = require_ip();
    var smart_buffer_1 = require_smartbuffer();
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers();
    var receivebuffer_1 = require_receivebuffer();
    var util_1 = require_util();
    Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: function() {
      return util_1.SocksClientError;
    } });
    var SocksClient = class extends events_1.EventEmitter {
      constructor(options2) {
        super();
        this.options = Object.assign({}, options2);
        helpers_1.validateSocksClientOptions(options2);
        this.setState(constants_1.SocksClientState.Created);
      }
      static createConnection(options2, callback) {
        return new Promise((resolve3, reject) => {
          try {
            helpers_1.validateSocksClientOptions(options2, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve3(err);
            } else {
              return reject(err);
            }
          }
          const client = new SocksClient(options2);
          client.connect(options2.existing_socket);
          client.once("established", (info) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info);
              resolve3(info);
            } else {
              resolve3(info);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve3(err);
            } else {
              reject(err);
            }
          });
        });
      }
      static createConnectionChain(options2, callback) {
        return new Promise((resolve3, reject) => __awaiter(this, void 0, void 0, function* () {
          try {
            helpers_1.validateSocksClientChainOptions(options2);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve3(err);
            } else {
              return reject(err);
            }
          }
          let sock;
          if (options2.randomizeChain) {
            util_1.shuffleArray(options2.proxies);
          }
          try {
            for (let i = 0; i < options2.proxies.length; i++) {
              const nextProxy = options2.proxies[i];
              const nextDestination = i === options2.proxies.length - 1 ? options2.destination : {
                host: options2.proxies[i + 1].ipaddress,
                port: options2.proxies[i + 1].port
              };
              const result = yield SocksClient.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination
              });
              if (!sock) {
                sock = result.socket;
              }
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve3({ socket: sock });
            } else {
              resolve3({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve3(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      static createUDPFrame(options2) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options2.frameNumber || 0);
        if (net.isIPv4(options2.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE(ip.toLong(options2.remoteHost.host));
        } else if (net.isIPv6(options2.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer(ip.toBuffer(options2.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options2.remoteHost.host));
          buff.writeString(options2.remoteHost.host);
        }
        buff.writeUInt16BE(options2.remoteHost.port);
        buff.writeBuffer(options2.data);
        return buff.toBuffer();
      }
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = ip.fromLong(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip.toString(buff.readBuffer(16));
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info.socket.emit("data", excessData);
            }
            info.socket.resume();
          });
        });
      }
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: ip.fromLong(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: ip.fromLong(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
        } else if (net.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.fromLong(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.toString(buff.readBuffer(16)),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.fromLong(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.toString(buff.readBuffer(16)),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    };
    exports.SocksClient = SocksClient;
  }
});

// node_modules/socks/build/index.js
var require_build = __commonJS({
  "node_modules/socks/build/index.js"(exports) {
    init_shims();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_socksclient(), exports);
  }
});

// node_modules/socks-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/socks-proxy-agent/dist/agent.js"(exports) {
    init_shims();
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dns_1 = __importDefault(__require("dns"));
    var tls_1 = __importDefault(__require("tls"));
    var url_1 = __importDefault(__require("url"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var socks_1 = require_build();
    var debug = debug_1.default("socks-proxy-agent");
    function dnsLookup(host) {
      return new Promise((resolve3, reject) => {
        dns_1.default.lookup(host, (err, res) => {
          if (err) {
            reject(err);
          } else {
            resolve3(res);
          }
        });
      });
    }
    function parseSocksProxy(opts) {
      let port = 0;
      let lookup = false;
      let type = 5;
      const host = opts.hostname || opts.host;
      if (!host) {
        throw new TypeError('No "host"');
      }
      if (typeof opts.port === "number") {
        port = opts.port;
      } else if (typeof opts.port === "string") {
        port = parseInt(opts.port, 10);
      }
      if (!port) {
        port = 1080;
      }
      if (opts.protocol) {
        switch (opts.protocol.replace(":", "")) {
          case "socks4":
            lookup = true;
          case "socks4a":
            type = 4;
            break;
          case "socks5":
            lookup = true;
          case "socks":
          case "socks5h":
            type = 5;
            break;
          default:
            throw new TypeError(`A "socks" protocol must be specified! Got: ${opts.protocol}`);
        }
      }
      if (typeof opts.type !== "undefined") {
        if (opts.type === 4 || opts.type === 5) {
          type = opts.type;
        } else {
          throw new TypeError(`"type" must be 4 or 5, got: ${opts.type}`);
        }
      }
      const proxy = {
        host,
        port,
        type
      };
      let userId = opts.userId || opts.username;
      let password = opts.password;
      if (opts.auth) {
        const auth = opts.auth.split(":");
        userId = auth[0];
        password = auth[1];
      }
      if (userId) {
        Object.defineProperty(proxy, "userId", {
          value: userId,
          enumerable: false
        });
      }
      if (password) {
        Object.defineProperty(proxy, "password", {
          value: password,
          enumerable: false
        });
      }
      return { lookup, proxy };
    }
    var SocksProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new TypeError("a SOCKS proxy server `host` and `port` must be specified!");
        }
        super(opts);
        const parsedProxy = parseSocksProxy(opts);
        this.lookup = parsedProxy.lookup;
        this.proxy = parsedProxy.proxy;
        this.tlsConnectionOptions = opts.tls || {};
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { lookup, proxy } = this;
          let { host, port, timeout } = opts;
          if (!host) {
            throw new Error("No `host` defined!");
          }
          if (lookup) {
            host = yield dnsLookup(host);
          }
          const socksOpts = {
            proxy,
            destination: { host, port },
            command: "connect",
            timeout
          };
          debug("Creating socks proxy connection: %o", socksOpts);
          const { socket } = yield socks_1.SocksClient.createConnection(socksOpts);
          debug("Successfully created socks proxy connection");
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls_1.default.connect(Object.assign(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }), this.tlsConnectionOptions));
          }
          return socket;
        });
      }
    };
    exports.default = SocksProxyAgent;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/socks-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/socks-proxy-agent/dist/index.js"(exports, module) {
    init_shims();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createSocksProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createSocksProxyAgent2) {
      createSocksProxyAgent2.SocksProxyAgent = agent_1.default;
      createSocksProxyAgent2.prototype = agent_1.default.prototype;
    })(createSocksProxyAgent || (createSocksProxyAgent = {}));
    module.exports = createSocksProxyAgent;
  }
});

// node_modules/playwright-core/lib/server/cookieStore.js
var require_cookieStore = __commonJS({
  "node_modules/playwright-core/lib/server/cookieStore.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.domainMatches = domainMatches;
    exports.CookieStore = void 0;
    var Cookie = class {
      constructor(data) {
        this._raw = void 0;
        this._raw = data;
      }
      name() {
        return this._raw.name;
      }
      matches(url) {
        if (this._raw.secure && url.protocol !== "https:")
          return false;
        if (!domainMatches(url.hostname, this._raw.domain))
          return false;
        if (!pathMatches(url.pathname, this._raw.path))
          return false;
        return true;
      }
      equals(other) {
        return this._raw.name === other._raw.name && this._raw.domain === other._raw.domain && this._raw.path === other._raw.path;
      }
      networkCookie() {
        return this._raw;
      }
      updateExpiresFrom(other) {
        this._raw.expires = other._raw.expires;
      }
      expired() {
        if (this._raw.expires === -1)
          return false;
        return this._raw.expires * 1e3 < Date.now();
      }
    };
    var CookieStore = class {
      constructor() {
        this._nameToCookies = new Map();
      }
      addCookies(cookies) {
        for (const cookie of cookies)
          this._addCookie(new Cookie(cookie));
      }
      cookies(url) {
        const result = [];
        for (const cookie of this._cookiesIterator()) {
          if (cookie.matches(url))
            result.push(cookie.networkCookie());
        }
        return result;
      }
      allCookies() {
        const result = [];
        for (const cookie of this._cookiesIterator())
          result.push(cookie.networkCookie());
        return result;
      }
      _addCookie(cookie) {
        if (cookie.expired())
          return;
        let set = this._nameToCookies.get(cookie.name());
        if (!set) {
          set = new Set();
          this._nameToCookies.set(cookie.name(), set);
        }
        CookieStore.pruneExpired(set);
        for (const other of set) {
          if (other.equals(cookie)) {
            cookie.updateExpiresFrom(other);
            set.delete(other);
          }
        }
        set.add(cookie);
      }
      *_cookiesIterator() {
        for (const [name, cookies] of this._nameToCookies) {
          CookieStore.pruneExpired(cookies);
          for (const cookie of cookies)
            yield cookie;
          if (cookies.size === 0)
            this._nameToCookies.delete(name);
        }
      }
      static pruneExpired(cookies) {
        for (const cookie of cookies) {
          if (cookie.expired())
            cookies.delete(cookie);
        }
      }
    };
    exports.CookieStore = CookieStore;
    function domainMatches(value, domain) {
      if (value === domain)
        return true;
      if (!domain.startsWith("."))
        return false;
      value = "." + value;
      return value.endsWith(domain);
    }
    function pathMatches(value, path) {
      if (value === path)
        return true;
      if (!value.endsWith("/"))
        value = value + "/";
      if (!path.endsWith("/"))
        path = path + "/";
      return value.startsWith(path);
    }
  }
});

// node_modules/playwright-core/lib/server/formData.js
var require_formData = __commonJS({
  "node_modules/playwright-core/lib/server/formData.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MultipartFormData = void 0;
    var MultipartFormData = class {
      constructor() {
        this._boundary = void 0;
        this._chunks = [];
        this._boundary = generateUniqueBoundaryString();
      }
      contentTypeHeader() {
        return `multipart/form-data; boundary=${this._boundary}`;
      }
      addField(name, value) {
        this._beginMultiPartHeader(name);
        this._finishMultiPartHeader();
        this._chunks.push(Buffer.from(value));
        this._finishMultiPartField();
      }
      addFileField(name, value) {
        this._beginMultiPartHeader(name);
        this._chunks.push(Buffer.from(`; filename="${value.name}"`));
        this._chunks.push(Buffer.from(`\r
content-type: ${value.mimeType || "application/octet-stream"}`));
        this._finishMultiPartHeader();
        this._chunks.push(Buffer.from(value.buffer, "base64"));
        this._finishMultiPartField();
      }
      finish() {
        this._addBoundary(true);
        return Buffer.concat(this._chunks);
      }
      _beginMultiPartHeader(name) {
        this._addBoundary();
        this._chunks.push(Buffer.from(`content-disposition: form-data; name="${name}"`));
      }
      _finishMultiPartHeader() {
        this._chunks.push(Buffer.from(`\r
\r
`));
      }
      _finishMultiPartField() {
        this._chunks.push(Buffer.from(`\r
`));
      }
      _addBoundary(isLastBoundary) {
        this._chunks.push(Buffer.from("--" + this._boundary));
        if (isLastBoundary)
          this._chunks.push(Buffer.from("--"));
        this._chunks.push(Buffer.from("\r\n"));
      }
    };
    exports.MultipartFormData = MultipartFormData;
    var alphaNumericEncodingMap = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66];
    function generateUniqueBoundaryString() {
      const charCodes = [];
      for (let i = 0; i < 16; i++)
        charCodes.push(alphaNumericEncodingMap[Math.floor(Math.random() * alphaNumericEncodingMap.length)]);
      return "----WebKitFormBoundary" + String.fromCharCode(...charCodes);
    }
  }
});

// node_modules/playwright-core/lib/server/fetch.js
var require_fetch = __commonJS({
  "node_modules/playwright-core/lib/server/fetch.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GlobalAPIRequestContext = exports.BrowserContextAPIRequestContext = exports.APIRequestContext = void 0;
    var http2 = _interopRequireWildcard(__require("http"));
    var https2 = _interopRequireWildcard(__require("https"));
    var _httpsProxyAgent = require_dist();
    var _socksProxyAgent = require_dist2();
    var _stream = __require("stream");
    var _url = _interopRequireDefault(__require("url"));
    var _zlib = _interopRequireDefault(__require("zlib"));
    var _debugLogger = require_debugLogger();
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _browserContext = require_browserContext();
    var _cookieStore = require_cookieStore();
    var _formData = require_formData();
    var _instrumentation = require_instrumentation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var APIRequestContext = class extends _instrumentation.SdkObject {
      static findResponseBody(guid) {
        for (const request of APIRequestContext.allInstances) {
          const body = request.fetchResponses.get(guid);
          if (body)
            return body;
        }
        return void 0;
      }
      constructor(parent) {
        super(parent, "fetchRequest");
        this.fetchResponses = new Map();
        APIRequestContext.allInstances.add(this);
      }
      _disposeImpl() {
        APIRequestContext.allInstances.delete(this);
        this.fetchResponses.clear();
        this.emit(APIRequestContext.Events.Dispose);
      }
      _storeResponseBody(body) {
        const uid = (0, _utils.createGuid)();
        this.fetchResponses.set(uid, body);
        return uid;
      }
      async fetch(params) {
        try {
          var _params$method;
          const headers = {};
          const defaults = this._defaultOptions();
          headers["user-agent"] = defaults.userAgent;
          headers["accept"] = "*/*";
          headers["accept-encoding"] = "gzip,deflate,br";
          if (defaults.extraHTTPHeaders) {
            for (const {
              name,
              value
            } of defaults.extraHTTPHeaders)
              headers[name.toLowerCase()] = value;
          }
          if (params.headers) {
            for (const {
              name,
              value
            } of params.headers)
              headers[name.toLowerCase()] = value;
          }
          const method = ((_params$method = params.method) === null || _params$method === void 0 ? void 0 : _params$method.toUpperCase()) || "GET";
          const proxy = defaults.proxy;
          let agent;
          if (proxy) {
            var _proxyOpts$protocol;
            const proxyOpts = _url.default.parse(proxy.server);
            if ((_proxyOpts$protocol = proxyOpts.protocol) !== null && _proxyOpts$protocol !== void 0 && _proxyOpts$protocol.startsWith("socks")) {
              agent = new _socksProxyAgent.SocksProxyAgent({
                host: proxyOpts.hostname,
                port: proxyOpts.port || void 0
              });
            } else {
              if (proxy.username)
                proxyOpts.auth = `${proxy.username}:${proxy.password || ""}`;
              agent = new _httpsProxyAgent.HttpsProxyAgent(proxyOpts);
            }
          }
          const timeout = defaults.timeoutSettings.timeout(params);
          const deadline = timeout && (0, _utils.monotonicTime)() + timeout;
          const options2 = {
            method,
            headers,
            agent,
            maxRedirects: 20,
            timeout,
            deadline
          };
          if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors)
            options2.rejectUnauthorized = false;
          const requestUrl = new URL(params.url, defaults.baseURL);
          if (params.params) {
            for (const {
              name,
              value
            } of params.params)
              requestUrl.searchParams.set(name, value);
          }
          let postData;
          if (["POST", "PUT", "PATCH", "DELETE"].includes(method))
            postData = serializePostData(params, headers);
          else if (params.postData || params.jsonData || params.formData || params.multipartData)
            throw new Error(`Method ${method} does not accept post data`);
          if (postData)
            headers["content-length"] = String(postData.byteLength);
          const fetchResponse = await this._sendRequest(requestUrl, options2, postData);
          const fetchUid = this._storeResponseBody(fetchResponse.body);
          if (params.failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400))
            return {
              error: `${fetchResponse.status} ${fetchResponse.statusText}`
            };
          return {
            fetchResponse: __spreadProps(__spreadValues({}, fetchResponse), {
              fetchUid
            })
          };
        } catch (e) {
          return {
            error: e instanceof Error ? e.message : String(e)
          };
        }
      }
      async _updateCookiesFromHeader(responseUrl, setCookie) {
        const url = new URL(responseUrl);
        const defaultPath = "/" + url.pathname.substr(1).split("/").slice(0, -1).join("/");
        const cookies = [];
        for (const header of setCookie) {
          const cookie = parseCookie(header);
          if (!cookie)
            continue;
          if (!cookie.domain)
            cookie.domain = url.hostname;
          else
            (0, _utils.assert)(cookie.domain.startsWith("."));
          if (!(0, _cookieStore.domainMatches)(url.hostname, cookie.domain))
            continue;
          if (!cookie.path || !cookie.path.startsWith("/"))
            cookie.path = defaultPath;
          cookies.push(cookie);
        }
        if (cookies.length)
          await this._addCookies(cookies);
      }
      async _updateRequestCookieHeader(url, options2) {
        if (options2.headers["cookie"] !== void 0)
          return;
        const cookies = await this._cookies(url);
        if (cookies.length) {
          const valueArray = cookies.map((c) => `${c.name}=${c.value}`);
          options2.headers["cookie"] = valueArray.join("; ");
        }
      }
      async _sendRequest(url, options2, postData) {
        await this._updateRequestCookieHeader(url, options2);
        return new Promise((fulfill, reject) => {
          const requestConstructor = (url.protocol === "https:" ? https2 : http2).request;
          const request = requestConstructor(url, options2, async (response) => {
            if (_debugLogger.debugLogger.isEnabled("api")) {
              _debugLogger.debugLogger.log("api", `\u2190 ${response.statusCode} ${response.statusMessage}`);
              for (const [name, value] of Object.entries(response.headers))
                _debugLogger.debugLogger.log("api", `  ${name}: ${value}`);
            }
            if (response.headers["set-cookie"])
              await this._updateCookiesFromHeader(response.url || url.toString(), response.headers["set-cookie"]);
            if (redirectStatus2.includes(response.statusCode)) {
              if (!options2.maxRedirects) {
                reject(new Error("Max redirect count exceeded"));
                request.destroy();
                return;
              }
              const headers = __spreadValues({}, options2.headers);
              delete headers[`cookie`];
              const status = response.statusCode;
              let method = options2.method;
              if ((status === 301 || status === 302) && method === "POST" || status === 303 && !["GET", "HEAD"].includes(method)) {
                method = "GET";
                postData = void 0;
                delete headers[`content-encoding`];
                delete headers[`content-language`];
                delete headers[`content-length`];
                delete headers[`content-location`];
                delete headers[`content-type`];
              }
              const redirectOptions = {
                method,
                headers,
                agent: options2.agent,
                maxRedirects: options2.maxRedirects - 1,
                timeout: options2.timeout,
                deadline: options2.deadline
              };
              if (options2.rejectUnauthorized === false)
                redirectOptions.rejectUnauthorized = false;
              if (response.headers.location) {
                const locationURL = new URL(response.headers.location, url);
                fulfill(this._sendRequest(locationURL, redirectOptions, postData));
                request.destroy();
                return;
              }
            }
            if (response.statusCode === 401 && !options2.headers["authorization"]) {
              const auth = response.headers["www-authenticate"];
              const credentials = this._defaultOptions().httpCredentials;
              if (auth !== null && auth !== void 0 && auth.trim().startsWith("Basic ") && credentials) {
                const {
                  username,
                  password
                } = credentials;
                const encoded = Buffer.from(`${username || ""}:${password || ""}`).toString("base64");
                options2.headers["authorization"] = `Basic ${encoded}`;
                fulfill(this._sendRequest(url, options2, postData));
                request.destroy();
                return;
              }
            }
            response.on("aborted", () => reject(new Error("aborted")));
            let body = response;
            let transform;
            const encoding = response.headers["content-encoding"];
            if (encoding === "gzip" || encoding === "x-gzip") {
              transform = _zlib.default.createGunzip({
                flush: _zlib.default.constants.Z_SYNC_FLUSH,
                finishFlush: _zlib.default.constants.Z_SYNC_FLUSH
              });
            } else if (encoding === "br") {
              transform = _zlib.default.createBrotliDecompress();
            } else if (encoding === "deflate") {
              transform = _zlib.default.createInflate();
            }
            if (transform) {
              body = (0, _stream.pipeline)(response, transform, (e) => {
                if (e)
                  reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`));
              });
            }
            const chunks = [];
            body.on("data", (chunk) => chunks.push(chunk));
            body.on("end", () => {
              const body2 = Buffer.concat(chunks);
              fulfill({
                url: response.url || url.toString(),
                status: response.statusCode || 0,
                statusText: response.statusMessage || "",
                headers: toHeadersArray(response.rawHeaders),
                body: body2
              });
            });
            body.on("error", reject);
          });
          request.on("error", reject);
          const disposeListener = () => {
            reject(new Error("Request context disposed."));
            request.destroy();
          };
          this.on(APIRequestContext.Events.Dispose, disposeListener);
          request.on("close", () => this.off(APIRequestContext.Events.Dispose, disposeListener));
          if (_debugLogger.debugLogger.isEnabled("api")) {
            _debugLogger.debugLogger.log("api", `\u2192 ${options2.method} ${url.toString()}`);
            if (options2.headers) {
              for (const [name, value] of Object.entries(options2.headers))
                _debugLogger.debugLogger.log("api", `  ${name}: ${value}`);
            }
          }
          if (options2.deadline) {
            const rejectOnTimeout = () => {
              reject(new Error(`Request timed out after ${options2.timeout}ms`));
              request.destroy();
            };
            const remaining = options2.deadline - (0, _utils.monotonicTime)();
            if (remaining <= 0) {
              rejectOnTimeout();
              return;
            }
            request.setTimeout(remaining, rejectOnTimeout);
          }
          if (postData)
            request.write(postData);
          request.end();
        });
      }
    };
    exports.APIRequestContext = APIRequestContext;
    APIRequestContext.Events = {
      Dispose: "dispose"
    };
    APIRequestContext.allInstances = new Set();
    var BrowserContextAPIRequestContext = class extends APIRequestContext {
      constructor(context) {
        super(context);
        this._context = void 0;
        this._context = context;
        context.once(_browserContext.BrowserContext.Events.Close, () => this._disposeImpl());
      }
      dispose() {
        this.fetchResponses.clear();
      }
      _defaultOptions() {
        return {
          userAgent: this._context._options.userAgent || this._context._browser.userAgent(),
          extraHTTPHeaders: this._context._options.extraHTTPHeaders,
          httpCredentials: this._context._options.httpCredentials,
          proxy: this._context._options.proxy || this._context._browser.options.proxy,
          timeoutSettings: this._context._timeoutSettings,
          ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,
          baseURL: this._context._options.baseURL
        };
      }
      async _addCookies(cookies) {
        await this._context.addCookies(cookies);
      }
      async _cookies(url) {
        return await this._context.cookies(url.toString());
      }
      async storageState() {
        return this._context.storageState();
      }
    };
    exports.BrowserContextAPIRequestContext = BrowserContextAPIRequestContext;
    var GlobalAPIRequestContext = class extends APIRequestContext {
      constructor(playwright3, options2) {
        super(playwright3);
        this._cookieStore = new _cookieStore.CookieStore();
        this._options = void 0;
        this._origins = void 0;
        const timeoutSettings = new _timeoutSettings.TimeoutSettings();
        if (options2.timeout !== void 0)
          timeoutSettings.setDefaultTimeout(options2.timeout);
        const proxy = options2.proxy;
        if (proxy !== null && proxy !== void 0 && proxy.server) {
          let url = proxy === null || proxy === void 0 ? void 0 : proxy.server.trim();
          if (!/^\w+:\/\//.test(url))
            url = "http://" + url;
          proxy.server = url;
        }
        if (options2.storageState) {
          this._origins = options2.storageState.origins;
          this._cookieStore.addCookies(options2.storageState.cookies);
        }
        this._options = {
          baseURL: options2.baseURL,
          userAgent: options2.userAgent || `Playwright/${(0, _utils.getPlaywrightVersion)()}`,
          extraHTTPHeaders: options2.extraHTTPHeaders,
          ignoreHTTPSErrors: !!options2.ignoreHTTPSErrors,
          httpCredentials: options2.httpCredentials,
          proxy,
          timeoutSettings
        };
      }
      dispose() {
        this._disposeImpl();
      }
      _defaultOptions() {
        return this._options;
      }
      async _addCookies(cookies) {
        this._cookieStore.addCookies(cookies);
      }
      async _cookies(url) {
        return this._cookieStore.cookies(url);
      }
      async storageState() {
        return {
          cookies: this._cookieStore.allCookies(),
          origins: this._origins || []
        };
      }
    };
    exports.GlobalAPIRequestContext = GlobalAPIRequestContext;
    function toHeadersArray(rawHeaders) {
      const result = [];
      for (let i = 0; i < rawHeaders.length; i += 2)
        result.push({
          name: rawHeaders[i],
          value: rawHeaders[i + 1]
        });
      return result;
    }
    var redirectStatus2 = [301, 302, 303, 307, 308];
    function parseCookie(header) {
      const pairs = header.split(";").filter((s2) => s2.trim().length > 0).map((p) => p.split("=").map((s2) => s2.trim()));
      if (!pairs.length)
        return null;
      const [name, value] = pairs[0];
      const cookie = {
        name,
        value,
        domain: "",
        path: "",
        expires: -1,
        httpOnly: false,
        secure: false,
        sameSite: "Lax"
      };
      for (let i = 1; i < pairs.length; i++) {
        const [name2, value2] = pairs[i];
        switch (name2.toLowerCase()) {
          case "expires":
            const expiresMs = +new Date(value2);
            if (isFinite(expiresMs))
              cookie.expires = expiresMs / 1e3;
            break;
          case "max-age":
            const maxAgeSec = parseInt(value2, 10);
            if (isFinite(maxAgeSec))
              cookie.expires = Date.now() / 1e3 + maxAgeSec;
            break;
          case "domain":
            cookie.domain = value2.toLocaleLowerCase() || "";
            if (cookie.domain && !cookie.domain.startsWith("."))
              cookie.domain = "." + cookie.domain;
            break;
          case "path":
            cookie.path = value2 || "";
            break;
          case "secure":
            cookie.secure = true;
            break;
          case "httponly":
            cookie.httpOnly = true;
            break;
        }
      }
      return cookie;
    }
    function isJsonParsable(value) {
      if (typeof value !== "string")
        return false;
      try {
        JSON.parse(value);
        return true;
      } catch (e) {
        if (e instanceof SyntaxError)
          return false;
        else
          throw e;
      }
    }
    function serializePostData(params, headers) {
      (0, _utils.assert)((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
      if (params.jsonData) {
        var _contentType, _headers$_contentType;
        const json = isJsonParsable(params.jsonData) ? params.jsonData : JSON.stringify(params.jsonData);
        (_headers$_contentType = headers[_contentType = "content-type"]) !== null && _headers$_contentType !== void 0 ? _headers$_contentType : headers[_contentType] = "application/json";
        return Buffer.from(json, "utf8");
      } else if (params.formData) {
        var _contentType2, _headers$_contentType2;
        const searchParams = new URLSearchParams();
        for (const {
          name,
          value
        } of params.formData)
          searchParams.append(name, value);
        (_headers$_contentType2 = headers[_contentType2 = "content-type"]) !== null && _headers$_contentType2 !== void 0 ? _headers$_contentType2 : headers[_contentType2] = "application/x-www-form-urlencoded";
        return Buffer.from(searchParams.toString(), "utf8");
      } else if (params.multipartData) {
        var _contentType3, _headers$_contentType3;
        const formData = new _formData.MultipartFormData();
        for (const field of params.multipartData) {
          if (field.file)
            formData.addFileField(field.name, field.file);
          else if (field.value)
            formData.addField(field.name, field.value);
        }
        (_headers$_contentType3 = headers[_contentType3 = "content-type"]) !== null && _headers$_contentType3 !== void 0 ? _headers$_contentType3 : headers[_contentType3] = formData.contentTypeHeader();
        return formData.finish();
      } else if (params.postData) {
        var _contentType4, _headers$_contentType4;
        (_headers$_contentType4 = headers[_contentType4 = "content-type"]) !== null && _headers$_contentType4 !== void 0 ? _headers$_contentType4 : headers[_contentType4] = "application/octet-stream";
        return Buffer.from(params.postData, "base64");
      }
      return void 0;
    }
  }
});

// node_modules/playwright-core/lib/server/network.js
var require_network = __commonJS({
  "node_modules/playwright-core/lib/server/network.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.filterCookies = filterCookies;
    exports.rewriteCookies = rewriteCookies;
    exports.parsedURL = parsedURL;
    exports.stripFragmentFromUrl = stripFragmentFromUrl;
    exports.singleHeader = singleHeader;
    exports.mergeHeaders = mergeHeaders;
    exports.STATUS_TEXTS = exports.WebSocket = exports.Response = exports.Route = exports.Request = void 0;
    var _utils = require_utils();
    var _async = require_async();
    var _instrumentation = require_instrumentation();
    var _fetch = require_fetch();
    function filterCookies(cookies, urls) {
      const parsedURLs = urls.map((s2) => new URL(s2));
      return cookies.filter((c) => {
        if (!parsedURLs.length)
          return true;
        for (const parsedURL2 of parsedURLs) {
          let domain = c.domain;
          if (!domain.startsWith("."))
            domain = "." + domain;
          if (!("." + parsedURL2.hostname).endsWith(domain))
            continue;
          if (!parsedURL2.pathname.startsWith(c.path))
            continue;
          if (parsedURL2.protocol !== "https:" && c.secure)
            continue;
          return true;
        }
        return false;
      });
    }
    function rewriteCookies(cookies) {
      return cookies.map((c) => {
        (0, _utils.assert)(c.name, "Cookie should have a name");
        (0, _utils.assert)(c.url || c.domain && c.path, "Cookie should have a url or a domain/path pair");
        (0, _utils.assert)(!(c.url && c.domain), "Cookie should have either url or domain");
        (0, _utils.assert)(!(c.url && c.path), "Cookie should have either url or path");
        const copy = __spreadValues({}, c);
        if (copy.url) {
          (0, _utils.assert)(copy.url !== "about:blank", `Blank page can not have cookie "${c.name}"`);
          (0, _utils.assert)(!copy.url.startsWith("data:"), `Data URL page can not have cookie "${c.name}"`);
          const url = new URL(copy.url);
          copy.domain = url.hostname;
          copy.path = url.pathname.substring(0, url.pathname.lastIndexOf("/") + 1);
          copy.secure = url.protocol === "https:";
        }
        return copy;
      });
    }
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    function stripFragmentFromUrl(url) {
      if (!url.includes("#"))
        return url;
      return url.substring(0, url.indexOf("#"));
    }
    var Request2 = class extends _instrumentation.SdkObject {
      constructor(frame, redirectedFrom, documentId, url, resourceType, method, postData, headers) {
        super(frame, "request");
        this._response = null;
        this._redirectedFrom = void 0;
        this._redirectedTo = null;
        this._documentId = void 0;
        this._isFavicon = void 0;
        this._failureText = null;
        this._url = void 0;
        this._resourceType = void 0;
        this._method = void 0;
        this._postData = void 0;
        this._headers = void 0;
        this._headersMap = new Map();
        this._rawRequestHeadersPromise = void 0;
        this._frame = void 0;
        this._waitForResponsePromise = new _async.ManualPromise();
        this._responseEndTiming = -1;
        this.responseSize = {
          encodedBodySize: 0,
          transferSize: 0,
          responseHeadersSize: 0
        };
        (0, _utils.assert)(!url.startsWith("data:"), "Data urls should not fire requests");
        this._frame = frame;
        this._redirectedFrom = redirectedFrom;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        this._documentId = documentId;
        this._url = stripFragmentFromUrl(url);
        this._resourceType = resourceType;
        this._method = method;
        this._postData = postData;
        this._headers = headers;
        for (const {
          name,
          value
        } of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._isFavicon = url.endsWith("/favicon.ico") || !!(redirectedFrom !== null && redirectedFrom !== void 0 && redirectedFrom._isFavicon);
      }
      _setFailureText(failureText) {
        this._failureText = failureText;
        this._waitForResponsePromise.resolve(null);
      }
      url() {
        return this._url;
      }
      resourceType() {
        return this._resourceType;
      }
      method() {
        return this._method;
      }
      postDataBuffer() {
        return this._postData;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      setWillReceiveExtraHeaders() {
        if (!this._rawRequestHeadersPromise)
          this._rawRequestHeadersPromise = new _async.ManualPromise();
      }
      setRawRequestHeaders(headers) {
        if (!this._rawRequestHeadersPromise)
          this._rawRequestHeadersPromise = new _async.ManualPromise();
        this._rawRequestHeadersPromise.resolve(headers);
      }
      async rawRequestHeaders() {
        return this._rawRequestHeadersPromise || Promise.resolve(this._headers);
      }
      rawRequestHeadersPromise() {
        return this._rawRequestHeadersPromise;
      }
      response() {
        return this._waitForResponsePromise;
      }
      _existingResponse() {
        return this._response;
      }
      _setResponse(response) {
        this._response = response;
        this._waitForResponsePromise.resolve(response);
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
      frame() {
        return this._frame;
      }
      isNavigationRequest() {
        return !!this._documentId;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      bodySize() {
        var _this$postDataBuffer;
        return ((_this$postDataBuffer = this.postDataBuffer()) === null || _this$postDataBuffer === void 0 ? void 0 : _this$postDataBuffer.length) || 0;
      }
      async requestHeadersSize() {
        let headersSize = 4;
        headersSize += this.method().length;
        headersSize += new URL(this.url()).pathname.length;
        headersSize += 8;
        const headers = this.rawRequestHeadersPromise() ? await this.rawRequestHeadersPromise() : this._headers;
        for (const header of headers)
          headersSize += header.name.length + header.value.length + 4;
        return headersSize;
      }
    };
    exports.Request = Request2;
    var Route = class extends _instrumentation.SdkObject {
      constructor(request, delegate) {
        super(request.frame(), "route");
        this._request = void 0;
        this._delegate = void 0;
        this._handled = false;
        this._request = request;
        this._delegate = delegate;
      }
      request() {
        return this._request;
      }
      async abort(errorCode = "failed") {
        (0, _utils.assert)(!this._handled, "Route is already handled!");
        this._handled = true;
        await this._delegate.abort(errorCode);
      }
      async fulfill(overrides) {
        (0, _utils.assert)(!this._handled, "Route is already handled!");
        this._handled = true;
        let body = overrides.body;
        let isBase64 = overrides.isBase64 || false;
        if (body === void 0) {
          if (overrides.fetchResponseUid) {
            const context = this._request.frame()._page._browserContext;
            const buffer = context.fetchRequest.fetchResponses.get(overrides.fetchResponseUid) || _fetch.APIRequestContext.findResponseBody(overrides.fetchResponseUid);
            (0, _utils.assert)(buffer, "Fetch response has been disposed");
            body = buffer.toString("base64");
            isBase64 = true;
          } else {
            body = "";
            isBase64 = false;
          }
        }
        await this._delegate.fulfill({
          status: overrides.status || 200,
          headers: overrides.headers || [],
          body,
          isBase64
        });
      }
      async continue(overrides = {}) {
        (0, _utils.assert)(!this._handled, "Route is already handled!");
        if (overrides.url) {
          const newUrl = new URL(overrides.url);
          const oldUrl = new URL(this._request.url());
          if (oldUrl.protocol !== newUrl.protocol)
            throw new Error("New URL must have same protocol as overridden URL");
        }
        await this._delegate.continue(this._request, overrides);
      }
    };
    exports.Route = Route;
    var Response2 = class extends _instrumentation.SdkObject {
      constructor(request, status, statusText, headers, timing, getResponseBodyCallback, httpVersion) {
        super(request.frame(), "response");
        this._request = void 0;
        this._contentPromise = null;
        this._finishedPromise = new _async.ManualPromise();
        this._status = void 0;
        this._statusText = void 0;
        this._url = void 0;
        this._headers = void 0;
        this._headersMap = new Map();
        this._getResponseBodyCallback = void 0;
        this._timing = void 0;
        this._serverAddrPromise = new _async.ManualPromise();
        this._securityDetailsPromise = new _async.ManualPromise();
        this._rawResponseHeadersPromise = void 0;
        this._httpVersion = void 0;
        this._request = request;
        this._timing = timing;
        this._status = status;
        this._statusText = statusText;
        this._url = request.url();
        this._headers = headers;
        for (const {
          name,
          value
        } of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._getResponseBodyCallback = getResponseBodyCallback;
        this._request._setResponse(this);
        this._httpVersion = httpVersion;
      }
      _serverAddrFinished(addr) {
        this._serverAddrPromise.resolve(addr);
      }
      _securityDetailsFinished(securityDetails) {
        this._securityDetailsPromise.resolve(securityDetails);
      }
      _requestFinished(responseEndTiming) {
        this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);
        this._finishedPromise.resolve();
      }
      _setHttpVersion(httpVersion) {
        this._httpVersion = httpVersion;
      }
      url() {
        return this._url;
      }
      status() {
        return this._status;
      }
      statusText() {
        return this._statusText;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      async rawResponseHeaders() {
        return this._rawResponseHeadersPromise || Promise.resolve(this._headers);
      }
      setWillReceiveExtraHeaders() {
        this._request.setWillReceiveExtraHeaders();
        this._rawResponseHeadersPromise = new _async.ManualPromise();
      }
      setRawResponseHeaders(headers) {
        if (!this._rawResponseHeadersPromise)
          this._rawResponseHeadersPromise = new _async.ManualPromise();
        this._rawResponseHeadersPromise.resolve(headers);
      }
      timing() {
        return this._timing;
      }
      async serverAddr() {
        return await this._serverAddrPromise || null;
      }
      async securityDetails() {
        return await this._securityDetailsPromise || null;
      }
      body() {
        if (!this._contentPromise) {
          this._contentPromise = this._finishedPromise.then(async () => {
            if (this._status >= 300 && this._status <= 399)
              throw new Error("Response body is unavailable for redirect responses");
            return this._getResponseBodyCallback();
          });
        }
        return this._contentPromise;
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
      httpVersion() {
        if (!this._httpVersion)
          return "HTTP/1.1";
        if (this._httpVersion === "http/1.1")
          return "HTTP/1.1";
        return this._httpVersion;
      }
      async _responseHeadersSize() {
        if (this._request.responseSize.responseHeadersSize)
          return this._request.responseSize.responseHeadersSize;
        let headersSize = 4;
        headersSize += 8;
        headersSize += 3;
        headersSize += this.statusText().length;
        const headers = await this._bestEffortResponseHeaders();
        for (const header of headers)
          headersSize += header.name.length + header.value.length + 4;
        headersSize += 2;
        return headersSize;
      }
      async _bestEffortResponseHeaders() {
        return this._rawResponseHeadersPromise ? await this._rawResponseHeadersPromise : this._headers;
      }
      async sizes() {
        await this._finishedPromise;
        const requestHeadersSize = await this._request.requestHeadersSize();
        const responseHeadersSize = await this._responseHeadersSize();
        let {
          encodedBodySize
        } = this._request.responseSize;
        if (!encodedBodySize) {
          var _headers$find;
          const headers = await this._bestEffortResponseHeaders();
          const contentLength = (_headers$find = headers.find((h) => h.name.toLowerCase() === "content-length")) === null || _headers$find === void 0 ? void 0 : _headers$find.value;
          encodedBodySize = contentLength ? +contentLength : 0;
        }
        return {
          requestBodySize: this._request.bodySize(),
          requestHeadersSize,
          responseBodySize: encodedBodySize,
          responseHeadersSize
        };
      }
    };
    exports.Response = Response2;
    var WebSocket = class extends _instrumentation.SdkObject {
      constructor(parent, url) {
        super(parent, "ws");
        this._url = void 0;
        this._url = url;
      }
      url() {
        return this._url;
      }
      frameSent(opcode, data) {
        this.emit(WebSocket.Events.FrameSent, {
          opcode,
          data
        });
      }
      frameReceived(opcode, data) {
        this.emit(WebSocket.Events.FrameReceived, {
          opcode,
          data
        });
      }
      error(errorMessage) {
        this.emit(WebSocket.Events.SocketError, errorMessage);
      }
      closed() {
        this.emit(WebSocket.Events.Close);
      }
    };
    exports.WebSocket = WebSocket;
    WebSocket.Events = {
      Close: "close",
      SocketError: "socketerror",
      FrameReceived: "framereceived",
      FrameSent: "framesent"
    };
    var STATUS_TEXTS = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "Switch Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    exports.STATUS_TEXTS = STATUS_TEXTS;
    function singleHeader(name, value) {
      return [{
        name,
        value
      }];
    }
    function mergeHeaders(headers) {
      const lowerCaseToValue = new Map();
      const lowerCaseToOriginalCase = new Map();
      for (const h of headers) {
        if (!h)
          continue;
        for (const {
          name,
          value
        } of h) {
          const lower = name.toLowerCase();
          lowerCaseToOriginalCase.set(lower, name);
          lowerCaseToValue.set(lower, value);
        }
      }
      const result = [];
      for (const [lower, value] of lowerCaseToValue)
        result.push({
          name: lowerCaseToOriginalCase.get(lower),
          value
        });
      return result;
    }
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports, module) {
    init_shims();
    "use strict";
    function Mime2() {
      this._types = Object.create(null);
      this._extensions = Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime2.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime2.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime2.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module.exports = Mime2;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports, module) {
    init_shims();
    module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/mime/types/other.js"(exports, module) {
    init_shims();
    module.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/mime/index.js"(exports, module) {
    init_shims();
    "use strict";
    var Mime2 = require_Mime();
    module.exports = new Mime2(require_standard(), require_other());
  }
});

// node_modules/playwright-core/lib/generated/injectedScriptSource.js
var require_injectedScriptSource = __commonJS({
  "node_modules/playwright-core/lib/generated/injectedScriptSource.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.source = void 0;
    var source = 'var pwExport;(()=>{"use strict";var e={204:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.checkComponentAttribute=function(e,t){for(const n of t.jsonPath)null!=e&&(e=e[n]);const n="string"!=typeof e||t.caseSensetive?e:e.toUpperCase(),r="string"!=typeof t.value||t.caseSensetive?t.value:t.value.toUpperCase();return"<truthy>"===t.op?!!n:"="===t.op?n===r:"string"==typeof n&&"string"==typeof r&&("*="===t.op?n.includes(r):"^="===t.op?n.startsWith(r):"$="===t.op?n.endsWith(r):"|="===t.op?n===r||n.startsWith(r+"-"):"~="===t.op&&n.split(" ").includes(r))},t.parseComponentSelector=function(e){let t=0,n=0===e.length;const r=()=>e[t]||"",o=()=>{const o=r();return++t,n=t>=e.length,o},i=o=>{if(n)throw new Error(`Unexpected end of selector while parsing selector \\`${e}\\``);throw new Error(`Error while parsing selector \\`${e}\\` - unexpected symbol "${r()}" at position ${t}`+(o?" during "+o:""))};function s(){for(;!n&&/\\s/.test(r());)o()}function c(){let e="";for(s();!n&&/[-$0-9A-Z_]/i.test(r());)e+=o();return e}function a(e){let t=o();for(t!==e&&i("parsing quoted string");!n&&r()!==e;)"\\\\"===r()&&o(),t+=o();return r()!==e&&i("parsing quoted string"),t+=o(),t}function u(){let e="";return s(),e="\'"===r()||\'"\'===r()?a(r()).slice(1,-1):c(),e||i("parsing property path"),e}function l(){o();const t=[];for(t.push(u()),s();"."===r();)o(),t.push(u()),s();if("]"===r())return o(),{jsonPath:t,op:"<truthy>",value:null,caseSensetive:!1};const c=function(){s();let e="";return n||(e+=o()),n||"="===e||(e+=o()),["=","*=","^=","$=","|=","~="].includes(e)||i("parsing operator"),e}();let l,p=!0;if(s(),"\'"===r()||\'"\'===r())l=a(r()).slice(1,-1),s(),"i"===r()||"I"===r()?(p=!1,o()):"s"!==r()&&"S"!==r()||(p=!0,o());else{for(l="";!n&&!/\\s/.test(r())&&"]"!==r();)l+=o();"true"===l?l=!0:"false"===l?l=!1:(l=+l,isNaN(l)&&i("parsing attribute value"))}if(s(),"]"!==r()&&i("parsing attribute value"),o(),"="!==c&&"string"!=typeof l)throw new Error(`Error while parsing selector \\`${e}\\` - cannot use ${c} in attribute with non-string matching value - ${l}`);return{jsonPath:t,op:c,value:l,caseSensetive:p}}const p={name:"",attributes:[]};for(p.name=c(),s();"["===r();)p.attributes.push(l()),s();if(n||i(void 0),!p.name&&!p.attributes.length)throw new Error(`Error while parsing selector \\`${e}\\` - selector cannot be empty`);return p}},317:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCSS=function(e,t){let n;try{n=r.tokenize(e),n[n.length-1]instanceof r.EOFToken||n.push(new r.EOFToken)}catch(t){const n=t.message+` while parsing selector "${e}"`,r=(t.stack||"").indexOf(t.message);throw-1!==r&&(t.stack=t.stack.substring(0,r)+n+t.stack.substring(r+t.message.length)),t.message=n,t}const o=n.find((e=>e instanceof r.AtKeywordToken||e instanceof r.BadStringToken||e instanceof r.BadURLToken||e instanceof r.ColumnToken||e instanceof r.CDOToken||e instanceof r.CDCToken||e instanceof r.SemicolonToken||e instanceof r.OpenCurlyToken||e instanceof r.CloseCurlyToken||e instanceof r.URLToken||e instanceof r.PercentageToken));if(o)throw new Error(`Unsupported token "${o.toSource()}" while parsing selector "${e}"`);let i=0;const s=new Set;function c(){return new Error(`Unexpected token "${n[i].toSource()}" while parsing selector "${e}"`)}function a(){for(;n[i]instanceof r.WhitespaceToken;)i++}function u(e=i){return n[e]instanceof r.IdentToken}function l(e=i){return n[e]instanceof r.CommaToken}function p(e=i){return n[e]instanceof r.CloseParenToken}function h(e=i){return n[e]instanceof r.DelimToken&&"*"===n[e].value}function f(e=i){return n[e]instanceof r.EOFToken}function d(e=i){return n[e]instanceof r.DelimToken&&[">","+","~"].includes(n[e].value)}function m(e=i){return l(e)||p(e)||f(e)||d(e)||n[e]instanceof r.WhitespaceToken}function g(){const e=[y()];for(;a(),l();)i++,e.push(y());return e}function y(){return a(),function(e=i){return n[e]instanceof r.NumberToken}()||function(e=i){return n[e]instanceof r.StringToken}()?n[i++].value:function(){const e={simples:[]};for(a(),d()?e.simples.push({selector:{functions:[{name:"scope",args:[]}]},combinator:""}):e.simples.push({selector:w(),combinator:""});;){if(a(),d())e.simples[e.simples.length-1].combinator=n[i++].value,a();else if(m())break;e.simples.push({combinator:"",selector:w()})}return e}()}function w(){let e="";const o=[];for(;!m();)if(u()||h())e+=n[i++].toSource();else if(n[i]instanceof r.HashToken)e+=n[i++].toSource();else if(n[i]instanceof r.DelimToken&&"."===n[i].value){if(i++,!u())throw c();e+="."+n[i++].toSource()}else if(n[i]instanceof r.ColonToken)if(i++,u())if(t.has(n[i].value.toLowerCase())){const e=n[i++].value.toLowerCase();o.push({name:e,args:[]}),s.add(e)}else e+=":"+n[i++].toSource();else{if(!(n[i]instanceof r.FunctionToken))throw c();{const r=n[i++].value.toLowerCase();if(t.has(r)?(o.push({name:r,args:g()}),s.add(r)):e+=`:${r}(${v()})`,a(),!p())throw c();i++}}else{if(!(n[i]instanceof r.OpenSquareToken))throw c();for(e+="[",i++;!(n[i]instanceof r.CloseSquareToken||f());)e+=n[i++].toSource();if(!(n[i]instanceof r.CloseSquareToken))throw c();e+="]",i++}if(!e&&!o.length)throw c();return{css:e||void 0,functions:o}}function v(){let e="";for(;!p()&&!f();)e+=n[i++].toSource();return e}const b=g();if(!f())throw new Error(`Error while parsing selector "${e}"`);if(b.some((e=>"object"!=typeof e||!("simples"in e))))throw new Error(`Error while parsing selector "${e}"`);return{selector:b,names:Array.from(s)}},t.serializeSelector=function e(t){return t.map((t=>"string"==typeof t?`"${t}"`:"number"==typeof t?String(t):t.simples.map((({selector:t,combinator:n})=>{let r=t.css||"";return r+=t.functions.map((t=>`:${t.name}(${e(t.args)})`)).join(""),n&&(r+=" "+n),r})).join(" "))).join(", ")};var r=function(e,t){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=o(t);if(n&&n.has(e))return n.get(e);var r={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var c=i?Object.getOwnPropertyDescriptor(e,s):null;c&&(c.get||c.set)?Object.defineProperty(r,s,c):r[s]=e[s]}return r.default=e,n&&n.set(e,r),r}(n(503));function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(o=function(e){return e?n:t})(e)}},503:(e,t)=>{var n,r;n=function(e){var t=function(e,t,n){return e>=t&&e<=n};function n(e){return t(e,48,57)}function r(e){return n(e)||t(e,65,70)||t(e,97,102)}function o(e){return function(e){return t(e,65,90)}(e)||function(e){return t(e,97,122)}(e)}function i(e){return o(e)||function(e){return e>=128}(e)||95==e}function s(e){return i(e)||n(e)||45==e}function c(e){return t(e,0,8)||11==e||t(e,14,31)||127==e}function a(e){return 10==e}function u(e){return a(e)||9==e||32==e}var l=function(e){this.message=e};function p(e){if(e<=65535)return String.fromCharCode(e);e-=Math.pow(2,16);var t=Math.floor(e/Math.pow(2,10))+55296,n=e%Math.pow(2,10)+56320;return String.fromCharCode(t)+String.fromCharCode(n)}function h(){throw"Abstract Base Class"}function f(){return this}function d(){return this}function m(){return this}function g(){return this}function y(){return this}function w(){return this}function v(){return this}function b(){return this}function E(){throw"Abstract Base Class"}function _(){return this.value="{",this.mirror="}",this}function S(){return this.value="}",this.mirror="{",this}function T(){return this.value="[",this.mirror="]",this}function k(){return this.value="]",this.mirror="[",this}function N(){return this.value="(",this.mirror=")",this}function x(){return this.value=")",this.mirror="(",this}function C(){return this}function A(){return this}function O(){return this}function M(){return this}function $(){return this}function R(){return this}function L(){return this}function P(e){return this.value=p(e),this}function j(){throw"Abstract Base Class"}function I(e){this.value=e}function q(e){this.value=e,this.mirror=")"}function D(e){this.value=e}function U(e){this.value=e,this.type="unrestricted"}function W(e){this.value=e}function F(e){this.value=e}function B(){this.value=null,this.type="integer",this.repr=""}function z(){this.value=null,this.repr=""}function H(){this.value=null,this.type="integer",this.repr="",this.unit=""}function V(e){for(var n="",r=(e=""+e).charCodeAt(0),o=0;o<e.length;o++){var i=e.charCodeAt(o);if(0==i)throw new l("Invalid character: the input contains U+0000.");t(i,1,31)||127==i||0==o&&t(i,48,57)||1==o&&t(i,48,57)&&45==r?n+="\\\\"+i.toString(16)+" ":i>=128||45==i||95==i||t(i,48,57)||t(i,65,90)||t(i,97,122)?n+=e[o]:n+="\\\\"+e[o]}return n}function G(e){e=""+e;for(var n="",r=0;r<e.length;r++){var o=e.charCodeAt(r);if(0==o)throw new l("Invalid character: the input contains U+0000.");t(o,1,31)||127==o?n+="\\\\"+o.toString(16)+" ":n+=34==o||92==o?"\\\\"+e[r]:e[r]}return n}(l.prototype=new Error).name="InvalidCharacterError",h.prototype.toJSON=function(){return{token:this.tokenType}},h.prototype.toString=function(){return this.tokenType},h.prototype.toSource=function(){return""+this},f.prototype=Object.create(h.prototype),f.prototype.tokenType="BADSTRING",d.prototype=Object.create(h.prototype),d.prototype.tokenType="BADURL",m.prototype=Object.create(h.prototype),m.prototype.tokenType="WHITESPACE",m.prototype.toString=function(){return"WS"},m.prototype.toSource=function(){return" "},g.prototype=Object.create(h.prototype),g.prototype.tokenType="CDO",g.prototype.toSource=function(){return"\\x3c!--"},y.prototype=Object.create(h.prototype),y.prototype.tokenType="CDC",y.prototype.toSource=function(){return"--\\x3e"},w.prototype=Object.create(h.prototype),w.prototype.tokenType=":",v.prototype=Object.create(h.prototype),v.prototype.tokenType=";",b.prototype=Object.create(h.prototype),b.prototype.tokenType=",",E.prototype=Object.create(h.prototype),_.prototype=Object.create(E.prototype),_.prototype.tokenType="{",S.prototype=Object.create(E.prototype),S.prototype.tokenType="}",T.prototype=Object.create(E.prototype),T.prototype.tokenType="[",k.prototype=Object.create(E.prototype),k.prototype.tokenType="]",N.prototype=Object.create(E.prototype),N.prototype.tokenType="(",x.prototype=Object.create(E.prototype),x.prototype.tokenType=")",C.prototype=Object.create(h.prototype),C.prototype.tokenType="~=",A.prototype=Object.create(h.prototype),A.prototype.tokenType="|=",O.prototype=Object.create(h.prototype),O.prototype.tokenType="^=",M.prototype=Object.create(h.prototype),M.prototype.tokenType="$=",$.prototype=Object.create(h.prototype),$.prototype.tokenType="*=",R.prototype=Object.create(h.prototype),R.prototype.tokenType="||",L.prototype=Object.create(h.prototype),L.prototype.tokenType="EOF",L.prototype.toSource=function(){return""},P.prototype=Object.create(h.prototype),P.prototype.tokenType="DELIM",P.prototype.toString=function(){return"DELIM("+this.value+")"},P.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},P.prototype.toSource=function(){return"\\\\"==this.value?"\\\\\\n":this.value},j.prototype=Object.create(h.prototype),j.prototype.ASCIIMatch=function(e){return this.value.toLowerCase()==e.toLowerCase()},j.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},I.prototype=Object.create(j.prototype),I.prototype.tokenType="IDENT",I.prototype.toString=function(){return"IDENT("+this.value+")"},I.prototype.toSource=function(){return V(this.value)},q.prototype=Object.create(j.prototype),q.prototype.tokenType="FUNCTION",q.prototype.toString=function(){return"FUNCTION("+this.value+")"},q.prototype.toSource=function(){return V(this.value)+"("},D.prototype=Object.create(j.prototype),D.prototype.tokenType="AT-KEYWORD",D.prototype.toString=function(){return"AT("+this.value+")"},D.prototype.toSource=function(){return"@"+V(this.value)},U.prototype=Object.create(j.prototype),U.prototype.tokenType="HASH",U.prototype.toString=function(){return"HASH("+this.value+")"},U.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e},U.prototype.toSource=function(){return"id"==this.type?"#"+V(this.value):"#"+function(e){for(var n="",r=((e=""+e).charCodeAt(0),0);r<e.length;r++){var o=e.charCodeAt(r);if(0==o)throw new l("Invalid character: the input contains U+0000.");o>=128||45==o||95==o||t(o,48,57)||t(o,65,90)||t(o,97,122)?n+=e[r]:n+="\\\\"+o.toString(16)+" "}return n}(this.value)},W.prototype=Object.create(j.prototype),W.prototype.tokenType="STRING",W.prototype.toString=function(){return\'"\'+G(this.value)+\'"\'},F.prototype=Object.create(j.prototype),F.prototype.tokenType="URL",F.prototype.toString=function(){return"URL("+this.value+")"},F.prototype.toSource=function(){return\'url("\'+G(this.value)+\'")\'},B.prototype=Object.create(h.prototype),B.prototype.tokenType="NUMBER",B.prototype.toString=function(){return"integer"==this.type?"INT("+this.value+")":"NUMBER("+this.value+")"},B.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e},B.prototype.toSource=function(){return this.repr},z.prototype=Object.create(h.prototype),z.prototype.tokenType="PERCENTAGE",z.prototype.toString=function(){return"PERCENTAGE("+this.value+")"},z.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.repr=this.repr,e},z.prototype.toSource=function(){return this.repr+"%"},H.prototype=Object.create(h.prototype),H.prototype.tokenType="DIMENSION",H.prototype.toString=function(){return"DIM("+this.value+","+this.unit+")"},H.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e.unit=this.unit,e},H.prototype.toSource=function(){var e=this.repr,n=V(this.unit);return"e"!=n[0].toLowerCase()||"-"!=n[1]&&!t(n.charCodeAt(1),48,57)||(n="\\\\65 "+n.slice(1,n.length)),e+n},e.tokenize=function(e){e=function(e){for(var n=[],r=0;r<e.length;r++){var o=e.charCodeAt(r);if(13==o&&10==e.charCodeAt(r+1)&&(o=10,r++),13!=o&&12!=o||(o=10),0==o&&(o=65533),t(o,55296,56319)&&t(e.charCodeAt(r+1),56320,57343)){var i=o-55296,s=e.charCodeAt(r+1)-56320;o=Math.pow(2,16)+i*Math.pow(2,10)+s,r++}n.push(o)}return n}(e);for(var o,l=-1,h=[],E=0,j=0,V=0,G={line:E,column:j},X=function(t){return t>=e.length?-1:e[t]},J=function(e){if(void 0===e&&(e=1),e>3)throw"Spec Error: no more than three codepoints of lookahead.";return X(l+e)},Q=function(e){return void 0===e&&(e=1),a(o=X(l+=e))?(E+=1,V=j,j=0):j+=e,!0},K=function(){return l-=1,a(o)?(E-=1,j=V):j-=1,G.line=E,G.column=j,!0},Y=function(e){return void 0===e&&(e=o),-1==e},Z=function(){return console.log("Parse error at index "+l+", processing codepoint 0x"+o.toString(16)+"."),!0},ee=function(){if(te(),Q(),u(o)){for(;u(J());)Q();return new m}if(34==o)return oe();if(35==o){if(s(J())||ce(J(1),J(2))){var e=new U;return ue(J(1),J(2),J(3))&&(e.type="id"),e.value=he(),e}return new P(o)}return 36==o?61==J()?(Q(),new M):new P(o):39==o?oe():40==o?new N:41==o?new x:42==o?61==J()?(Q(),new $):new P(o):43==o?pe()?(K(),ne()):new P(o):44==o?new b:45==o?pe()?(K(),ne()):45==J(1)&&62==J(2)?(Q(2),new y):le()?(K(),re()):new P(o):46==o?pe()?(K(),ne()):new P(o):58==o?new w:59==o?new v:60==o?33==J(1)&&45==J(2)&&45==J(3)?(Q(3),new g):new P(o):64==o?ue(J(1),J(2),J(3))?new D(he()):new P(o):91==o?new T:92==o?ae()?(K(),re()):(Z(),new P(o)):93==o?new k:94==o?61==J()?(Q(),new O):new P(o):123==o?new _:124==o?61==J()?(Q(),new A):124==J()?(Q(),new R):new P(o):125==o?new S:126==o?61==J()?(Q(),new C):new P(o):n(o)?(K(),ne()):i(o)?(K(),re()):Y()?new L:new P(o)},te=function(){for(;47==J(1)&&42==J(2);)for(Q(2);;){if(Q(),42==o&&47==J()){Q();break}if(Y())return void Z()}},ne=function(){var e,t=fe();return ue(J(1),J(2),J(3))?((e=new H).value=t.value,e.repr=t.repr,e.type=t.type,e.unit=he(),e):37==J()?(Q(),(e=new z).value=t.value,e.repr=t.repr,e):((e=new B).value=t.value,e.repr=t.repr,e.type=t.type,e)},re=function(){var e=he();if("url"==e.toLowerCase()&&40==J()){for(Q();u(J(1))&&u(J(2));)Q();return 34==J()||39==J()?new q(e):!u(J())||34!=J(2)&&39!=J(2)?ie():new q(e)}return 40==J()?(Q(),new q(e)):new I(e)},oe=function(e){void 0===e&&(e=o);for(var t="";Q();){if(o==e||Y())return new W(t);if(a(o))return Z(),K(),new f;92==o?Y(J())||(a(J())?Q():t+=p(se())):t+=p(o)}},ie=function(){for(var e=new F("");u(J());)Q();if(Y(J()))return e;for(;Q();){if(41==o||Y())return e;if(u(o)){for(;u(J());)Q();return 41==J()||Y(J())?(Q(),e):(me(),new d)}if(34==o||39==o||40==o||c(o))return Z(),me(),new d;if(92==o){if(!ae())return Z(),me(),new d;e.value+=p(se())}else e.value+=p(o)}},se=function(){if(Q(),r(o)){for(var e=[o],t=0;t<5&&r(J());t++)Q(),e.push(o);u(J())&&Q();var n=parseInt(e.map((function(e){return String.fromCharCode(e)})).join(""),16);return n>1114111&&(n=65533),n}return Y()?65533:o},ce=function(e,t){return 92==e&&!a(t)},ae=function(){return ce(o,J())},ue=function(e,t,n){return 45==e?i(t)||45==t||ce(t,n):!!i(e)||92==e&&ce(e,t)},le=function(){return ue(o,J(1),J(2))},pe=function(){return e=o,t=J(1),r=J(2),43==e||45==e?!!n(t)||!(46!=t||!n(r)):46==e?!!n(t):!!n(e);var e,t,r},he=function(){for(var e="";Q();)if(s(o))e+=p(o);else{if(!ae())return K(),e;e+=p(se())}},fe=function(){var e=[],t="integer";for(43!=J()&&45!=J()||(Q(),e+=p(o));n(J());)Q(),e+=p(o);if(46==J(1)&&n(J(2)))for(Q(),e+=p(o),Q(),e+=p(o),t="number";n(J());)Q(),e+=p(o);var r=J(1),i=J(2),s=J(3);if(69!=r&&101!=r||!n(i)){if((69==r||101==r)&&(43==i||45==i)&&n(s))for(Q(),e+=p(o),Q(),e+=p(o),Q(),e+=p(o),t="number";n(J());)Q(),e+=p(o)}else for(Q(),e+=p(o),Q(),e+=p(o),t="number";n(J());)Q(),e+=p(o);return{type:t,value:de(e),repr:e}},de=function(e){return+e},me=function(){for(;Q();){if(41==o||Y())return;ae()&&se()}},ge=0;!Y(J());)if(h.push(ee()),++ge>2*e.length)return"I\'m infinite-looping!";return h},e.IdentToken=I,e.FunctionToken=q,e.AtKeywordToken=D,e.HashToken=U,e.StringToken=W,e.BadStringToken=f,e.URLToken=F,e.BadURLToken=d,e.DelimToken=P,e.NumberToken=B,e.PercentageToken=z,e.DimensionToken=H,e.IncludeMatchToken=C,e.DashMatchToken=A,e.PrefixMatchToken=O,e.SuffixMatchToken=M,e.SubstringMatchToken=$,e.ColumnToken=R,e.WhitespaceToken=m,e.CDOToken=g,e.CDCToken=y,e.ColonToken=w,e.SemicolonToken=v,e.CommaToken=b,e.OpenParenToken=N,e.CloseParenToken=x,e.OpenSquareToken=T,e.CloseSquareToken=k,e.OpenCurlyToken=_,e.CloseCurlyToken=S,e.EOFToken=L,e.CSSParserToken=h,e.GroupingToken=E},void 0===(r=n.apply(t,[t]))||(e.exports=r)},461:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSelector=i,t.splitSelectorByFrame=function(e){const t=i(e),n=[];let r={parts:[]},o=0;for(let e=0;e<t.parts.length;++e){const i=t.parts[e];if("control"!==i.name||"enter-frame"!==i.body)t.capture===e&&(r.capture=e-o),r.parts.push(i);else{if(!r.parts.length)throw new Error("Selector cannot start with entering frame, select the iframe first");n.push(r),r={parts:[]},o=e+1}}if(!r.parts.length)throw new Error(`Selector cannot end with entering frame, while parsing selector ${e}`);if(n.push(r),"number"==typeof t.capture&&"number"!=typeof n[n.length-1].capture)throw new Error("Can not capture the selector before diving into the frame. Only use * after the last frame has been selected");return n},t.stringifySelector=function(e){return"string"==typeof e?e:e.parts.map(((t,n)=>{const r="css"===t.name?"":t.name+"=";return`${n===e.capture?"*":""}${r}${t.source}`})).join(" >> ")},t.customCSSNames=void 0;var r=n(317);const o=new Set(["not","is","where","has","scope","light","visible","text","text-matches","text-is","has-text","above","below","right-of","left-of","near","nth-match"]);function i(e){const t=function(e){let t,n=0,r=0;const o={parts:[]},i=()=>{const t=e.substring(r,n).trim(),i=t.indexOf("=");let s,c;-1!==i&&t.substring(0,i).trim().match(/^[a-zA-Z_0-9-+:*]+$/)?(s=t.substring(0,i).trim(),c=t.substring(i+1)):t.length>1&&\'"\'===t[0]&&\'"\'===t[t.length-1]||t.length>1&&"\'"===t[0]&&"\'"===t[t.length-1]?(s="text",c=t):/^\\(*\\/\\//.test(t)||t.startsWith("..")?(s="xpath",c=t):(s="css",c=t);let a=!1;if("*"===s[0]&&(a=!0,s=s.substring(1)),o.parts.push({name:s,body:c}),a){if(void 0!==o.capture)throw new Error("Only one of the selectors can capture using * modifier");o.capture=o.parts.length-1}};if(!e.includes(">>"))return n=e.length,i(),o;for(;n<e.length;){const o=e[n];"\\\\"===o&&n+1<e.length?n+=2:o===t?(t=void 0,n++):t||\'"\'!==o&&"\'"!==o&&"`"!==o?t||">"!==o||">"!==e[n+1]?n++:(i(),n+=2,r=n):(t=o,n++)}return i(),o}(e),n=t.parts.map((e=>"css"===e.name||"css:light"===e.name?("css:light"===e.name&&(e.body=":light("+e.body+")"),{name:"css",body:(0,r.parseCSS)(e.body,o).selector,source:e.body}):{...e,source:e.body}));return{capture:t.capture,parts:n}}t.customCSSNames=o},836:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ReactEngine=void 0;var r=n(204);function o(e){if("function"==typeof e.type)return e.type.displayName||e.type.name||"Anonymous";if("string"==typeof e.type)return e.type;if(e._currentElement){const t=e._currentElement.type;if("string"==typeof t)return t;if("function"==typeof t)return t.displayName||t.name||"Anonymous"}return""}function i(e){if(e.child){const t=[];for(let n=e.child;n;n=n.sibling)t.push(n);return t}if(!e._currentElement)return[];const t=e=>{var t;const n=null===(t=e._currentElement)||void 0===t?void 0:t.type;return"function"==typeof n||"string"==typeof n};if(e._renderedComponent){const n=e._renderedComponent;return t(n)?[n]:[]}return e._renderedChildren?[...Object.values(e._renderedChildren)].filter(t):[]}function s(e){var t;const n=e.memoizedProps||(null===(t=e._currentElement)||void 0===t?void 0:t.props);if(!n||"string"==typeof n)return n;const r={...n};return delete r.children,r}function c(e){var t;const n={name:o(e),children:i(e).map(c),rootElements:[],props:s(e)},r=e.stateNode||e._hostNode||(null===(t=e._renderedComponent)||void 0===t?void 0:t._hostNode);if(r instanceof Element)n.rootElements.push(r);else for(const e of n.children)n.rootElements.push(...e.rootElements);return n}function a(e,t,n=[]){t(e)&&n.push(e);for(const r of e.children)a(r,t,n);return n}const u={queryAll(e,t){const{name:n,attributes:o}=(0,r.parseComponentSelector)(t),i=function(){const e=[],t=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT);for(;t.nextNode();){const n=t.currentNode;n.hasOwnProperty("_reactRootContainer")&&e.push(n._reactRootContainer._internalRoot.current)}for(const t of document.querySelectorAll("[data-reactroot]"))for(const n of Object.keys(t))(n.startsWith("__reactInternalInstance")||n.startsWith("__reactFiber"))&&e.push(t[n]);return e}().map((e=>c(e))).map((t=>a(t,(t=>{if(n&&t.name!==n)return!1;if(t.rootElements.some((t=>!e.contains(t))))return!1;for(const e of o)if(!(0,r.checkComponentAttribute)(t.props,e))return!1;return!0})))).flat(),s=new Set;for(const e of i)for(const t of e.rootElements)s.add(t);return[...s]}};t.ReactEngine=u},848:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createLaxTextMatcher=d,t.createStrictTextMatcher=m,t.createRegexTextMatcher=g,t.elementText=w,t.elementMatchesText=v,t.parentElementOrShadowHost=x,t.isVisible=O,t.SelectorEvaluatorImpl=void 0;var r=n(461);t.SelectorEvaluatorImpl=class{constructor(e){this._engines=new Map,this._cacheQueryCSS=new Map,this._cacheMatches=new Map,this._cacheQuery=new Map,this._cacheMatchesSimple=new Map,this._cacheMatchesParents=new Map,this._cacheCallMatches=new Map,this._cacheCallQuery=new Map,this._cacheQuerySimple=new Map,this._cacheText=new Map,this._scoreMap=void 0,this._retainCacheCounter=0;for(const[t,n]of e)this._engines.set(t,n);this._engines.set("not",c),this._engines.set("is",o),this._engines.set("where",o),this._engines.set("has",i),this._engines.set("scope",s),this._engines.set("light",a),this._engines.set("visible",u),this._engines.set("text",l),this._engines.set("text-is",p),this._engines.set("text-matches",h),this._engines.set("has-text",f),this._engines.set("right-of",k("right-of",b)),this._engines.set("left-of",k("left-of",E)),this._engines.set("above",k("above",_)),this._engines.set("below",k("below",S)),this._engines.set("near",k("near",T)),this._engines.set("nth-match",N);const t=[...this._engines.keys()];t.sort();const n=[...r.customCSSNames];if(n.sort(),t.join("|")!==n.join("|"))throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${t.join("|")} vs ${n.join("|")}`)}begin(){++this._retainCacheCounter}end(){--this._retainCacheCounter,this._retainCacheCounter||(this._cacheQueryCSS.clear(),this._cacheMatches.clear(),this._cacheQuery.clear(),this._cacheMatchesSimple.clear(),this._cacheMatchesParents.clear(),this._cacheCallMatches.clear(),this._cacheCallQuery.clear(),this._cacheQuerySimple.clear(),this._cacheText.clear())}_cached(e,t,n,r){e.has(t)||e.set(t,[]);const o=e.get(t),i=o.find((e=>n.every(((t,n)=>e.rest[n]===t))));if(i)return i.result;const s=r();return o.push({rest:n,result:s}),s}_checkSelector(e){if("object"!=typeof e||!e||!(Array.isArray(e)||"simples"in e&&e.simples.length))throw new Error(`Malformed selector "${e}"`);return e}matches(e,t,n){const r=this._checkSelector(t);this.begin();try{return this._cached(this._cacheMatches,e,[r,n.scope,n.pierceShadow],(()=>Array.isArray(r)?this._matchesEngine(o,e,r,n):!!this._matchesSimple(e,r.simples[r.simples.length-1].selector,n)&&this._matchesParents(e,r,r.simples.length-2,n)))}finally{this.end()}}query(e,t){const n=this._checkSelector(t);this.begin();try{return this._cached(this._cacheQuery,n,[e.scope,e.pierceShadow],(()=>{if(Array.isArray(n))return this._queryEngine(o,e,n);const t=this._scoreMap;this._scoreMap=new Map;let r=this._querySimple(e,n.simples[n.simples.length-1].selector);return r=r.filter((t=>this._matchesParents(t,n,n.simples.length-2,e))),this._scoreMap.size&&r.sort(((e,t)=>{const n=this._scoreMap.get(e),r=this._scoreMap.get(t);return n===r?0:void 0===n?1:void 0===r?-1:n-r})),this._scoreMap=t,r}))}finally{this.end()}}_markScore(e,t){this._scoreMap&&this._scoreMap.set(e,t)}_matchesSimple(e,t,n){return this._cached(this._cacheMatchesSimple,e,[t,n.scope,n.pierceShadow],(()=>{if(!t.functions.some((e=>"scope"===e.name||"is"===e.name))&&e===n.scope)return!1;if(t.css&&!this._matchesCSS(e,t.css))return!1;for(const r of t.functions)if(!this._matchesEngine(this._getEngine(r.name),e,r.args,n))return!1;return!0}))}_querySimple(e,t){return t.functions.length?this._cached(this._cacheQuerySimple,t,[e.scope,e.pierceShadow],(()=>{let n=t.css;const r=t.functions;let o;"*"===n&&r.length&&(n=void 0);let i=-1;void 0!==n?o=this._queryCSS(e,n):(i=r.findIndex((e=>void 0!==this._getEngine(e.name).query)),-1===i&&(i=0),o=this._queryEngine(this._getEngine(r[i].name),e,r[i].args));for(let t=0;t<r.length;t++){if(t===i)continue;const n=this._getEngine(r[t].name);void 0!==n.matches&&(o=o.filter((o=>this._matchesEngine(n,o,r[t].args,e))))}for(let t=0;t<r.length;t++){if(t===i)continue;const n=this._getEngine(r[t].name);void 0===n.matches&&(o=o.filter((o=>this._matchesEngine(n,o,r[t].args,e))))}return o})):this._queryCSS(e,t.css||"*")}_matchesParents(e,t,n,r){return n<0||this._cached(this._cacheMatchesParents,e,[t,n,r.scope,r.pierceShadow],(()=>{const{selector:o,combinator:i}=t.simples[n];if(">"===i){const i=C(e,r);return!(!i||!this._matchesSimple(i,o,r))&&this._matchesParents(i,t,n-1,r)}if("+"===i){const i=A(e,r);return!(!i||!this._matchesSimple(i,o,r))&&this._matchesParents(i,t,n-1,r)}if(""===i){let i=C(e,r);for(;i;){if(this._matchesSimple(i,o,r)){if(this._matchesParents(i,t,n-1,r))return!0;if(""===t.simples[n-1].combinator)break}i=C(i,r)}return!1}if("~"===i){let i=A(e,r);for(;i;){if(this._matchesSimple(i,o,r)){if(this._matchesParents(i,t,n-1,r))return!0;if("~"===t.simples[n-1].combinator)break}i=A(i,r)}return!1}if(">="===i){let i=e;for(;i;){if(this._matchesSimple(i,o,r)){if(this._matchesParents(i,t,n-1,r))return!0;if(""===t.simples[n-1].combinator)break}i=C(i,r)}return!1}throw new Error(`Unsupported combinator "${i}"`)}))}_matchesEngine(e,t,n,r){if(e.matches)return this._callMatches(e,t,n,r);if(e.query)return this._callQuery(e,n,r).includes(t);throw new Error(\'Selector engine should implement "matches" or "query"\')}_queryEngine(e,t,n){if(e.query)return this._callQuery(e,n,t);if(e.matches)return this._queryCSS(t,"*").filter((r=>this._callMatches(e,r,n,t)));throw new Error(\'Selector engine should implement "matches" or "query"\')}_callMatches(e,t,n,r){return this._cached(this._cacheCallMatches,t,[e,r.scope,r.pierceShadow,...n],(()=>e.matches(t,n,r,this)))}_callQuery(e,t,n){return this._cached(this._cacheCallQuery,e,[n.scope,n.pierceShadow,...t],(()=>e.query(n,t,this)))}_matchesCSS(e,t){return e.matches(t)}_queryCSS(e,t){return this._cached(this._cacheQueryCSS,t,[e.scope,e.pierceShadow],(()=>{let n=[];return function r(o){if(n=n.concat([...o.querySelectorAll(t)]),e.pierceShadow){o.shadowRoot&&r(o.shadowRoot);for(const e of o.querySelectorAll("*"))e.shadowRoot&&r(e.shadowRoot)}}(e.scope),n}))}_getEngine(e){const t=this._engines.get(e);if(!t)throw new Error(`Unknown selector engine "${e}"`);return t}};const o={matches(e,t,n,r){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');return t.some((t=>r.matches(e,t,n)))},query(e,t,n){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');let r=[];for(const o of t)r=r.concat(n.query(e,o));return 1===t.length?r:function(e){const t=new Map,n=[],r=[];function o(e){let r=t.get(e);if(r)return r;const i=x(e);return i?o(i).children.push(e):n.push(e),r={children:[],taken:!1},t.set(e,r),r}return e.forEach((e=>o(e).taken=!0)),n.forEach((function e(n){const o=t.get(n);if(o.taken&&r.push(n),o.children.length>1){const e=new Set(o.children);o.children=[];let t=n.firstElementChild;for(;t&&o.children.length<e.size;)e.has(t)&&o.children.push(t),t=t.nextElementSibling;for(t=n.shadowRoot?n.shadowRoot.firstElementChild:null;t&&o.children.length<e.size;)e.has(t)&&o.children.push(t),t=t.nextElementSibling}o.children.forEach(e)})),r}(r)}},i={matches(e,t,n,r){if(0===t.length)throw new Error(\'"has" engine expects non-empty selector list\');return r.query({...n,scope:e},t).length>0}},s={matches(e,t,n,r){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');return 9===n.scope.nodeType?e===n.scope.documentElement:e===n.scope},query(e,t,n){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');if(9===e.scope.nodeType){const t=e.scope.documentElement;return t?[t]:[]}return 1===e.scope.nodeType?[e.scope]:[]}},c={matches(e,t,n,r){if(0===t.length)throw new Error(\'"not" engine expects non-empty selector list\');return!r.matches(e,t,n)}},a={query:(e,t,n)=>n.query({...e,pierceShadow:!1},t),matches:(e,t,n,r)=>r.matches(e,t,{...n,pierceShadow:!1})},u={matches(e,t,n,r){if(t.length)throw new Error(\'"visible" engine expects no arguments\');return O(e)}},l={matches(e,t,n,r){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text" engine expects a single string\');return"self"===v(r,e,d(t[0]))}},p={matches(e,t,n,r){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text-is" engine expects a single string\');return"none"!==v(r,e,m(t[0]))}},h={matches(e,t,n,r){if(0===t.length||"string"!=typeof t[0]||t.length>2||2===t.length&&"string"!=typeof t[1])throw new Error(\'"text-matches" engine expects a regexp body and optional regexp flags\');return"self"===v(r,e,g(t[0],2===t.length?t[1]:void 0))}},f={matches(e,t,n,r){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"has-text" engine expects a single string\');return!y(e)&&d(t[0])(w(r,e))}};function d(e){return e=e.trim().replace(/\\s+/g," ").toLowerCase(),t=>t.full.trim().replace(/\\s+/g," ").toLowerCase().includes(e)}function m(e){return e=e.trim().replace(/\\s+/g," "),t=>!e&&!t.immediate.length||t.immediate.some((t=>t.trim().replace(/\\s+/g," ")===e))}function g(e,t){const n=new RegExp(e,t);return e=>n.test(e.full)}function y(e){return"SCRIPT"===e.nodeName||"STYLE"===e.nodeName||document.head&&document.head.contains(e)}function w(e,t){let n=e._cacheText.get(t);if(void 0===n){if(n={full:"",immediate:[]},!y(t)){let r="";if(t instanceof HTMLInputElement&&("submit"===t.type||"button"===t.type))n={full:t.value,immediate:[t.value]};else{for(let o=t.firstChild;o;o=o.nextSibling)o.nodeType===Node.TEXT_NODE?(n.full+=o.nodeValue||"",r+=o.nodeValue||""):(r&&n.immediate.push(r),r="",o.nodeType===Node.ELEMENT_NODE&&(n.full+=w(e,o).full));r&&n.immediate.push(r),t.shadowRoot&&(n.full+=w(e,t.shadowRoot).full)}}e._cacheText.set(t,n)}return n}function v(e,t,n){if(y(t))return"none";if(!n(w(e,t)))return"none";for(let r=t.firstChild;r;r=r.nextSibling)if(r.nodeType===Node.ELEMENT_NODE&&n(w(e,r)))return"selfAndChildren";return t.shadowRoot&&n(w(e,t.shadowRoot))?"selfAndChildren":"self"}function b(e,t,n){const r=e.left-t.right;if(!(r<0||void 0!==n&&r>n))return r+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function E(e,t,n){const r=t.left-e.right;if(!(r<0||void 0!==n&&r>n))return r+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function _(e,t,n){const r=t.top-e.bottom;if(!(r<0||void 0!==n&&r>n))return r+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function S(e,t,n){const r=e.top-t.bottom;if(!(r<0||void 0!==n&&r>n))return r+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function T(e,t,n){const r=void 0===n?50:n;let o=0;return e.left-t.right>=0&&(o+=e.left-t.right),t.left-e.right>=0&&(o+=t.left-e.right),t.top-e.bottom>=0&&(o+=t.top-e.bottom),e.top-t.bottom>=0&&(o+=e.top-t.bottom),o>r?void 0:o}function k(e,t){return{matches(n,r,o,i){const s=r.length&&"number"==typeof r[r.length-1]?r[r.length-1]:void 0,c=void 0===s?r:r.slice(0,r.length-1);if(r.length<1+(void 0===s?0:1))throw new Error(`"${e}" engine expects a selector list and optional maximum distance in pixels`);const a=n.getBoundingClientRect();let u;for(const e of i.query(o,c)){if(e===n)continue;const r=t(a,e.getBoundingClientRect(),s);void 0!==r&&(void 0===u||r<u)&&(u=r)}return void 0!==u&&(i._markScore(n,u),!0)}}}const N={query(e,t,n){let r=t[t.length-1];if(t.length<2)throw new Error(\'"nth-match" engine expects non-empty selector list and an index argument\');if("number"!=typeof r||r<1)throw new Error(\'"nth-match" engine expects a one-based index as the last argument\');const i=o.query(e,t.slice(0,t.length-1),n);return r--,r<i.length?[i[r]]:[]}};function x(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:void 0}function C(e,t){if(e!==t.scope)return t.pierceShadow?x(e):e.parentElement||void 0}function A(e,t){if(e!==t.scope)return e.previousElementSibling||void 0}function O(e){if(!e.ownerDocument||!e.ownerDocument.defaultView)return!0;const t=e.ownerDocument.defaultView.getComputedStyle(e);if(!t||"hidden"===t.visibility)return!1;const n=e.getBoundingClientRect();return n.width>0&&n.height>0}},854:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.querySelector=function(e,t,n){try{const r=e.parseSelector(t);return{selector:t,elements:e.querySelectorAll(r,n)}}catch(e){return{selector:t,elements:[]}}},t.generateSelector=function(e,t){e._evaluator.begin();try{const n=function(e,t){if(t.ownerDocument.documentElement===t)return[{engine:"css",selector:"html",score:1}];const n=(u,p)=>{const d=p?o:i;let m=d.get(u);return void 0===m&&(m=((o,i)=>{const u=o===t;let p=i?function(e,t,n){if("SELECT"===t.nodeName)return[];const o=(0,r.elementText)(e._evaluator,t).full.trim().replace(/\\s+/g," ").substring(0,80);if(!o)return[];const i=[];let s=o;if((o.includes(\'"\')||o.includes(">>")||"/"===o[0])&&(s=`/.*${function(e){return e.replace(/[.*+?^>${}()|[\\]\\\\]/g,"\\\\$&")}(o)}.*/`),i.push({engine:"text",selector:s,score:10}),n&&s===o){let e=t.nodeName.toLocaleLowerCase();t.hasAttribute("role")&&(e+=`[role=${l(t.getAttribute("role"))}]`),i.push({engine:"css",selector:`${e}:has-text("${o}")`,score:30})}return i}(e,o,o===t).map((e=>[e])):[];o!==t&&(p=s(p));const d=function(e,t){const n=[];for(const e of["data-testid","data-test-id","data-test"])t.hasAttribute(e)&&n.push({engine:"css",selector:`[${e}=${l(t.getAttribute(e))}]`,score:1});if("INPUT"===t.nodeName){const e=t;e.placeholder&&n.push({engine:"css",selector:`[placeholder=${l(e.placeholder)}]`,score:10})}t.hasAttribute("aria-label")&&n.push({engine:"css",selector:`[aria-label=${l(t.getAttribute("aria-label"))}]`,score:10}),t.getAttribute("alt")&&["APPLET","AREA","IMG","INPUT"].includes(t.nodeName)&&n.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[alt=${l(t.getAttribute("alt"))}]`,score:10}),t.hasAttribute("role")&&n.push({engine:"css",selector:`${t.nodeName.toLocaleLowerCase()}[role=${l(t.getAttribute("role"))}]`,score:50}),t.getAttribute("name")&&["BUTTON","FORM","FIELDSET","IFRAME","INPUT","KEYGEN","OBJECT","OUTPUT","SELECT","TEXTAREA","MAP","META","PARAM"].includes(t.nodeName)&&n.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[name=${l(t.getAttribute("name"))}]`,score:50}),["INPUT","TEXTAREA"].includes(t.nodeName)&&"hidden"!==t.getAttribute("type")&&t.getAttribute("type")&&n.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[type=${l(t.getAttribute("type"))}]`,score:50}),["INPUT","TEXTAREA","SELECT"].includes(t.nodeName)&&n.push({engine:"css",selector:t.nodeName.toLowerCase(),score:50});const r=t.getAttribute("id");return r&&!function(e){let t,n=0;for(let r=0;r<e.length;++r){const o=e[r];let i;"-"!==o&&"_"!==o&&(i=o>="a"&&o<="z"?"lower":o>="A"&&o<="Z"?"upper":o>="0"&&o<="9"?"digit":"other","lower"!==i||"upper"!==t?(t&&t!==i&&++n,t=i):t=i)}return n>=e.length/4}(r)&&n.push({engine:"css",selector:a(r),score:100}),n.push({engine:"css",selector:t.nodeName.toLocaleLowerCase(),score:200}),n}(0,o).map((e=>[e]));let m=f(e,t.ownerDocument,o,[...p,...d],u);p=s(p);const g=t=>{const r=i&&!t.length,s=[...t,...d].filter((e=>!m||h(e)<h(m)));let a=s[0];if(a)for(let t=c(o);t;t=c(t)){const i=n(t,r);if(!i)continue;if(m&&h([...i,...a])>=h(m))continue;if(a=f(e,t,o,s,u),!a)return;const c=[...i,...a];(!m||h(c)<h(m))&&(m=c)}};return g(p),o===t&&p.length&&g([]),m})(u,p),d.set(u,m)),m};return n(t,!0)}(e,t=t.closest("button,select,input,[role=button],[role=checkbox],[role=radio]")||t),d=p(n||[u(e,t)]),m=e.parseSelector(d);return{selector:d,elements:e.querySelectorAll(m,t.ownerDocument)}}finally{o.clear(),i.clear(),e._evaluator.end()}};var r=n(848);const o=new Map,i=new Map;function s(e){return e.filter((e=>"/"!==e[0].selector[0]))}function c(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:null}function a(e){return/^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(e)?"#"+e:`[id="${e}"]`}function u(e,t){const n=1e7,r=t.ownerDocument,o=[];function i(n){const r=o.slice();n&&r.unshift(n);const i=r.join(" "),s=e.parseSelector(i);return e.querySelector(s,t.ownerDocument,!1)===t?i:void 0}for(let e=t;e&&e!==r;e=c(e)){const t=e.nodeName.toLowerCase();let r="";if(e.id){const t=a(e.id),o=i(t);if(o)return{engine:"css",selector:o,score:n};r=t}const s=e.parentNode,c=[...e.classList];for(let e=0;e<c.length;++e){const t="."+c.slice(0,e+1).join("."),o=i(t);if(o)return{engine:"css",selector:o,score:n};!r&&s&&1===s.querySelectorAll(t).length&&(r=t)}if(s){const o=[...s.children],c=0===o.filter((e=>e.nodeName.toLowerCase()===t)).indexOf(e)?t:`${t}:nth-child(${1+o.indexOf(e)})`,a=i(c);if(a)return{engine:"css",selector:a,score:n};r||(r=c)}else r||(r=t);o.unshift(r)}return{engine:"css",selector:i(),score:n}}function l(e){return`"${e.replace(/"/g,\'\\\\"\').replace(/\\n/g,"\\\\n")}"`}function p(e){const t=[];let n="";for(const{engine:r,selector:o}of e)t.length&&("css"!==n||"css"!==r||o.startsWith(":nth-match("))&&t.push(">>"),n=r,"css"===r?t.push(o):t.push(`${r}=${o}`);return t.join(" ")}function h(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n].score*(e.length-n);return t}function f(e,t,n,r,o){const i=r.map((e=>({tokens:e,score:h(e)})));i.sort(((e,t)=>e.score-t.score));let s=null;for(const{tokens:r}of i){const i=e.parseSelector(p(r)),c=e.querySelectorAll(i,t),a=c.indexOf(n);if(0===a)return r;if(!o||s||-1===a||c.length>5)continue;const u=r.map((e=>"text"!==e.engine?e:e.selector.startsWith("/")&&e.selector.endsWith("/")?{engine:"css",selector:`:text-matches("${e.selector.substring(1,e.selector.length-1)}")`,score:e.score}:{engine:"css",selector:`:text("${e.selector}")`,score:e.score}));s=[{engine:"css",selector:`:nth-match(${p(u)}, ${a+1})`,score:h(u)+1e3}]}return s}},12:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.VueEngine=void 0;var r=n(204);function o(e,t){const n=e.replace(/^[a-zA-Z]:/,"").replace(/\\\\/g,"/");let r=n.substring(n.lastIndexOf("/")+1);return t&&r.endsWith(t)&&(r=r.substring(0,r.length-t.length)),r}function i(e,t){return t?t.toUpperCase():""}const s=/(?:^|[-_/])(\\w)/g,c=e=>e&&e.replace(s,i);function a(e,t,n=[]){t(e)&&n.push(e);for(const r of e.children)a(r,t,n);return n}const u={queryAll(e,t){const{name:n,attributes:i}=(0,r.parseComponentSelector)(t),s=function(){const e=[];for(const t of document.querySelectorAll("[data-v-app]"))t._vnode&&t._vnode.component&&e.push({root:t._vnode.component,version:3});const t=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT),n=new Set;for(;t.nextNode();){const e=t.currentNode;e&&e.__vue__&&n.add(e.__vue__.$root)}for(const t of n)e.push({version:2,root:t});return e}().map((e=>3===e.version?function(e){function t(e,t){return e.type.__playwright_guessedName=t,t}function n(e){const n=function(e){const t=e.name||e._componentTag||e.__playwright_guessedName;if(t)return t;const n=e.__file;return n?c(o(n,".vue")):void 0}(e.type||{});if(n)return n;if(e.root===e)return"Root";for(const n in null===(r=e.parent)||void 0===r||null===(i=r.type)||void 0===i?void 0:i.components){var r,i,s;if((null===(s=e.parent)||void 0===s?void 0:s.type.components[n])===e.type)return t(e,n)}for(const n in null===(a=e.appContext)||void 0===a?void 0:a.components){var a;if(e.appContext.components[n]===e.type)return t(e,n)}return"Anonymous Component"}function r(e){const t=[];return e.component&&t.push(e.component),e.suspense&&t.push(...r(e.suspense.activeBranch)),Array.isArray(e.children)&&e.children.forEach((e=>{e.component?t.push(e.component):t.push(...r(e))})),t.filter((e=>{var t;return!(function(e){return e._isBeingDestroyed||e.isUnmounted}(e)||null!==(t=e.type.devtools)&&void 0!==t&&t.hide)}))}function i(e){return function(e){return"Symbol(Fragment)"===e.subTree.type.toString()}(e)?function(e){if(!e.children)return[];const t=[];for(let n=0,r=e.children.length;n<r;n++){const r=e.children[n];r.component?t.push(...i(r.component)):r.el&&t.push(r.el)}return t}(e.subTree):[e.subTree.el]}return function e(t){return{name:n(t),children:r(t.subTree).map(e),rootElements:i(t),props:t.props}}(e)}(e.root):function(e){function t(e){return function(e){const t=e.displayName||e.name||e._componentTag;if(t)return t;const n=e.__file;return n?c(o(n,".vue")):void 0}(e.$options||e.fnOptions||{})||(e.$root===e?"Root":"Anonymous Component")}function n(e){return e.$children?e.$children:Array.isArray(e.subTree.children)?e.subTree.children.filter((e=>!!e.component)).map((e=>e.component)):[]}return function e(r){return{name:t(r),children:n(r).map(e),rootElements:[r.$el],props:r._props}}(e)}(e.root))).map((t=>a(t,(t=>{if(n&&t.name!==n)return!1;if(t.rootElements.some((t=>!e.contains(t))))return!1;for(const e of i)if(!(0,r.checkComponentAttribute)(t.props,e))return!1;return!0})))).flat(),u=new Set;for(const e of s)for(const t of e.rootElements)u.add(t);return[...u]}};t.VueEngine=u},530:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.XPathEngine=void 0;const n={queryAll(e,t){t.startsWith("/")&&(t="."+t);const n=[],r=e instanceof Document?e:e.ownerDocument;if(!r)return n;const o=r.evaluate(t,e,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE);for(let e=o.iterateNext();e;e=o.iterateNext())e.nodeType===Node.ELEMENT_NODE&&n.push(e);return n}};t.XPathEngine=n}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}();var r={};(()=>{var e=r;e.default=void 0;var t=n(530),o=n(836),i=n(12),s=n(461),c=n(848),a=n(854);const u=new Set(["AREA","BASE","BR","COL","COMMAND","EMBED","HR","IMG","INPUT","KEYGEN","LINK","MENUITEM","META","PARAM","SOURCE","TRACK","WBR"]),l=new Set(["checked","selected","disabled","readonly","multiple"]);function p(e){return e.replace(/\\n/g,"\u21B5").replace(/\\t/g,"\u21C6")}const h=new Map([["auxclick","mouse"],["click","mouse"],["dblclick","mouse"],["mousedown","mouse"],["mouseeenter","mouse"],["mouseleave","mouse"],["mousemove","mouse"],["mouseout","mouse"],["mouseover","mouse"],["mouseup","mouse"],["mouseleave","mouse"],["mousewheel","mouse"],["keydown","keyboard"],["keyup","keyboard"],["keypress","keyboard"],["textInput","keyboard"],["touchstart","touch"],["touchmove","touch"],["touchend","touch"],["touchcancel","touch"],["pointerover","pointer"],["pointerout","pointer"],["pointerenter","pointer"],["pointerleave","pointer"],["pointerdown","pointer"],["pointerup","pointer"],["pointermove","pointer"],["pointercancel","pointer"],["gotpointercapture","pointer"],["lostpointercapture","pointer"],["focus","focus"],["blur","focus"],["drag","drag"],["dragstart","drag"],["dragend","drag"],["dragover","drag"],["dragenter","drag"],["dragleave","drag"],["dragexit","drag"],["drop","drag"]]),f=new Set(["mousemove"]),d=new Set(["pointerdown","pointerup","touchstart","touchend","touchcancel"]),m=new Set(["mousedown","mouseup","pointerdown","pointerup","click","auxclick","dblclick","contextmenu"]),g=new Set([...f,...d,...m]);function y(e){if(!e.includes("\\\\"))return e;const t=[];let n=0;for(;n<e.length;)"\\\\"===e[n]&&n+1<e.length&&n++,t.push(e[n++]);return t.join("")}class w{constructor(e){this._string=void 0,this._substring=void 0,this._regex=void 0,this._normalizeWhiteSpace=void 0,this._normalizeWhiteSpace=e.normalizeWhiteSpace,this._string=e.matchSubstring?void 0:this.normalizeWhiteSpace(e.string),this._substring=e.matchSubstring?this.normalizeWhiteSpace(e.string):void 0,this._regex=e.regexSource?new RegExp(e.regexSource,e.regexFlags):void 0}matches(e){return this._normalizeWhiteSpace&&!this._regex&&(e=this.normalizeWhiteSpace(e)),void 0!==this._string?e===this._string:void 0!==this._substring?e.includes(this._substring):!!this._regex&&!!this._regex.test(e)}normalizeWhiteSpace(e){return e&&this._normalizeWhiteSpace?e.trim().replace(/\\u200b/g,"").replace(/\\s+/g," "):e}}function v(e,t){if(e===t)return!0;if(e&&t&&"object"==typeof e&&"object"==typeof t){if(e.constructor!==t.constructor)return!1;if(Array.isArray(e)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!v(e[n],t[n]))return!1;return!0}if(e instanceof RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();const n=Object.keys(e);if(n.length!==Object.keys(t).length)return!1;for(let e=0;e<n.length;++e)if(!t.hasOwnProperty(n[e]))return!1;for(const r of n)if(!v(e[r],t[r]))return!1;return!0}return"number"==typeof e&&"number"==typeof t&&isNaN(e)&&isNaN(t)}var b=class{constructor(e,n,r){this._engines=void 0,this._evaluator=void 0,this._stableRafCount=void 0,this._browserName=void 0,this.onGlobalListenersRemoved=new Set,this._hitTargetInterceptor=void 0,this._evaluator=new c.SelectorEvaluatorImpl(new Map),this._engines=new Map,this._engines.set("xpath",t.XPathEngine),this._engines.set("xpath:light",t.XPathEngine),this._engines.set("_react",o.ReactEngine),this._engines.set("_vue",i.VueEngine),this._engines.set("text",this._createTextEngine(!0)),this._engines.set("text:light",this._createTextEngine(!1)),this._engines.set("id",this._createAttributeEngine("id",!0)),this._engines.set("id:light",this._createAttributeEngine("id",!1)),this._engines.set("data-testid",this._createAttributeEngine("data-testid",!0)),this._engines.set("data-testid:light",this._createAttributeEngine("data-testid",!1)),this._engines.set("data-test-id",this._createAttributeEngine("data-test-id",!0)),this._engines.set("data-test-id:light",this._createAttributeEngine("data-test-id",!1)),this._engines.set("data-test",this._createAttributeEngine("data-test",!0)),this._engines.set("data-test:light",this._createAttributeEngine("data-test",!1)),this._engines.set("css",this._createCSSEngine()),this._engines.set("nth",{queryAll:()=>[]}),this._engines.set("visible",{queryAll:()=>[]}),this._engines.set("control",this._createControlEngine());for(const{name:e,engine:t}of r)this._engines.set(e,t);this._stableRafCount=e,this._browserName=n,this._setupGlobalListenersRemovalDetection(),this._setupHitTargetInterceptors()}eval(e){return n.g.eval(e)}parseSelector(e){const t=(0,s.parseSelector)(e);for(const n of t.parts)if(!this._engines.has(n.name))throw this.createStacklessError(`Unknown engine "${n.name}" while parsing selector ${e}`);return t}querySelector(e,t,n){if(!t.querySelector)throw this.createStacklessError("Node is not queryable.");this._evaluator.begin();try{var r,o;const i=this._querySelectorRecursively([{element:t,capture:void 0}],e,0,new Map);if(n&&i.length>1)throw this.strictModeViolationError(e,i.map((e=>e.element)));return(null===(r=i[0])||void 0===r?void 0:r.capture)||(null===(o=i[0])||void 0===o?void 0:o.element)}finally{this._evaluator.end()}}_querySelectorRecursively(e,t,n,r){if(n===t.parts.length)return e;const o=t.parts[n];if("nth"===o.name){let i=[];if("0"===o.body)i=e.slice(0,1);else if("-1"===o.body)e.length&&(i=e.slice(e.length-1));else{if("number"==typeof t.capture)throw this.createStacklessError("Can\'t query n-th element in a request with the capture.");const n=+o.body,r=new Set;for(const t of e)r.add(t.element),n+1===r.size&&(i=[t])}return this._querySelectorRecursively(i,t,n+1,r)}if("visible"===o.name){const i=Boolean(o.body),s=e.filter((e=>i===(0,c.isVisible)(e.element)));return this._querySelectorRecursively(s,t,n+1,r)}const i=[];for(const o of e){const e=n-1===t.capture?o.element:o.capture;let s=r.get(o.element);s||(s=[],r.set(o.element,s));let c=s[n];c||(c=this._queryEngineAll(t.parts[n],o.element),s[n]=c);for(const t of c){if(!("nodeName"in t))throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(t)}`);i.push({element:t,capture:e})}}return this._querySelectorRecursively(i,t,n+1,r)}querySelectorAll(e,t){if(!t.querySelectorAll)throw this.createStacklessError("Node is not queryable.");this._evaluator.begin();try{const n=this._querySelectorRecursively([{element:t,capture:void 0}],e,0,new Map),r=new Set;for(const e of n)r.add(e.capture||e.element);return[...r]}finally{this._evaluator.end()}}_queryEngineAll(e,t){return this._engines.get(e.name).queryAll(t,e.body)}_createAttributeEngine(e,t){return{queryAll:(n,r)=>this._evaluator.query({scope:n,pierceShadow:t},(t=>[{simples:[{selector:{css:`[${e}=${JSON.stringify(t)}]`,functions:[]},combinator:""}]}])(r))}}_createCSSEngine(){const e=this._evaluator;return{queryAll:(t,n)=>e.query({scope:t,pierceShadow:!0},n)}}_createTextEngine(e){const t=(t,n)=>{const{matcher:r,kind:o}=function(e){if("/"===e[0]&&e.lastIndexOf("/")>0){const t=e.lastIndexOf("/");return{matcher:(0,c.createRegexTextMatcher)(e.substring(1,t),e.substring(t+1)),kind:"regex"}}let t=!1;return e.length>1&&\'"\'===e[0]&&\'"\'===e[e.length-1]&&(e=y(e.substring(1,e.length-1)),t=!0),e.length>1&&"\'"===e[0]&&"\'"===e[e.length-1]&&(e=y(e.substring(1,e.length-1)),t=!0),{matcher:t?(0,c.createStrictTextMatcher)(e):(0,c.createLaxTextMatcher)(e),kind:t?"strict":"lax"}}(n),i=[];let s=null;const a=e=>{if("lax"===o&&s&&s.contains(e))return!1;const t=(0,c.elementMatchesText)(this._evaluator,e,r);"none"===t&&(s=e),("self"===t||"selfAndChildren"===t&&"strict"===o)&&i.push(e)};t.nodeType===Node.ELEMENT_NODE&&a(t);const u=this._evaluator._queryCSS({scope:t,pierceShadow:e},"*");for(const e of u)a(e);return i};return{queryAll:(e,n)=>t(e,n)}}_createControlEngine(){return{queryAll(e,t){if("enter-frame"===t)return[];if("return-empty"===t)return[];throw new Error(`Internal error, unknown control selector ${t}`)}}}extend(e,t){return new(n.g.eval(`\\n    (() => {\\n      ${e}\\n      return pwExport;\\n    })()`))(this,t)}isVisible(e){return(0,c.isVisible)(e)}pollRaf(e){return this.poll(e,(e=>requestAnimationFrame(e)))}pollInterval(e,t){return this.poll(t,(t=>setTimeout(t,e)))}pollLogScale(e){const t=[100,250,500];let n=0;return this.poll(e,(e=>setTimeout(e,t[n++]||1e3)))}poll(e,t){return this._runAbortableTask((n=>{let r,o;const i=new Promise(((e,t)=>{r=e,o=t})),s=()=>{if(!n.aborted)try{const o=e(n);o!==n.continuePolling?r(o):t(s)}catch(e){n.log("  "+e.message),o(e)}};return s(),i}))}_runAbortableTask(e){let t,n=[],r=!1;const o=()=>{t&&(t(n),n=[],t=void 0)};let i,s="";const c={injectedScript:this,aborted:!1,continuePolling:Symbol("continuePolling"),log:e=>{s=e,n.push({message:e}),o()},logRepeating:e=>{e!==s&&c.log(e)},setIntermediateResult:e=>{i!==e&&(i=e,n.push({intermediateResult:e}),o())}};return{takeNextLogs:()=>new Promise((e=>{t=e,(n.length||r)&&o()})),run:()=>{const t=e(c);return t.finally((()=>{r=!0,o()})),t},cancel:()=>{c.aborted=!0},takeLastLogs:()=>n}}getElementBorderWidth(e){if(e.nodeType!==Node.ELEMENT_NODE||!e.ownerDocument||!e.ownerDocument.defaultView)return{left:0,top:0};const t=e.ownerDocument.defaultView.getComputedStyle(e);return{left:parseInt(t.borderLeftWidth||"",10),top:parseInt(t.borderTopWidth||"",10)}}retarget(e,t){let n=e.nodeType===Node.ELEMENT_NODE?e:e.parentElement;return n?(n.matches("input, textarea, select")||(n=n.closest("button, [role=button], [role=checkbox], [role=radio]")||n),"follow-label"===t&&(n.matches("input, textarea, button, select, [role=button], [role=checkbox], [role=radio]")||n.isContentEditable||(n=n.closest("label")||n),"LABEL"===n.nodeName&&(n=n.control||n)),n):null}waitForElementStatesAndPerformAction(e,t,n,r){let o,i=0,s=0,c=0;return this.pollRaf((a=>{if(n)return a.log("    forcing action"),r(e,a);for(const n of t){if("stable"!==n){const t=this.elementState(e,n);if("boolean"!=typeof t)return t;if(!t)return a.logRepeating(`    element is not ${n} - waiting...`),a.continuePolling;continue}const t=this.retarget(e,"no-follow-label");if(!t)return"error:notconnected";if(1==++i)return a.continuePolling;const r=performance.now();if(this._stableRafCount>1&&r-c<15)return a.continuePolling;c=r;const u=t.getBoundingClientRect(),l={x:u.top,y:u.left,width:u.width,height:u.height};o&&l.x===o.x&&l.y===o.y&&l.width===o.width&&l.height===o.height?++s:s=0;const p=s>=this._stableRafCount,h=p||!o;if(o=l,h||a.logRepeating("    element is not stable - waiting..."),!p)return a.continuePolling}return r(e,a)}))}elementState(e,t){const n=this.retarget(e,["stable","visible","hidden"].includes(t)?"no-follow-label":"follow-label");if(!n||!n.isConnected)return"hidden"===t||"error:notconnected";if("visible"===t)return this.isVisible(n);if("hidden"===t)return!this.isVisible(n);const r=["BUTTON","INPUT","SELECT","TEXTAREA"].includes(n.nodeName)&&n.hasAttribute("disabled");if("disabled"===t)return r;if("enabled"===t)return!r;const o=!(["INPUT","TEXTAREA","SELECT"].includes(n.nodeName)&&n.hasAttribute("readonly"));if("editable"===t)return!r&&o;if("checked"===t){if(["checkbox","radio"].includes(n.getAttribute("role")||""))return"true"===n.getAttribute("aria-checked");if("INPUT"!==n.nodeName)throw this.createStacklessError("Not a checkbox or radio button");if(!["radio","checkbox"].includes(n.type.toLowerCase()))throw this.createStacklessError("Not a checkbox or radio button");return n.checked}throw this.createStacklessError(`Unexpected element state "${t}"`)}selectOptions(e,t,n){const r=this.retarget(t,"follow-label");if(!r)return"error:notconnected";if("select"!==r.nodeName.toLowerCase())throw this.createStacklessError("Element is not a <select> element");const o=r,i=[...o.options],s=[];let c=e.slice();for(let e=0;e<i.length;e++){const t=i[e],n=n=>{if(n instanceof Node)return t===n;let r=!0;return void 0!==n.value&&(r=r&&n.value===t.value),void 0!==n.label&&(r=r&&n.label===t.label),void 0!==n.index&&(r=r&&n.index===e),r};if(c.some(n)){if(s.push(t),!o.multiple){c=[];break}c=c.filter((e=>!n(e)))}}return c.length?(n.logRepeating("    did not find some options - waiting... "),n.continuePolling):(o.value=void 0,s.forEach((e=>e.selected=!0)),n.log("    selected specified option(s)"),o.dispatchEvent(new Event("input",{bubbles:!0})),o.dispatchEvent(new Event("change",{bubbles:!0})),s.map((e=>e.value)))}fill(e,t,n){const r=this.retarget(t,"follow-label");if(!r)return"error:notconnected";if("input"===r.nodeName.toLowerCase()){const t=r,o=t.type.toLowerCase(),i=new Set(["date","time","datetime","datetime-local","month","week"]);if(!new Set(["","email","number","password","search","tel","text","url"]).has(o)&&!i.has(o))throw n.log(`    input of type "${o}" cannot be filled`),this.createStacklessError(`Input of type "${o}" cannot be filled`);if("number"===o&&(e=e.trim(),isNaN(Number(e))))throw this.createStacklessError("Cannot type text into input[type=number]");if(i.has(o)){if(e=e.trim(),t.focus(),t.value=e,t.value!==e)throw this.createStacklessError("Malformed value");return r.dispatchEvent(new Event("input",{bubbles:!0})),r.dispatchEvent(new Event("change",{bubbles:!0})),"done"}}else if("textarea"===r.nodeName.toLowerCase());else if(!r.isContentEditable)throw this.createStacklessError("Element is not an <input>, <textarea> or [contenteditable] element");return this.selectText(r),"needsinput"}selectText(e){const t=this.retarget(e,"follow-label");if(!t)return"error:notconnected";if("input"===t.nodeName.toLowerCase()){const e=t;return e.select(),e.focus(),"done"}if("textarea"===t.nodeName.toLowerCase()){const e=t;return e.selectionStart=0,e.selectionEnd=e.value.length,e.focus(),"done"}const n=t.ownerDocument.createRange();n.selectNodeContents(t);const r=t.ownerDocument.defaultView.getSelection();return r&&(r.removeAllRanges(),r.addRange(n)),t.focus(),"done"}focusNode(e,t){if(!e.isConnected)return"error:notconnected";if(e.nodeType!==Node.ELEMENT_NODE)throw this.createStacklessError("Node is not an element");const n=e.getRootNode().activeElement===e&&e.ownerDocument&&e.ownerDocument.hasFocus();if(e.focus(),t&&!n&&"input"===e.nodeName.toLowerCase())try{e.setSelectionRange(0,0)}catch(e){}return"done"}setInputFiles(e,t){if(e.nodeType!==Node.ELEMENT_NODE)return"Node is not of type HTMLElement";const n=e;if("INPUT"!==n.nodeName)return"Not an <input> element";const r=n;if("file"!==(r.getAttribute("type")||"").toLowerCase())return"Not an input[type=file] element";const o=t.map((e=>{const t=Uint8Array.from(atob(e.buffer),(e=>e.charCodeAt(0)));return new File([t],e.name,{type:e.mimeType})})),i=new DataTransfer;for(const e of o)i.items.add(e);r.files=i.files,r.dispatchEvent(new Event("input",{bubbles:!0})),r.dispatchEvent(new Event("change",{bubbles:!0}))}checkHitTargetAt(e,t){let n=e.nodeType===Node.ELEMENT_NODE?e:e.parentElement;if(!n||!n.isConnected)return"error:notconnected";n=n.closest("button, [role=button]")||n;const r=this.deepElementFromPoint(document,t.x,t.y);return this._expectHitTargetParent(r,n)}_expectHitTargetParent(e,t){const n=[];for(;e&&e!==t;)n.push(e),e=(0,c.parentElementOrShadowHost)(e);if(e===t)return"done";const r=this.previewNode(n[0]||document.documentElement);let o,i=t;for(;i;){const e=n.indexOf(i);if(-1!==e){e>1&&(o=this.previewNode(n[e-1]));break}i=(0,c.parentElementOrShadowHost)(i)}return o?{hitTargetDescription:`${r} from ${o} subtree`}:{hitTargetDescription:r}}setupHitTargetInterceptor(e,t,n){const r=e.nodeType===Node.ELEMENT_NODE?e:e.parentElement;if(!r||!r.isConnected)return"error:notconnected";const o=r.closest("button, [role=button]")||r,i={hover:f,tap:d,mouse:m}[t];let s;const c=e=>{if(!i.has(e.type))return;if(!e.isTrusted)return;if(!o.isConnected)return;const t=window.TouchEvent&&e instanceof window.TouchEvent?e.touches[0]:e;if(t&&(void 0===s||"done"===s)){const e=this.deepElementFromPoint(document,t.clientX,t.clientY);s=this._expectHitTargetParent(e,o)}(n||"done"!==s)&&(e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation())};return this._hitTargetInterceptor=c,{stop:()=>(this._hitTargetInterceptor===c&&(this._hitTargetInterceptor=void 0),s||"done")}}dispatchEvent(e,t,n){let r;switch(n={bubbles:!0,cancelable:!0,composed:!0,...n},h.get(t)){case"mouse":r=new MouseEvent(t,n);break;case"keyboard":r=new KeyboardEvent(t,n);break;case"touch":r=new TouchEvent(t,n);break;case"pointer":r=new PointerEvent(t,n);break;case"focus":r=new FocusEvent(t,n);break;case"drag":r=new DragEvent(t,n);break;default:r=new Event(t,n)}e.dispatchEvent(r)}deepElementFromPoint(e,t,n){let r,o=e;for(;o;){const e=o.elementsFromPoint(t,n)[0];if(!e||r===e)break;r=e,o=r.shadowRoot}return r}previewNode(e){if(e.nodeType===Node.TEXT_NODE)return p(`#text=${e.nodeValue||""}`);if(e.nodeType!==Node.ELEMENT_NODE)return p(`<${e.nodeName.toLowerCase()} />`);const t=e,n=[];for(let e=0;e<t.attributes.length;e++){const{name:r,value:o}=t.attributes[e];"style"===r||r.startsWith("__playwright")||(!o&&l.has(r)?n.push(` ${r}`):n.push(` ${r}="${o}"`))}n.sort(((e,t)=>e.length-t.length));let r=n.join("");if(r.length>50&&(r=r.substring(0,49)+"\u2026"),u.has(t.nodeName))return p(`<${t.nodeName.toLowerCase()}${r}/>`);const o=t.childNodes;let i=!1;if(o.length<=5){i=!0;for(let e=0;e<o.length;e++)i=i&&o[e].nodeType===Node.TEXT_NODE}let s=i?t.textContent||"":o.length?"\u2026":"";return s.length>50&&(s=s.substring(0,49)+"\u2026"),p(`<${t.nodeName.toLowerCase()}${r}>${s}</${t.nodeName.toLowerCase()}>`)}strictModeViolationError(e,t){const n=t.slice(0,10).map((e=>({preview:this.previewNode(e),selector:(0,a.generateSelector)(this,e).selector}))),r=n.map(((e,t)=>`\\n    ${t+1}) ${e.preview} aka playwright.$("${e.selector}")`));return n.length<t.length&&r.push("\\n    ..."),this.createStacklessError(`strict mode violation: "${(0,s.stringifySelector)(e)}" resolved to ${t.length} elements:${r.join("")}\\n`)}createStacklessError(e){if("firefox"===this._browserName){const t=new Error("Error: "+e);return t.stack="",t}const t=new Error(e);return delete t.stack,t}_setupGlobalListenersRemovalDetection(){const e="__playwright_global_listeners_check__";let t=!1;const n=()=>t=!0;window.addEventListener(e,n),new MutationObserver((r=>{if(r.some((e=>Array.from(e.addedNodes).includes(document.documentElement)))&&(t=!1,window.dispatchEvent(new CustomEvent(e)),!t)){window.addEventListener(e,n);for(const e of this.onGlobalListenersRemoved)e()}})).observe(document,{childList:!0})}_setupHitTargetInterceptors(){const e=e=>{var t;return null===(t=this._hitTargetInterceptor)||void 0===t?void 0:t.call(this,e)},t=()=>{for(const t of g)window.addEventListener(t,e,{capture:!0,passive:!1})};t(),this.onGlobalListenersRemoved.add(t)}expectSingleElement(e,t,n){const r=e.injectedScript,o=n.expression;{let n;if("to.be.checked"===o)n=e.injectedScript.elementState(t,"checked");else if("to.be.disabled"===o)n=e.injectedScript.elementState(t,"disabled");else if("to.be.editable"===o)n=e.injectedScript.elementState(t,"editable");else if("to.be.empty"===o){var i;n="INPUT"===t.nodeName||"TEXTAREA"===t.nodeName?!t.value:!(null!==(i=t.textContent)&&void 0!==i&&i.trim())}else"to.be.enabled"===o?n=e.injectedScript.elementState(t,"enabled"):"to.be.focused"===o?n=document.activeElement===t:"to.be.hidden"===o?n=e.injectedScript.elementState(t,"hidden"):"to.be.visible"===o&&(n=e.injectedScript.elementState(t,"visible"));if(void 0!==n){if("error:notcheckbox"===n)throw r.createStacklessError("Element is not a checkbox");if("error:notconnected"===n)throw r.createStacklessError("Element is not connected");return{received:n,matches:n}}}if("to.have.property"===o){const e=t[n.expressionArg];return{received:e,matches:v(e,n.expectedValue)}}{let e;if("to.have.attribute"===o)e=t.getAttribute(n.expressionArg)||"";else if("to.have.class"===o)e=t.className;else if("to.have.css"===o)e=window.getComputedStyle(t)[n.expressionArg];else if("to.have.id"===o)e=t.id;else if("to.have.text"===o)e=n.useInnerText?t.innerText:t.textContent||"";else if("to.have.title"===o)e=document.title;else if("to.have.url"===o)e=document.location.href;else if("to.have.value"===o){if("INPUT"!==t.nodeName&&"TEXTAREA"!==t.nodeName&&"SELECT"!==t.nodeName)throw this.createStacklessError("Not an input element");e=t.value}if(void 0!==e&&n.expectedText)return{received:e,matches:new w(n.expectedText[0]).matches(e)}}throw this.createStacklessError("Unknown expect matcher: "+o)}expectArray(e,t){const n=t.expression;if("to.have.count"===n){const n=e.length;return{received:n,matches:n===t.expectedNumber}}let r;if("to.have.text.array"===n||"to.contain.text.array"===n?r=e.map((e=>t.useInnerText?e.innerText:e.textContent||"")):"to.have.class.array"===n&&(r=e.map((e=>e.className))),r&&t.expectedText){const e="to.contain.text.array"!==n;if(r.length!==t.expectedText.length&&e)return{received:r,matches:!1};let o=0;const i=t.expectedText.map((e=>new w(e)));let s=!0;for(const e of i){for(;o<r.length&&!e.matches(r[o]);)o++;if(o>=r.length){s=!1;break}}return{received:r,matches:s}}throw this.createStacklessError("Unknown expect matcher: "+n)}};e.default=b})(),pwExport=r.default})();';
    exports.source = source;
  }
});

// node_modules/playwright-core/lib/server/common/protocolError.js
var require_protocolError = __commonJS({
  "node_modules/playwright-core/lib/server/common/protocolError.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSessionClosedError = isSessionClosedError;
    exports.ProtocolError = void 0;
    var ProtocolError = class extends Error {
      constructor(sessionClosed, message) {
        super(message);
        this.sessionClosed = void 0;
        this.sessionClosed = sessionClosed || false;
      }
    };
    exports.ProtocolError = ProtocolError;
    function isSessionClosedError(e) {
      return e instanceof ProtocolError && e.sessionClosed;
    }
  }
});

// node_modules/playwright-core/lib/generated/utilityScriptSource.js
var require_utilityScriptSource = __commonJS({
  "node_modules/playwright-core/lib/generated/utilityScriptSource.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.source = void 0;
    var source = 'var pwExport;(()=>{"use strict";var t={645:(t,e,r)=>{function n(t,e,o){const i=e(t);if(!("fallThrough"in i))return i;if(t=i.fallThrough,o.has(t))throw new Error("Argument is a circular structure");if("symbol"==typeof t)return{v:"undefined"};if(Object.is(t,void 0))return{v:"undefined"};if(Object.is(t,null))return{v:"null"};if(Object.is(t,NaN))return{v:"NaN"};if(Object.is(t,1/0))return{v:"Infinity"};if(Object.is(t,-1/0))return{v:"-Infinity"};if(Object.is(t,-0))return{v:"-0"};if("boolean"==typeof t)return t;if("number"==typeof t)return t;if("string"==typeof t)return t;if((u=t)instanceof Error||u&&u.__proto__&&"Error"===u.__proto__.name){const e=t;return"captureStackTrace"in r.g.Error?e.stack||"":`${e.name}: ${e.message}\\n${e.stack}`}var u;if(function(t){return t instanceof Date||"[object Date]"===Object.prototype.toString.call(t)}(t))return{d:t.toJSON()};if(function(t){return t instanceof RegExp||"[object RegExp]"===Object.prototype.toString.call(t)}(t))return{r:{p:t.source,f:t.flags}};if(Array.isArray(t)){const r=[];o.add(t);for(let i=0;i<t.length;++i)r.push(n(t[i],e,o));return o.delete(t),{a:r}}if("object"==typeof t){const r=[];o.add(t);for(const i of Object.keys(t)){let u;try{u=t[i]}catch(t){continue}"toJSON"===i&&"function"==typeof u?r.push({k:i,v:{o:[]}}):r.push({k:i,v:n(u,e,o)})}return o.delete(t),{o:r}}}Object.defineProperty(e,"__esModule",{value:!0}),e.parseEvaluationResultValue=function t(e,r=[]){if(!Object.is(e,void 0)){if("object"==typeof e&&e){if("v"in e){if("undefined"===e.v)return;return"null"===e.v?null:"NaN"===e.v?NaN:"Infinity"===e.v?1/0:"-Infinity"===e.v?-1/0:"-0"===e.v?-0:void 0}if("d"in e)return new Date(e.d);if("r"in e)return new RegExp(e.r.p,e.r.f);if("a"in e)return e.a.map((e=>t(e,r)));if("o"in e){const n={};for(const{k:o,v:i}of e.o)n[o]=t(i,r);return n}if("h"in e)return r[e.h]}return e}},e.serializeAsCallArgument=function(t,e){return n(t,e,new Set)}}},e={};function r(n){var o=e[n];if(void 0!==o)return o.exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}();var n={};(()=>{var t=n;t.default=void 0;var e=r(645);t.default=class{evaluate(t,n,o,i,...u){const a=u.slice(0,i),f=u.slice(i),s=a.map((t=>(0,e.parseEvaluationResultValue)(t,f)));let c=r.g.eval(o);return!0===t?c=c(...s):!1===t?c=c:"function"==typeof c&&(c=c(...s)),n?this._promiseAwareJsonValueNoThrow(c):c}jsonValue(t,r){if(!Object.is(r,void 0))return(0,e.serializeAsCallArgument)(r,(t=>({fallThrough:t})))}_promiseAwareJsonValueNoThrow(t){const e=t=>{try{return this.jsonValue(!0,t)}catch(t){return}};return t&&"object"==typeof t&&"function"==typeof t.then?(async()=>{const r=await t;return e(r)})():e(t)}}})(),pwExport=n.default})();';
    exports.source = source;
  }
});

// node_modules/playwright-core/lib/server/common/utilityScriptSerializers.js
var require_utilityScriptSerializers = __commonJS({
  "node_modules/playwright-core/lib/server/common/utilityScriptSerializers.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseEvaluationResultValue = parseEvaluationResultValue;
    exports.serializeAsCallArgument = serializeAsCallArgument;
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isError(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
    function parseEvaluationResultValue(value, handles = []) {
      if (Object.is(value, void 0))
        return void 0;
      if (typeof value === "object" && value) {
        if ("v" in value) {
          if (value.v === "undefined")
            return void 0;
          if (value.v === "null")
            return null;
          if (value.v === "NaN")
            return NaN;
          if (value.v === "Infinity")
            return Infinity;
          if (value.v === "-Infinity")
            return -Infinity;
          if (value.v === "-0")
            return -0;
          return void 0;
        }
        if ("d" in value)
          return new Date(value.d);
        if ("r" in value)
          return new RegExp(value.r.p, value.r.f);
        if ("a" in value)
          return value.a.map((a) => parseEvaluationResultValue(a, handles));
        if ("o" in value) {
          const result = {};
          for (const {
            k,
            v
          } of value.o)
            result[k] = parseEvaluationResultValue(v, handles);
          return result;
        }
        if ("h" in value)
          return handles[value.h];
      }
      return value;
    }
    function serializeAsCallArgument(value, handleSerializer) {
      return serialize(value, handleSerializer, new Set());
    }
    function serialize(value, handleSerializer, visited) {
      const result = handleSerializer(value);
      if ("fallThrough" in result)
        value = result.fallThrough;
      else
        return result;
      if (visited.has(value))
        throw new Error("Argument is a circular structure");
      if (typeof value === "symbol")
        return {
          v: "undefined"
        };
      if (Object.is(value, void 0))
        return {
          v: "undefined"
        };
      if (Object.is(value, null))
        return {
          v: "null"
        };
      if (Object.is(value, NaN))
        return {
          v: "NaN"
        };
      if (Object.is(value, Infinity))
        return {
          v: "Infinity"
        };
      if (Object.is(value, -Infinity))
        return {
          v: "-Infinity"
        };
      if (Object.is(value, -0))
        return {
          v: "-0"
        };
      if (typeof value === "boolean")
        return value;
      if (typeof value === "number")
        return value;
      if (typeof value === "string")
        return value;
      if (isError(value)) {
        const error2 = value;
        if ("captureStackTrace" in global.Error) {
          return error2.stack || "";
        }
        return `${error2.name}: ${error2.message}
${error2.stack}`;
      }
      if (isDate(value))
        return {
          d: value.toJSON()
        };
      if (isRegExp(value))
        return {
          r: {
            p: value.source,
            f: value.flags
          }
        };
      if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
          a.push(serialize(value[i], handleSerializer, visited));
        visited.delete(value);
        return {
          a
        };
      }
      if (typeof value === "object") {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value)) {
          let item;
          try {
            item = value[name];
          } catch (e) {
            continue;
          }
          if (name === "toJSON" && typeof item === "function")
            o.push({
              k: name,
              v: {
                o: []
              }
            });
          else
            o.push({
              k: name,
              v: serialize(item, handleSerializer, visited)
            });
        }
        visited.delete(value);
        return {
          o
        };
      }
    }
  }
});

// node_modules/playwright-core/lib/server/javascript.js
var require_javascript = __commonJS({
  "node_modules/playwright-core/lib/server/javascript.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.evaluate = evaluate;
    exports.evaluateExpression = evaluateExpression;
    exports.evaluateExpressionAndWaitForSignals = evaluateExpressionAndWaitForSignals;
    exports.parseUnserializableValue = parseUnserializableValue;
    exports.normalizeEvaluationExpression = normalizeEvaluationExpression;
    exports.isJavaScriptErrorInEvaluate = isJavaScriptErrorInEvaluate;
    exports.JavaScriptErrorInEvaluate = exports.JSHandle = exports.ExecutionContext = void 0;
    var utilityScriptSource = _interopRequireWildcard(require_utilityScriptSource());
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _instrumentation = require_instrumentation();
    var _async = require_async();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var ExecutionContext = class extends _instrumentation.SdkObject {
      constructor(parent, delegate) {
        super(parent, "execution-context");
        this._delegate = void 0;
        this._utilityScriptPromise = void 0;
        this._destroyedPromise = new _async.ManualPromise();
        this._delegate = delegate;
      }
      contextDestroyed(error2) {
        this._destroyedPromise.resolve(error2);
      }
      _raceAgainstContextDestroyed(promise) {
        return Promise.race([this._destroyedPromise.then((e) => {
          throw e;
        }), promise]);
      }
      rawEvaluateJSON(expression) {
        return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateJSON(expression));
      }
      rawEvaluateHandle(expression) {
        return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(expression));
      }
      rawCallFunctionNoReply(func, ...args) {
        this._delegate.rawCallFunctionNoReply(func, ...args);
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return this._raceAgainstContextDestroyed(this._delegate.evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds));
      }
      getProperties(context, objectId) {
        return this._raceAgainstContextDestroyed(this._delegate.getProperties(context, objectId));
      }
      createHandle(remoteObject) {
        return this._delegate.createHandle(this, remoteObject);
      }
      releaseHandle(objectId) {
        return this._delegate.releaseHandle(objectId);
      }
      async waitForSignalsCreatedBy(action) {
        return action();
      }
      adoptIfNeeded(handle) {
        return null;
      }
      utilityScript() {
        if (!this._utilityScriptPromise) {
          const source = `
      (() => {
        ${utilityScriptSource.source}
        return new pwExport();
      })();`;
          this._utilityScriptPromise = this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(source).then((objectId) => new JSHandle(this, "object", void 0, objectId)));
        }
        return this._utilityScriptPromise;
      }
      async doSlowMo() {
      }
    };
    exports.ExecutionContext = ExecutionContext;
    var JSHandle = class extends _instrumentation.SdkObject {
      constructor(context, type, preview, objectId, value) {
        super(context, "handle");
        this._context = void 0;
        this._disposed = false;
        this._objectId = void 0;
        this._value = void 0;
        this._objectType = void 0;
        this._preview = void 0;
        this._previewCallback = void 0;
        this._context = context;
        this._objectId = objectId;
        this._value = value;
        this._objectType = type;
        this._preview = this._objectId ? preview || `JSHandle@${this._objectType}` : String(value);
      }
      callFunctionNoReply(func, arg) {
        this._context.rawCallFunctionNoReply(func, this, arg);
      }
      async evaluate(pageFunction, arg) {
        return evaluate(this._context, true, pageFunction, this, arg);
      }
      async evaluateHandle(pageFunction, arg) {
        return evaluate(this._context, false, pageFunction, this, arg);
      }
      async evaluateExpressionAndWaitForSignals(expression, isFunction, returnByValue, arg) {
        const value = await evaluateExpressionAndWaitForSignals(this._context, returnByValue, expression, isFunction, this, arg);
        await this._context.doSlowMo();
        return value;
      }
      async getProperty(propertyName) {
        const objectHandle = await this.evaluateHandle((object, propertyName2) => {
          const result2 = {
            __proto__: null
          };
          result2[propertyName2] = object[propertyName2];
          return result2;
        }, propertyName);
        const properties = await objectHandle.getProperties();
        const result = properties.get(propertyName);
        objectHandle.dispose();
        return result;
      }
      async getProperties() {
        if (!this._objectId)
          return new Map();
        return this._context.getProperties(this._context, this._objectId);
      }
      rawValue() {
        return this._value;
      }
      async jsonValue() {
        if (!this._objectId)
          return this._value;
        const utilityScript = await this._context.utilityScript();
        const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
        return this._context.evaluateWithArguments(script, true, utilityScript, [true], [this._objectId]);
      }
      asElement() {
        return null;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        if (this._objectId)
          this._context.releaseHandle(this._objectId).catch((e) => {
          });
      }
      toString() {
        return this._preview;
      }
      _setPreviewCallback(callback) {
        this._previewCallback = callback;
      }
      preview() {
        return this._preview;
      }
      _setPreview(preview) {
        this._preview = preview;
        if (this._previewCallback)
          this._previewCallback(preview);
      }
    };
    exports.JSHandle = JSHandle;
    async function evaluate(context, returnByValue, pageFunction, ...args) {
      return evaluateExpression(context, returnByValue, String(pageFunction), typeof pageFunction === "function", ...args);
    }
    async function evaluateExpression(context, returnByValue, expression, isFunction, ...args) {
      const utilityScript = await context.utilityScript();
      expression = normalizeEvaluationExpression(expression, isFunction);
      const handles = [];
      const toDispose = [];
      const pushHandle = (handle) => {
        handles.push(handle);
        return handles.length - 1;
      };
      args = args.map((arg) => (0, _utilityScriptSerializers.serializeAsCallArgument)(arg, (handle) => {
        if (handle instanceof JSHandle) {
          if (!handle._objectId)
            return {
              fallThrough: handle._value
            };
          if (handle._disposed)
            throw new Error("JSHandle is disposed!");
          const adopted = context.adoptIfNeeded(handle);
          if (adopted === null)
            return {
              h: pushHandle(Promise.resolve(handle))
            };
          toDispose.push(adopted);
          return {
            h: pushHandle(adopted)
          };
        }
        return {
          fallThrough: handle
        };
      }));
      const utilityScriptObjectIds = [];
      for (const handle of await Promise.all(handles)) {
        if (handle._context !== context)
          throw new Error("JSHandles can be evaluated only in the context they were created!");
        utilityScriptObjectIds.push(handle._objectId);
      }
      const utilityScriptValues = [isFunction, returnByValue, expression, args.length, ...args];
      const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;
      try {
        return await context.evaluateWithArguments(script, returnByValue, utilityScript, utilityScriptValues, utilityScriptObjectIds);
      } finally {
        toDispose.map((handlePromise) => handlePromise.then((handle) => handle.dispose()));
      }
    }
    async function evaluateExpressionAndWaitForSignals(context, returnByValue, expression, isFunction, ...args) {
      return await context.waitForSignalsCreatedBy(() => evaluateExpression(context, returnByValue, expression, isFunction, ...args));
    }
    function parseUnserializableValue(unserializableValue) {
      if (unserializableValue === "NaN")
        return NaN;
      if (unserializableValue === "Infinity")
        return Infinity;
      if (unserializableValue === "-Infinity")
        return -Infinity;
      if (unserializableValue === "-0")
        return -0;
    }
    function normalizeEvaluationExpression(expression, isFunction) {
      expression = expression.trim();
      if (isFunction) {
        try {
          new Function("(" + expression + ")");
        } catch (e1) {
          if (expression.startsWith("async "))
            expression = "async function " + expression.substring("async ".length);
          else
            expression = "function " + expression;
          try {
            new Function("(" + expression + ")");
          } catch (e2) {
            throw new Error("Passed function is not well-serializable!");
          }
        }
      }
      if (/^(async)?\s*function(\s|\()/.test(expression))
        expression = "(" + expression + ")";
      return expression;
    }
    var JavaScriptErrorInEvaluate = class extends Error {
    };
    exports.JavaScriptErrorInEvaluate = JavaScriptErrorInEvaluate;
    function isJavaScriptErrorInEvaluate(error2) {
      return error2 instanceof JavaScriptErrorInEvaluate;
    }
  }
});

// node_modules/playwright-core/lib/server/progress.js
var require_progress2 = __commonJS({
  "node_modules/playwright-core/lib/server/progress.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ProgressController = void 0;
    var _errors = require_errors();
    var _utils = require_utils();
    var _async = require_async();
    var ProgressController = class {
      constructor(metadata, sdkObject) {
        this._forceAbortPromise = new _async.ManualPromise();
        this._cleanups = [];
        this._logName = "api";
        this._state = "before";
        this._deadline = 0;
        this._timeout = 0;
        this._lastIntermediateResult = void 0;
        this.metadata = void 0;
        this.instrumentation = void 0;
        this.sdkObject = void 0;
        this.metadata = metadata;
        this.sdkObject = sdkObject;
        this.instrumentation = sdkObject.instrumentation;
        this._forceAbortPromise.catch((e) => null);
      }
      setLogName(logName) {
        this._logName = logName;
      }
      lastIntermediateResult() {
        return this._lastIntermediateResult;
      }
      async run(task, timeout) {
        if (timeout) {
          this._timeout = timeout;
          this._deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;
        }
        (0, _utils.assert)(this._state === "before");
        this._state = "running";
        const progress = {
          log: (message) => {
            progress.logEntry({
              message
            });
          },
          logEntry: (entry) => {
            if ("message" in entry) {
              const message = entry.message;
              if (this._state === "running")
                this.metadata.log.push(message);
              this.instrumentation.onCallLog(this._logName, message, this.sdkObject, this.metadata);
            }
            if ("intermediateResult" in entry)
              this._lastIntermediateResult = entry.intermediateResult;
          },
          timeUntilDeadline: () => this._deadline ? this._deadline - (0, _utils.monotonicTime)() : 2147483647,
          isRunning: () => this._state === "running",
          cleanupWhenAborted: (cleanup) => {
            if (this._state === "running")
              this._cleanups.push(cleanup);
            else
              runCleanup(cleanup);
          },
          throwIfAborted: () => {
            if (this._state === "aborted")
              throw new AbortedError();
          },
          beforeInputAction: async (element) => {
            await this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);
          },
          metadata: this.metadata
        };
        const timeoutError = new _errors.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
        const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress.timeUntilDeadline());
        try {
          const promise = task(progress);
          const result = await Promise.race([promise, this._forceAbortPromise]);
          this._state = "finished";
          return result;
        } catch (e) {
          this._state = "aborted";
          await Promise.all(this._cleanups.splice(0).map(runCleanup));
          throw e;
        } finally {
          clearTimeout(timer);
        }
      }
    };
    exports.ProgressController = ProgressController;
    async function runCleanup(cleanup) {
      try {
        await cleanup();
      } catch (e) {
      }
    }
    var AbortedError = class extends Error {
    };
  }
});

// node_modules/playwright-core/lib/server/dom.js
var require_dom = __commonJS({
  "node_modules/playwright-core/lib/server/dom.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.throwRetargetableDOMError = throwRetargetableDOMError;
    exports.assertDone = assertDone;
    exports.waitForSelectorTask = waitForSelectorTask;
    exports.kUnableToAdoptErrorMessage = exports.InjectedScriptPollHandler = exports.ElementHandle = exports.FrameExecutionContext = void 0;
    var mime = _interopRequireWildcard(require_mime());
    var injectedScriptSource = _interopRequireWildcard(require_injectedScriptSource());
    var _protocolError = require_protocolError();
    var js = _interopRequireWildcard(require_javascript());
    var _progress = require_progress2();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FrameExecutionContext = class extends js.ExecutionContext {
      constructor(delegate, frame, world) {
        super(frame, delegate);
        this.frame = void 0;
        this._injectedScriptPromise = void 0;
        this.world = void 0;
        this.frame = frame;
        this.world = world;
      }
      async waitForSignalsCreatedBy(action) {
        return this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, action);
      }
      adoptIfNeeded(handle) {
        if (handle instanceof ElementHandle && handle._context !== this)
          return this.frame._page._delegate.adoptElementHandle(handle, this);
        return null;
      }
      async evaluate(pageFunction, arg) {
        return js.evaluate(this, true, pageFunction, arg);
      }
      async evaluateHandle(pageFunction, arg) {
        return js.evaluate(this, false, pageFunction, arg);
      }
      async evaluateExpression(expression, isFunction, arg) {
        return js.evaluateExpression(this, true, expression, isFunction, arg);
      }
      async evaluateExpressionAndWaitForSignals(expression, isFunction, arg) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, async () => {
          return this.evaluateExpression(expression, isFunction, arg);
        });
      }
      async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, async () => {
          return js.evaluateExpression(this, false, expression, isFunction, arg);
        });
      }
      createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
          return new ElementHandle(this, remoteObject.objectId);
        return super.createHandle(remoteObject);
      }
      injectedScript() {
        if (!this._injectedScriptPromise) {
          const custom = [];
          for (const [name, {
            source: source2
          }] of this.frame._page.selectors._engines)
            custom.push(`{ name: '${name}', engine: (${source2}) }`);
          const source = `
        (() => {
        ${injectedScriptSource.source}
        return new pwExport(
          ${this.frame._page._delegate.rafCountForStablePosition()},
          "${this.frame._page._browserContext._browser.options.name}",
          [${custom.join(",\n")}]
        );
        })();
      `;
          this._injectedScriptPromise = this.rawEvaluateHandle(source).then((objectId) => new js.JSHandle(this, "object", void 0, objectId));
        }
        return this._injectedScriptPromise;
      }
      async doSlowMo() {
        return this.frame._page._doSlowMo();
      }
    };
    exports.FrameExecutionContext = FrameExecutionContext;
    var ElementHandle = class extends js.JSHandle {
      constructor(context, objectId) {
        super(context, "node", void 0, objectId);
        this._page = void 0;
        this._frame = void 0;
        this._page = context.frame._page;
        this._frame = context.frame;
        this._initializePreview().catch((e) => {
        });
      }
      async _initializePreview() {
        const utility = await this._context.injectedScript();
        this._setPreview(await utility.evaluate((injected, e) => "JSHandle@" + injected.previewNode(e), this));
      }
      asElement() {
        return this;
      }
      async evaluateInUtility(pageFunction, arg) {
        try {
          const utility = await this._frame._utilityContext();
          return await utility.evaluate(pageFunction, [await utility.injectedScript(), this, arg]);
        } catch (e) {
          if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
            throw e;
          return "error:notconnected";
        }
      }
      async evaluateHandleInUtility(pageFunction, arg) {
        try {
          const utility = await this._frame._utilityContext();
          return await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);
        } catch (e) {
          if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
            throw e;
          return "error:notconnected";
        }
      }
      async evaluatePoll(progress, pageFunction, arg) {
        try {
          const utility = await this._frame._utilityContext();
          const poll = await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);
          const pollHandler = new InjectedScriptPollHandler(progress, poll);
          return await pollHandler.finish();
        } catch (e) {
          if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
            throw e;
          return "error:notconnected";
        }
      }
      async ownerFrame() {
        const frameId = await this._page._delegate.getOwnerFrame(this);
        if (!frameId)
          return null;
        const frame = this._page._frameManager.frame(frameId);
        if (frame)
          return frame;
        for (const page of this._page._browserContext.pages()) {
          const frame2 = page._frameManager.frame(frameId);
          if (frame2)
            return frame2;
        }
        return null;
      }
      async isIframeElement() {
        return this.evaluateInUtility(([injected, node]) => node && (node.nodeName === "IFRAME" || node.nodeName === "FRAME"), {});
      }
      async contentFrame() {
        const isFrameElement = throwRetargetableDOMError(await this.isIframeElement());
        if (!isFrameElement)
          return null;
        return this._page._delegate.getContentFrame(this);
      }
      async getAttribute(name) {
        return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node, name2]) => {
          if (node.nodeType !== Node.ELEMENT_NODE)
            throw injected.createStacklessError("Node is not an element");
          const element = node;
          return {
            value: element.getAttribute(name2)
          };
        }, name)).value;
      }
      async inputValue() {
        return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {
          if (node.nodeType !== Node.ELEMENT_NODE || node.nodeName !== "INPUT" && node.nodeName !== "TEXTAREA" && node.nodeName !== "SELECT")
            throw injected.createStacklessError("Node is not an <input>, <textarea> or <select> element");
          const element = node;
          return {
            value: element.value
          };
        }, void 0)).value;
      }
      async textContent() {
        return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {
          return {
            value: node.textContent
          };
        }, void 0)).value;
      }
      async innerText() {
        return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {
          if (node.nodeType !== Node.ELEMENT_NODE)
            throw injected.createStacklessError("Node is not an element");
          if (node.namespaceURI !== "http://www.w3.org/1999/xhtml")
            throw injected.createStacklessError("Node is not an HTMLElement");
          const element = node;
          return {
            value: element.innerText
          };
        }, void 0)).value;
      }
      async innerHTML() {
        return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {
          if (node.nodeType !== Node.ELEMENT_NODE)
            throw injected.createStacklessError("Node is not an element");
          const element = node;
          return {
            value: element.innerHTML
          };
        }, void 0)).value;
      }
      async dispatchEvent(type, eventInit = {}) {
        const main = await this._frame._mainContext();
        await this._page._frameManager.waitForSignalsCreatedBy(null, false, async () => {
          return main.evaluate(([injected, node, {
            type: type2,
            eventInit: eventInit2
          }]) => injected.dispatchEvent(node, type2, eventInit2), [await main.injectedScript(), this, {
            type,
            eventInit
          }]);
        });
        await this._page._doSlowMo();
      }
      async _scrollRectIntoViewIfNeeded(rect) {
        return await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
      }
      async _waitAndScrollIntoViewIfNeeded(progress) {
        while (progress.isRunning()) {
          assertDone(throwRetargetableDOMError(await this._waitForDisplayedAtStablePosition(progress, false, false)));
          progress.throwIfAborted();
          const result = throwRetargetableDOMError(await this._scrollRectIntoViewIfNeeded());
          if (result === "error:notvisible")
            continue;
          assertDone(result);
          return;
        }
      }
      async scrollIntoViewIfNeeded(metadata, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run((progress) => this._waitAndScrollIntoViewIfNeeded(progress), this._page._timeoutSettings.timeout(options2));
      }
      async _clickablePoint() {
        const intersectQuadWithViewport = (quad) => {
          return quad.map((point) => ({
            x: Math.min(Math.max(point.x, 0), metrics.width),
            y: Math.min(Math.max(point.y, 0), metrics.height)
          }));
        };
        const computeQuadArea = (quad) => {
          let area = 0;
          for (let i = 0; i < quad.length; ++i) {
            const p1 = quad[i];
            const p2 = quad[(i + 1) % quad.length];
            area += (p1.x * p2.y - p2.x * p1.y) / 2;
          }
          return Math.abs(area);
        };
        const [quads, metrics] = await Promise.all([this._page._delegate.getContentQuads(this), this._page.mainFrame()._utilityContext().then((utility) => utility.evaluate(() => ({
          width: innerWidth,
          height: innerHeight
        })))]);
        if (!quads || !quads.length)
          return "error:notvisible";
        const filtered = quads.map((quad) => intersectQuadWithViewport(quad)).filter((quad) => computeQuadArea(quad) > 0.99);
        if (!filtered.length)
          return "error:notinviewport";
        const result = {
          x: 0,
          y: 0
        };
        for (const point of filtered[0]) {
          result.x += point.x / 4;
          result.y += point.y / 4;
        }
        compensateHalfIntegerRoundingError(result);
        return result;
      }
      async _offsetPoint(offset) {
        const [box, border] = await Promise.all([this.boundingBox(), this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch((e) => {
        })]);
        if (!box || !border)
          return "error:notvisible";
        if (border === "error:notconnected")
          return border;
        return {
          x: box.x + border.left + offset.x,
          y: box.y + border.top + offset.y
        };
      }
      async _retryPointerAction(progress, actionName, waitForEnabled, action, options2) {
        let retry = 0;
        const waitTime = [0, 20, 100, 100, 500];
        const scrollOptions = [void 0, {
          block: "end",
          inline: "end"
        }, {
          block: "center",
          inline: "center"
        }, {
          block: "start",
          inline: "start"
        }];
        while (progress.isRunning()) {
          if (retry) {
            progress.log(`retrying ${actionName} action${options2.trial ? " (trial run)" : ""}, attempt #${retry}`);
            const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];
            if (timeout) {
              progress.log(`  waiting ${timeout}ms`);
              const result2 = await this.evaluateInUtility(([injected, node, timeout2]) => new Promise((f) => setTimeout(f, timeout2)), timeout);
              if (result2 === "error:notconnected")
                return result2;
            }
          } else {
            progress.log(`attempting ${actionName} action${options2.trial ? " (trial run)" : ""}`);
          }
          const forceScrollOptions = scrollOptions[retry % scrollOptions.length];
          const result = await this._performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options2);
          ++retry;
          if (result === "error:notvisible") {
            if (options2.force)
              throw new Error("Element is not visible");
            progress.log("  element is not visible");
            continue;
          }
          if (result === "error:notinviewport") {
            if (options2.force)
              throw new Error("Element is outside of the viewport");
            progress.log("  element is outside of the viewport");
            continue;
          }
          if (typeof result === "object" && "hitTargetDescription" in result) {
            progress.log(`  ${result.hitTargetDescription} intercepts pointer events`);
            continue;
          }
          return result;
        }
        return "done";
      }
      async _performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options2) {
        const {
          force = false,
          position
        } = options2;
        if (options2.__testHookBeforeStable)
          await options2.__testHookBeforeStable();
        const result = await this._waitForDisplayedAtStablePosition(progress, force, waitForEnabled);
        if (result !== "done")
          return result;
        if (options2.__testHookAfterStable)
          await options2.__testHookAfterStable();
        progress.log("  scrolling into view if needed");
        progress.throwIfAborted();
        if (forceScrollOptions) {
          const scrolled = await this.evaluateInUtility(([injected, node, options3]) => {
            if (node.nodeType === 1)
              node.scrollIntoView(options3);
          }, forceScrollOptions);
          if (scrolled === "error:notconnected")
            return scrolled;
        } else {
          const scrolled = await this._scrollRectIntoViewIfNeeded(position ? {
            x: position.x,
            y: position.y,
            width: 0,
            height: 0
          } : void 0);
          if (scrolled !== "done")
            return scrolled;
        }
        progress.log("  done scrolling");
        const maybePoint = position ? await this._offsetPoint(position) : await this._clickablePoint();
        if (typeof maybePoint === "string")
          return maybePoint;
        const point = roundPoint(maybePoint);
        progress.metadata.point = point;
        if (!process.env.PLAYWRIGHT_LAYOUT_SHIFT_CHECK)
          return this._finishPointerAction(progress, actionName, point, options2, action);
        else
          return this._finishPointerActionDetectLayoutShift(progress, actionName, point, options2, action);
      }
      async _finishPointerAction(progress, actionName, point, options2, action) {
        if (!options2.force) {
          if (options2.__testHookBeforeHitTarget)
            await options2.__testHookBeforeHitTarget();
          progress.log(`  checking that element receives pointer events at (${point.x},${point.y})`);
          const hitTargetResult = await this._checkHitTargetAt(point);
          if (hitTargetResult !== "done")
            return hitTargetResult;
          progress.log(`  element does receive pointer events`);
        }
        if (options2.trial) {
          progress.log(`  trial ${actionName} has finished`);
          return "done";
        }
        await progress.beforeInputAction(this);
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          if (options2.__testHookBeforePointerAction)
            await options2.__testHookBeforePointerAction();
          progress.throwIfAborted();
          let restoreModifiers;
          if (options2 && options2.modifiers)
            restoreModifiers = await this._page.keyboard._ensureModifiers(options2.modifiers);
          progress.log(`  performing ${actionName} action`);
          await action(point);
          progress.log(`  ${actionName} action done`);
          progress.log("  waiting for scheduled navigations to finish");
          if (options2.__testHookAfterPointerAction)
            await options2.__testHookAfterPointerAction();
          if (restoreModifiers)
            await this._page.keyboard._ensureModifiers(restoreModifiers);
        }, "input");
        progress.log("  navigations have finished");
        return "done";
      }
      async _finishPointerActionDetectLayoutShift(progress, actionName, point, options2, action) {
        await progress.beforeInputAction(this);
        let hitTargetInterceptionHandle;
        if (!options2.force) {
          if (options2.__testHookBeforeHitTarget)
            await options2.__testHookBeforeHitTarget();
          const actionType = actionName === "hover" || actionName === "tap" ? actionName : "mouse";
          const handle = await this.evaluateHandleInUtility(([injected, node, {
            actionType: actionType2,
            trial
          }]) => injected.setupHitTargetInterceptor(node, actionType2, trial), {
            actionType,
            trial: !!options2.trial
          });
          if (handle === "error:notconnected")
            return handle;
          if (!handle._objectId)
            return handle.rawValue();
          hitTargetInterceptionHandle = handle;
          progress.cleanupWhenAborted(() => {
            hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => {
            });
          });
        }
        const actionResult = await this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          if (options2.__testHookBeforePointerAction)
            await options2.__testHookBeforePointerAction();
          progress.throwIfAborted();
          let restoreModifiers;
          if (options2 && options2.modifiers)
            restoreModifiers = await this._page.keyboard._ensureModifiers(options2.modifiers);
          progress.log(`  performing ${actionName} action`);
          await action(point);
          if (restoreModifiers)
            await this._page.keyboard._ensureModifiers(restoreModifiers);
          if (hitTargetInterceptionHandle) {
            const stopHitTargetInterception = hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => "done");
            if (!options2.noWaitAfter) {
              const hitTargetResult = await stopHitTargetInterception;
              if (hitTargetResult !== "done")
                return hitTargetResult;
            }
          }
          progress.log(`  ${options2.trial ? "trial " : ""}${actionName} action done`);
          progress.log("  waiting for scheduled navigations to finish");
          if (options2.__testHookAfterPointerAction)
            await options2.__testHookAfterPointerAction();
          return "done";
        }, "input");
        if (actionResult !== "done")
          return actionResult;
        progress.log("  navigations have finished");
        return "done";
      }
      async hover(metadata, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._hover(progress, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      _hover(progress, options2) {
        return this._retryPointerAction(progress, "hover", false, (point) => this._page.mouse.move(point.x, point.y), options2);
      }
      async click(metadata, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._click(progress, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      _click(progress, options2) {
        return this._retryPointerAction(progress, "click", true, (point) => this._page.mouse.click(point.x, point.y, options2), options2);
      }
      async dblclick(metadata, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._dblclick(progress, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      _dblclick(progress, options2) {
        return this._retryPointerAction(progress, "dblclick", true, (point) => this._page.mouse.dblclick(point.x, point.y, options2), options2);
      }
      async tap(metadata, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._tap(progress, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      _tap(progress, options2) {
        return this._retryPointerAction(progress, "tap", true, (point) => this._page.touchscreen.tap(point.x, point.y), options2);
      }
      async selectOption(metadata, elements, values, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._selectOption(progress, elements, values, options2);
          return throwRetargetableDOMError(result);
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _selectOption(progress, elements, values, options2) {
        const optionsToSelect = [...elements, ...values];
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          progress.throwIfAborted();
          progress.log("  selecting specified option(s)");
          const result = await this.evaluatePoll(progress, ([injected, node, {
            optionsToSelect: optionsToSelect2,
            force
          }]) => {
            return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled"], force, injected.selectOptions.bind(injected, optionsToSelect2));
          }, {
            optionsToSelect,
            force: options2.force
          });
          await this._page._doSlowMo();
          return result;
        });
      }
      async fill(metadata, value, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._fill(progress, value, options2);
          assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _fill(progress, value, options2) {
        progress.log(`elementHandle.fill("${value}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          progress.log("  waiting for element to be visible, enabled and editable");
          const filled = await this.evaluatePoll(progress, ([injected, node, {
            value: value2,
            force
          }]) => {
            return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled", "editable"], force, injected.fill.bind(injected, value2));
          }, {
            value,
            force: options2.force
          });
          progress.throwIfAborted();
          if (filled === "error:notconnected")
            return filled;
          progress.log("  element is visible, enabled and editable");
          if (filled === "needsinput") {
            progress.throwIfAborted();
            if (value)
              await this._page.keyboard.insertText(value);
            else
              await this._page.keyboard.press("Delete");
          } else {
            assertDone(filled);
          }
          return "done";
        }, "input");
      }
      async selectText(metadata, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          progress.throwIfAborted();
          const result = await this.evaluatePoll(progress, ([injected, node, force]) => {
            return injected.waitForElementStatesAndPerformAction(node, ["visible"], force, injected.selectText.bind(injected));
          }, options2.force);
          assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async setInputFiles(metadata, files, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._setInputFiles(progress, files, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _setInputFiles(progress, files, options2) {
        for (const payload of files) {
          if (!payload.mimeType)
            payload.mimeType = mime.getType(payload.name) || "application/octet-stream";
        }
        const result = await this.evaluateHandleInUtility(([injected, node, multiple]) => {
          const element = injected.retarget(node, "follow-label");
          if (!element)
            return;
          if (element.tagName !== "INPUT")
            throw injected.createStacklessError("Node is not an HTMLInputElement");
          if (multiple && !element.multiple)
            throw injected.createStacklessError("Non-multiple file input can only accept single file");
          return element;
        }, files.length > 1);
        if (result === "error:notconnected" || !result.asElement())
          return "error:notconnected";
        const retargeted = result.asElement();
        await progress.beforeInputAction(this);
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          progress.throwIfAborted();
          await this._page._delegate.setInputFiles(retargeted, files);
        });
        await this._page._doSlowMo();
        return "done";
      }
      async focus(metadata) {
        const controller = new _progress.ProgressController(metadata, this);
        await controller.run(async (progress) => {
          const result = await this._focus(progress);
          await this._page._doSlowMo();
          return assertDone(throwRetargetableDOMError(result));
        }, 0);
      }
      async _focus(progress, resetSelectionIfNotFocused) {
        progress.throwIfAborted();
        return await this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused2]) => injected.focusNode(node, resetSelectionIfNotFocused2), resetSelectionIfNotFocused);
      }
      async type(metadata, text, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._type(progress, text, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _type(progress, text, options2) {
        progress.log(`elementHandle.type("${text}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          const result = await this._focus(progress, true);
          if (result !== "done")
            return result;
          progress.throwIfAborted();
          await this._page.keyboard.type(text, options2);
          return "done";
        }, "input");
      }
      async press(metadata, key, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._press(progress, key, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _press(progress, key, options2) {
        progress.log(`elementHandle.press("${key}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          const result = await this._focus(progress, true);
          if (result !== "done")
            return result;
          progress.throwIfAborted();
          await this._page.keyboard.press(key, options2);
          return "done";
        }, "input");
      }
      async check(metadata, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._setChecked(progress, true, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async uncheck(metadata, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._setChecked(progress, false, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _setChecked(progress, state, options2) {
        const isChecked = async () => {
          const result2 = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, "checked"), {});
          return throwRetargetableDOMError(result2);
        };
        if (await isChecked() === state)
          return "done";
        const result = await this._click(progress, options2);
        if (result !== "done")
          return result;
        if (options2.trial)
          return "done";
        if (await isChecked() !== state)
          throw new Error("Clicking the checkbox did not change its state");
        return "done";
      }
      async boundingBox() {
        return this._page._delegate.getBoundingBox(this);
      }
      async screenshot(metadata, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run((progress) => this._page._screenshotter.screenshotElement(progress, this, options2), this._page._timeoutSettings.timeout(options2));
      }
      async querySelector(selector, options2) {
        const pair = await this._frame.resolveFrameForSelectorNoWait(selector, options2, this);
        if (!pair)
          return null;
        const {
          frame,
          info
        } = pair;
        return this._page.selectors.query(frame, info, this._frame === frame ? this : void 0);
      }
      async querySelectorAll(selector) {
        const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {}, this);
        if (!pair)
          return [];
        const {
          frame,
          info
        } = pair;
        return this._page.selectors._queryAll(frame, info, this._frame === frame ? this : void 0, true);
      }
      async evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {
        const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {
          strict
        }, this);
        const handle = pair ? await this._page.selectors.query(pair.frame, pair.info, this._frame === pair.frame ? this : void 0) : null;
        if (!handle)
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        handle.dispose();
        return result;
      }
      async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {}, this);
        if (!pair)
          throw new Error(`Error: failed to find frame for selector "${selector}"`);
        const {
          frame,
          info
        } = pair;
        const arrayHandle = await this._page.selectors._queryArray(frame, info, this._frame === frame ? this : void 0);
        const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        arrayHandle.dispose();
        return result;
      }
      async isVisible() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, "visible"), {});
        if (result === "error:notconnected")
          return false;
        return result;
      }
      async isHidden() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, "hidden"), {});
        return throwRetargetableDOMError(result);
      }
      async isEnabled() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, "enabled"), {});
        return throwRetargetableDOMError(result);
      }
      async isDisabled() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, "disabled"), {});
        return throwRetargetableDOMError(result);
      }
      async isEditable() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, "editable"), {});
        return throwRetargetableDOMError(result);
      }
      async isChecked() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, "checked"), {});
        return throwRetargetableDOMError(result);
      }
      async waitForElementState(metadata, state, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          progress.log(`  waiting for element to be ${state}`);
          const result = await this.evaluatePoll(progress, ([injected, node, state2]) => {
            return injected.waitForElementStatesAndPerformAction(node, [state2], false, () => "done");
          }, state);
          assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async waitForSelector(metadata, selector, options2 = {}) {
        return this._frame.waitForSelector(metadata, selector, options2, this);
      }
      async _adoptTo(context) {
        if (this._context !== context) {
          const adopted = await this._page._delegate.adoptElementHandle(this, context);
          this.dispose();
          return adopted;
        }
        return this;
      }
      async _waitForDisplayedAtStablePosition(progress, force, waitForEnabled) {
        if (waitForEnabled)
          progress.log(`  waiting for element to be visible, enabled and stable`);
        else
          progress.log(`  waiting for element to be visible and stable`);
        const result = await this.evaluatePoll(progress, ([injected, node, {
          waitForEnabled: waitForEnabled2,
          force: force2
        }]) => {
          return injected.waitForElementStatesAndPerformAction(node, waitForEnabled2 ? ["visible", "stable", "enabled"] : ["visible", "stable"], force2, () => "done");
        }, {
          waitForEnabled,
          force
        });
        if (result === "error:notconnected")
          return result;
        if (waitForEnabled)
          progress.log("  element is visible, enabled and stable");
        else
          progress.log("  element is visible and stable");
        return result;
      }
      async _checkHitTargetAt(point) {
        const frame = await this.ownerFrame();
        if (frame && frame.parentFrame()) {
          const element = await frame.frameElement();
          const box = await element.boundingBox();
          if (!box)
            return "error:notconnected";
          point = {
            x: point.x - box.x,
            y: point.y - box.y
          };
        }
        return this.evaluateInUtility(([injected, node, point2]) => injected.checkHitTargetAt(node, point2), point);
      }
    };
    exports.ElementHandle = ElementHandle;
    var InjectedScriptPollHandler = class {
      constructor(progress, poll) {
        this._progress = void 0;
        this._poll = void 0;
        this._progress = progress;
        this._poll = poll;
        this._progress.cleanupWhenAborted(() => this.cancel());
        this._streamLogs();
      }
      async _streamLogs() {
        while (this._poll && this._progress.isRunning()) {
          const log = await this._poll.evaluate((poll) => poll.takeNextLogs()).catch((e) => []);
          if (!this._poll || !this._progress.isRunning())
            return;
          for (const entry of log)
            this._progress.logEntry(entry);
        }
      }
      async finishHandle() {
        try {
          const result = await this._poll.evaluateHandle((poll) => poll.run());
          await this._finishInternal();
          return result;
        } finally {
          await this.cancel();
        }
      }
      async finish() {
        try {
          const result = await this._poll.evaluate((poll) => poll.run());
          await this._finishInternal();
          return result;
        } finally {
          await this.cancel();
        }
      }
      async _finishInternal() {
        if (!this._poll)
          return;
        const log = await this._poll.evaluate((poll) => poll.takeLastLogs()).catch((e) => []);
        for (const entry of log)
          this._progress.logEntry(entry);
      }
      async cancel() {
        if (!this._poll)
          return;
        const copy = this._poll;
        this._poll = null;
        await copy.evaluate((p) => p.cancel()).catch((e) => {
        });
        copy.dispose();
      }
    };
    exports.InjectedScriptPollHandler = InjectedScriptPollHandler;
    function throwRetargetableDOMError(result) {
      if (result === "error:notconnected")
        throw new Error("Element is not attached to the DOM");
      return result;
    }
    function assertDone(result) {
    }
    function roundPoint(point) {
      return {
        x: (point.x * 100 | 0) / 100,
        y: (point.y * 100 | 0) / 100
      };
    }
    function compensateHalfIntegerRoundingError(point) {
      const remainderX = point.x - Math.floor(point.x);
      if (remainderX > 0.49 && remainderX < 0.51)
        point.x -= 0.02;
      const remainderY = point.y - Math.floor(point.y);
      if (remainderY > 0.49 && remainderY < 0.51)
        point.y -= 0.02;
    }
    function waitForSelectorTask(selector, state, omitReturnValue, root) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, {
        parsed,
        strict,
        state: state2,
        omitReturnValue: omitReturnValue2,
        root: root2
      }) => {
        let lastElement;
        return injected.pollRaf((progress) => {
          const elements = injected.querySelectorAll(parsed, root2 || document);
          let element = elements[0];
          const visible = element ? injected.isVisible(element) : false;
          if (lastElement !== element) {
            lastElement = element;
            if (!element) {
              progress.log(`  selector did not resolve to any element`);
            } else {
              if (elements.length > 1) {
                if (strict)
                  throw injected.strictModeViolationError(parsed, elements);
                progress.log(`  selector resolved to ${elements.length} elements. Proceeding with the first one.`);
              }
              progress.log(`  selector resolved to ${visible ? "visible" : "hidden"} ${injected.previewNode(element)}`);
            }
          }
          const hasElement = !!element;
          if (omitReturnValue2)
            element = void 0;
          switch (state2) {
            case "attached":
              return hasElement ? element : progress.continuePolling;
            case "detached":
              return !hasElement ? void 0 : progress.continuePolling;
            case "visible":
              return visible ? element : progress.continuePolling;
            case "hidden":
              return !visible ? void 0 : progress.continuePolling;
          }
        });
      }, {
        parsed: selector.parsed,
        strict: selector.strict,
        state,
        omitReturnValue,
        root
      });
    }
    var kUnableToAdoptErrorMessage = "Unable to adopt element handle from a different document";
    exports.kUnableToAdoptErrorMessage = kUnableToAdoptErrorMessage;
  }
});

// node_modules/playwright-core/lib/common/types.js
var require_types = __commonJS({
  "node_modules/playwright-core/lib/common/types.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/playwright-core/lib/server/types.js
var require_types2 = __commonJS({
  "node_modules/playwright-core/lib/server/types.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Size", {
      enumerable: true,
      get: function() {
        return _types.Size;
      }
    });
    Object.defineProperty(exports, "Point", {
      enumerable: true,
      get: function() {
        return _types.Point;
      }
    });
    Object.defineProperty(exports, "Rect", {
      enumerable: true,
      get: function() {
        return _types.Rect;
      }
    });
    Object.defineProperty(exports, "Quad", {
      enumerable: true,
      get: function() {
        return _types.Quad;
      }
    });
    Object.defineProperty(exports, "URLMatch", {
      enumerable: true,
      get: function() {
        return _types.URLMatch;
      }
    });
    Object.defineProperty(exports, "TimeoutOptions", {
      enumerable: true,
      get: function() {
        return _types.TimeoutOptions;
      }
    });
    exports.forcedColors = exports.reducedMotions = exports.colorSchemes = exports.mediaTypes = exports.kLifecycleEvents = void 0;
    var _types = require_types();
    var kLifecycleEvents = new Set(["load", "domcontentloaded", "networkidle", "commit"]);
    exports.kLifecycleEvents = kLifecycleEvents;
    var mediaTypes = new Set(["screen", "print"]);
    exports.mediaTypes = mediaTypes;
    var colorSchemes = new Set(["dark", "light", "no-preference"]);
    exports.colorSchemes = colorSchemes;
    var reducedMotions = new Set(["no-preference", "reduce"]);
    exports.reducedMotions = reducedMotions;
    var forcedColors = new Set(["active", "none"]);
    exports.forcedColors = forcedColors;
  }
});

// node_modules/playwright-core/lib/server/common/cssTokenizer.js
var require_cssTokenizer = __commonJS({
  "node_modules/playwright-core/lib/server/common/cssTokenizer.js"(exports) {
    init_shims();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
      } else if (typeof exports !== "undefined") {
        factory(exports);
      } else {
        factory(root);
      }
    })(exports, function(exports2) {
      var between = function(num, first, last) {
        return num >= first && num <= last;
      };
      function digit(code) {
        return between(code, 48, 57);
      }
      function hexdigit(code) {
        return digit(code) || between(code, 65, 70) || between(code, 97, 102);
      }
      function uppercaseletter(code) {
        return between(code, 65, 90);
      }
      function lowercaseletter(code) {
        return between(code, 97, 122);
      }
      function letter(code) {
        return uppercaseletter(code) || lowercaseletter(code);
      }
      function nonascii(code) {
        return code >= 128;
      }
      function namestartchar(code) {
        return letter(code) || nonascii(code) || code == 95;
      }
      function namechar(code) {
        return namestartchar(code) || digit(code) || code == 45;
      }
      function nonprintable(code) {
        return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;
      }
      function newline(code) {
        return code == 10;
      }
      function whitespace(code) {
        return newline(code) || code == 9 || code == 32;
      }
      function badescape(code) {
        return newline(code) || isNaN(code);
      }
      var maximumallowedcodepoint = 1114111;
      var InvalidCharacterError = function(message) {
        this.message = message;
      };
      InvalidCharacterError.prototype = new Error();
      InvalidCharacterError.prototype.name = "InvalidCharacterError";
      function preprocess(str) {
        var codepoints = [];
        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);
          if (code == 13 && str.charCodeAt(i + 1) == 10) {
            code = 10;
            i++;
          }
          if (code == 13 || code == 12)
            code = 10;
          if (code == 0)
            code = 65533;
          if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {
            var lead = code - 55296;
            var trail = str.charCodeAt(i + 1) - 56320;
            code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
            i++;
          }
          codepoints.push(code);
        }
        return codepoints;
      }
      function stringFromCode(code) {
        if (code <= 65535)
          return String.fromCharCode(code);
        code -= Math.pow(2, 16);
        var lead = Math.floor(code / Math.pow(2, 10)) + 55296;
        var trail = code % Math.pow(2, 10) + 56320;
        return String.fromCharCode(lead) + String.fromCharCode(trail);
      }
      function tokenize(str) {
        str = preprocess(str);
        var i = -1;
        var tokens = [];
        var code;
        var line = 0;
        var column = 0;
        var lastLineLength = 0;
        var incrLineno = function() {
          line += 1;
          lastLineLength = column;
          column = 0;
        };
        var locStart = { line, column };
        var codepoint = function(i2) {
          if (i2 >= str.length) {
            return -1;
          }
          return str[i2];
        };
        var next = function(num) {
          if (num === void 0)
            num = 1;
          if (num > 3)
            throw "Spec Error: no more than three codepoints of lookahead.";
          return codepoint(i + num);
        };
        var consume = function(num) {
          if (num === void 0)
            num = 1;
          i += num;
          code = codepoint(i);
          if (newline(code))
            incrLineno();
          else
            column += num;
          return true;
        };
        var reconsume = function() {
          i -= 1;
          if (newline(code)) {
            line -= 1;
            column = lastLineLength;
          } else {
            column -= 1;
          }
          locStart.line = line;
          locStart.column = column;
          return true;
        };
        var eof = function(codepoint2) {
          if (codepoint2 === void 0)
            codepoint2 = code;
          return codepoint2 == -1;
        };
        var donothing = function() {
        };
        var parseerror = function() {
          console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");
          return true;
        };
        var consumeAToken = function() {
          consumeComments();
          consume();
          if (whitespace(code)) {
            while (whitespace(next()))
              consume();
            return new WhitespaceToken();
          } else if (code == 34)
            return consumeAStringToken();
          else if (code == 35) {
            if (namechar(next()) || areAValidEscape(next(1), next(2))) {
              var token = new HashToken();
              if (wouldStartAnIdentifier(next(1), next(2), next(3)))
                token.type = "id";
              token.value = consumeAName();
              return token;
            } else {
              return new DelimToken(code);
            }
          } else if (code == 36) {
            if (next() == 61) {
              consume();
              return new SuffixMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 39)
            return consumeAStringToken();
          else if (code == 40)
            return new OpenParenToken();
          else if (code == 41)
            return new CloseParenToken();
          else if (code == 42) {
            if (next() == 61) {
              consume();
              return new SubstringMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 43) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 44)
            return new CommaToken();
          else if (code == 45) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else if (next(1) == 45 && next(2) == 62) {
              consume(2);
              return new CDCToken();
            } else if (startsWithAnIdentifier()) {
              reconsume();
              return consumeAnIdentlikeToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 46) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 58)
            return new ColonToken();
          else if (code == 59)
            return new SemicolonToken();
          else if (code == 60) {
            if (next(1) == 33 && next(2) == 45 && next(3) == 45) {
              consume(3);
              return new CDOToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 64) {
            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
              return new AtKeywordToken(consumeAName());
            } else {
              return new DelimToken(code);
            }
          } else if (code == 91)
            return new OpenSquareToken();
          else if (code == 92) {
            if (startsWithAValidEscape()) {
              reconsume();
              return consumeAnIdentlikeToken();
            } else {
              parseerror();
              return new DelimToken(code);
            }
          } else if (code == 93)
            return new CloseSquareToken();
          else if (code == 94) {
            if (next() == 61) {
              consume();
              return new PrefixMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 123)
            return new OpenCurlyToken();
          else if (code == 124) {
            if (next() == 61) {
              consume();
              return new DashMatchToken();
            } else if (next() == 124) {
              consume();
              return new ColumnToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 125)
            return new CloseCurlyToken();
          else if (code == 126) {
            if (next() == 61) {
              consume();
              return new IncludeMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (digit(code)) {
            reconsume();
            return consumeANumericToken();
          } else if (namestartchar(code)) {
            reconsume();
            return consumeAnIdentlikeToken();
          } else if (eof())
            return new EOFToken();
          else
            return new DelimToken(code);
        };
        var consumeComments = function() {
          while (next(1) == 47 && next(2) == 42) {
            consume(2);
            while (true) {
              consume();
              if (code == 42 && next() == 47) {
                consume();
                break;
              } else if (eof()) {
                parseerror();
                return;
              }
            }
          }
        };
        var consumeANumericToken = function() {
          var num = consumeANumber();
          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
            var token = new DimensionToken();
            token.value = num.value;
            token.repr = num.repr;
            token.type = num.type;
            token.unit = consumeAName();
            return token;
          } else if (next() == 37) {
            consume();
            var token = new PercentageToken();
            token.value = num.value;
            token.repr = num.repr;
            return token;
          } else {
            var token = new NumberToken();
            token.value = num.value;
            token.repr = num.repr;
            token.type = num.type;
            return token;
          }
        };
        var consumeAnIdentlikeToken = function() {
          var str2 = consumeAName();
          if (str2.toLowerCase() == "url" && next() == 40) {
            consume();
            while (whitespace(next(1)) && whitespace(next(2)))
              consume();
            if (next() == 34 || next() == 39) {
              return new FunctionToken(str2);
            } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {
              return new FunctionToken(str2);
            } else {
              return consumeAURLToken();
            }
          } else if (next() == 40) {
            consume();
            return new FunctionToken(str2);
          } else {
            return new IdentToken(str2);
          }
        };
        var consumeAStringToken = function(endingCodePoint) {
          if (endingCodePoint === void 0)
            endingCodePoint = code;
          var string = "";
          while (consume()) {
            if (code == endingCodePoint || eof()) {
              return new StringToken(string);
            } else if (newline(code)) {
              parseerror();
              reconsume();
              return new BadStringToken();
            } else if (code == 92) {
              if (eof(next())) {
                donothing();
              } else if (newline(next())) {
                consume();
              } else {
                string += stringFromCode(consumeEscape());
              }
            } else {
              string += stringFromCode(code);
            }
          }
        };
        var consumeAURLToken = function() {
          var token = new URLToken("");
          while (whitespace(next()))
            consume();
          if (eof(next()))
            return token;
          while (consume()) {
            if (code == 41 || eof()) {
              return token;
            } else if (whitespace(code)) {
              while (whitespace(next()))
                consume();
              if (next() == 41 || eof(next())) {
                consume();
                return token;
              } else {
                consumeTheRemnantsOfABadURL();
                return new BadURLToken();
              }
            } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {
              parseerror();
              consumeTheRemnantsOfABadURL();
              return new BadURLToken();
            } else if (code == 92) {
              if (startsWithAValidEscape()) {
                token.value += stringFromCode(consumeEscape());
              } else {
                parseerror();
                consumeTheRemnantsOfABadURL();
                return new BadURLToken();
              }
            } else {
              token.value += stringFromCode(code);
            }
          }
        };
        var consumeEscape = function() {
          consume();
          if (hexdigit(code)) {
            var digits = [code];
            for (var total = 0; total < 5; total++) {
              if (hexdigit(next())) {
                consume();
                digits.push(code);
              } else {
                break;
              }
            }
            if (whitespace(next()))
              consume();
            var value = parseInt(digits.map(function(x) {
              return String.fromCharCode(x);
            }).join(""), 16);
            if (value > maximumallowedcodepoint)
              value = 65533;
            return value;
          } else if (eof()) {
            return 65533;
          } else {
            return code;
          }
        };
        var areAValidEscape = function(c1, c2) {
          if (c1 != 92)
            return false;
          if (newline(c2))
            return false;
          return true;
        };
        var startsWithAValidEscape = function() {
          return areAValidEscape(code, next());
        };
        var wouldStartAnIdentifier = function(c1, c2, c3) {
          if (c1 == 45) {
            return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);
          } else if (namestartchar(c1)) {
            return true;
          } else if (c1 == 92) {
            return areAValidEscape(c1, c2);
          } else {
            return false;
          }
        };
        var startsWithAnIdentifier = function() {
          return wouldStartAnIdentifier(code, next(1), next(2));
        };
        var wouldStartANumber = function(c1, c2, c3) {
          if (c1 == 43 || c1 == 45) {
            if (digit(c2))
              return true;
            if (c2 == 46 && digit(c3))
              return true;
            return false;
          } else if (c1 == 46) {
            if (digit(c2))
              return true;
            return false;
          } else if (digit(c1)) {
            return true;
          } else {
            return false;
          }
        };
        var startsWithANumber = function() {
          return wouldStartANumber(code, next(1), next(2));
        };
        var consumeAName = function() {
          var result = "";
          while (consume()) {
            if (namechar(code)) {
              result += stringFromCode(code);
            } else if (startsWithAValidEscape()) {
              result += stringFromCode(consumeEscape());
            } else {
              reconsume();
              return result;
            }
          }
        };
        var consumeANumber = function() {
          var repr = [];
          var type = "integer";
          if (next() == 43 || next() == 45) {
            consume();
            repr += stringFromCode(code);
          }
          while (digit(next())) {
            consume();
            repr += stringFromCode(code);
          }
          if (next(1) == 46 && digit(next(2))) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          }
          var c1 = next(1), c2 = next(2), c3 = next(3);
          if ((c1 == 69 || c1 == 101) && digit(c2)) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          }
          var value = convertAStringToANumber(repr);
          return { type, value, repr };
        };
        var convertAStringToANumber = function(string) {
          return +string;
        };
        var consumeTheRemnantsOfABadURL = function() {
          while (consume()) {
            if (code == 41 || eof()) {
              return;
            } else if (startsWithAValidEscape()) {
              consumeEscape();
              donothing();
            } else {
              donothing();
            }
          }
        };
        var iterationCount = 0;
        while (!eof(next())) {
          tokens.push(consumeAToken());
          iterationCount++;
          if (iterationCount > str.length * 2)
            return "I'm infinite-looping!";
        }
        return tokens;
      }
      function CSSParserToken() {
        throw "Abstract Base Class";
      }
      CSSParserToken.prototype.toJSON = function() {
        return { token: this.tokenType };
      };
      CSSParserToken.prototype.toString = function() {
        return this.tokenType;
      };
      CSSParserToken.prototype.toSource = function() {
        return "" + this;
      };
      function BadStringToken() {
        return this;
      }
      BadStringToken.prototype = Object.create(CSSParserToken.prototype);
      BadStringToken.prototype.tokenType = "BADSTRING";
      function BadURLToken() {
        return this;
      }
      BadURLToken.prototype = Object.create(CSSParserToken.prototype);
      BadURLToken.prototype.tokenType = "BADURL";
      function WhitespaceToken() {
        return this;
      }
      WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
      WhitespaceToken.prototype.tokenType = "WHITESPACE";
      WhitespaceToken.prototype.toString = function() {
        return "WS";
      };
      WhitespaceToken.prototype.toSource = function() {
        return " ";
      };
      function CDOToken() {
        return this;
      }
      CDOToken.prototype = Object.create(CSSParserToken.prototype);
      CDOToken.prototype.tokenType = "CDO";
      CDOToken.prototype.toSource = function() {
        return "<!--";
      };
      function CDCToken() {
        return this;
      }
      CDCToken.prototype = Object.create(CSSParserToken.prototype);
      CDCToken.prototype.tokenType = "CDC";
      CDCToken.prototype.toSource = function() {
        return "-->";
      };
      function ColonToken() {
        return this;
      }
      ColonToken.prototype = Object.create(CSSParserToken.prototype);
      ColonToken.prototype.tokenType = ":";
      function SemicolonToken() {
        return this;
      }
      SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
      SemicolonToken.prototype.tokenType = ";";
      function CommaToken() {
        return this;
      }
      CommaToken.prototype = Object.create(CSSParserToken.prototype);
      CommaToken.prototype.tokenType = ",";
      function GroupingToken() {
        throw "Abstract Base Class";
      }
      GroupingToken.prototype = Object.create(CSSParserToken.prototype);
      function OpenCurlyToken() {
        this.value = "{";
        this.mirror = "}";
        return this;
      }
      OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
      OpenCurlyToken.prototype.tokenType = "{";
      function CloseCurlyToken() {
        this.value = "}";
        this.mirror = "{";
        return this;
      }
      CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
      CloseCurlyToken.prototype.tokenType = "}";
      function OpenSquareToken() {
        this.value = "[";
        this.mirror = "]";
        return this;
      }
      OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
      OpenSquareToken.prototype.tokenType = "[";
      function CloseSquareToken() {
        this.value = "]";
        this.mirror = "[";
        return this;
      }
      CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
      CloseSquareToken.prototype.tokenType = "]";
      function OpenParenToken() {
        this.value = "(";
        this.mirror = ")";
        return this;
      }
      OpenParenToken.prototype = Object.create(GroupingToken.prototype);
      OpenParenToken.prototype.tokenType = "(";
      function CloseParenToken() {
        this.value = ")";
        this.mirror = "(";
        return this;
      }
      CloseParenToken.prototype = Object.create(GroupingToken.prototype);
      CloseParenToken.prototype.tokenType = ")";
      function IncludeMatchToken() {
        return this;
      }
      IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
      IncludeMatchToken.prototype.tokenType = "~=";
      function DashMatchToken() {
        return this;
      }
      DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
      DashMatchToken.prototype.tokenType = "|=";
      function PrefixMatchToken() {
        return this;
      }
      PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
      PrefixMatchToken.prototype.tokenType = "^=";
      function SuffixMatchToken() {
        return this;
      }
      SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
      SuffixMatchToken.prototype.tokenType = "$=";
      function SubstringMatchToken() {
        return this;
      }
      SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
      SubstringMatchToken.prototype.tokenType = "*=";
      function ColumnToken() {
        return this;
      }
      ColumnToken.prototype = Object.create(CSSParserToken.prototype);
      ColumnToken.prototype.tokenType = "||";
      function EOFToken() {
        return this;
      }
      EOFToken.prototype = Object.create(CSSParserToken.prototype);
      EOFToken.prototype.tokenType = "EOF";
      EOFToken.prototype.toSource = function() {
        return "";
      };
      function DelimToken(code) {
        this.value = stringFromCode(code);
        return this;
      }
      DelimToken.prototype = Object.create(CSSParserToken.prototype);
      DelimToken.prototype.tokenType = "DELIM";
      DelimToken.prototype.toString = function() {
        return "DELIM(" + this.value + ")";
      };
      DelimToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      };
      DelimToken.prototype.toSource = function() {
        if (this.value == "\\")
          return "\\\n";
        else
          return this.value;
      };
      function StringValuedToken() {
        throw "Abstract Base Class";
      }
      StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
      StringValuedToken.prototype.ASCIIMatch = function(str) {
        return this.value.toLowerCase() == str.toLowerCase();
      };
      StringValuedToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      };
      function IdentToken(val) {
        this.value = val;
      }
      IdentToken.prototype = Object.create(StringValuedToken.prototype);
      IdentToken.prototype.tokenType = "IDENT";
      IdentToken.prototype.toString = function() {
        return "IDENT(" + this.value + ")";
      };
      IdentToken.prototype.toSource = function() {
        return escapeIdent(this.value);
      };
      function FunctionToken(val) {
        this.value = val;
        this.mirror = ")";
      }
      FunctionToken.prototype = Object.create(StringValuedToken.prototype);
      FunctionToken.prototype.tokenType = "FUNCTION";
      FunctionToken.prototype.toString = function() {
        return "FUNCTION(" + this.value + ")";
      };
      FunctionToken.prototype.toSource = function() {
        return escapeIdent(this.value) + "(";
      };
      function AtKeywordToken(val) {
        this.value = val;
      }
      AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
      AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
      AtKeywordToken.prototype.toString = function() {
        return "AT(" + this.value + ")";
      };
      AtKeywordToken.prototype.toSource = function() {
        return "@" + escapeIdent(this.value);
      };
      function HashToken(val) {
        this.value = val;
        this.type = "unrestricted";
      }
      HashToken.prototype = Object.create(StringValuedToken.prototype);
      HashToken.prototype.tokenType = "HASH";
      HashToken.prototype.toString = function() {
        return "HASH(" + this.value + ")";
      };
      HashToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
      };
      HashToken.prototype.toSource = function() {
        if (this.type == "id") {
          return "#" + escapeIdent(this.value);
        } else {
          return "#" + escapeHash(this.value);
        }
      };
      function StringToken(val) {
        this.value = val;
      }
      StringToken.prototype = Object.create(StringValuedToken.prototype);
      StringToken.prototype.tokenType = "STRING";
      StringToken.prototype.toString = function() {
        return '"' + escapeString(this.value) + '"';
      };
      function URLToken(val) {
        this.value = val;
      }
      URLToken.prototype = Object.create(StringValuedToken.prototype);
      URLToken.prototype.tokenType = "URL";
      URLToken.prototype.toString = function() {
        return "URL(" + this.value + ")";
      };
      URLToken.prototype.toSource = function() {
        return 'url("' + escapeString(this.value) + '")';
      };
      function NumberToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
      }
      NumberToken.prototype = Object.create(CSSParserToken.prototype);
      NumberToken.prototype.tokenType = "NUMBER";
      NumberToken.prototype.toString = function() {
        if (this.type == "integer")
          return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
      };
      NumberToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
      };
      NumberToken.prototype.toSource = function() {
        return this.repr;
      };
      function PercentageToken() {
        this.value = null;
        this.repr = "";
      }
      PercentageToken.prototype = Object.create(CSSParserToken.prototype);
      PercentageToken.prototype.tokenType = "PERCENTAGE";
      PercentageToken.prototype.toString = function() {
        return "PERCENTAGE(" + this.value + ")";
      };
      PercentageToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
      };
      PercentageToken.prototype.toSource = function() {
        return this.repr + "%";
      };
      function DimensionToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
      }
      DimensionToken.prototype = Object.create(CSSParserToken.prototype);
      DimensionToken.prototype.tokenType = "DIMENSION";
      DimensionToken.prototype.toString = function() {
        return "DIM(" + this.value + "," + this.unit + ")";
      };
      DimensionToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
      };
      DimensionToken.prototype.toSource = function() {
        var source = this.repr;
        var unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 48, 57))) {
          unit = "\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
      };
      function escapeIdent(string) {
        string = "" + string;
        var result = "";
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {
            result += "\\" + code.toString(16) + " ";
          } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {
            result += string[i];
          } else {
            result += "\\" + string[i];
          }
        }
        return result;
      }
      function escapeHash(string) {
        string = "" + string;
        var result = "";
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {
            result += string[i];
          } else {
            result += "\\" + code.toString(16) + " ";
          }
        }
        return result;
      }
      function escapeString(string) {
        string = "" + string;
        var result = "";
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (between(code, 1, 31) || code == 127) {
            result += "\\" + code.toString(16) + " ";
          } else if (code == 34 || code == 92) {
            result += "\\" + string[i];
          } else {
            result += string[i];
          }
        }
        return result;
      }
      exports2.tokenize = tokenize;
      exports2.IdentToken = IdentToken;
      exports2.FunctionToken = FunctionToken;
      exports2.AtKeywordToken = AtKeywordToken;
      exports2.HashToken = HashToken;
      exports2.StringToken = StringToken;
      exports2.BadStringToken = BadStringToken;
      exports2.URLToken = URLToken;
      exports2.BadURLToken = BadURLToken;
      exports2.DelimToken = DelimToken;
      exports2.NumberToken = NumberToken;
      exports2.PercentageToken = PercentageToken;
      exports2.DimensionToken = DimensionToken;
      exports2.IncludeMatchToken = IncludeMatchToken;
      exports2.DashMatchToken = DashMatchToken;
      exports2.PrefixMatchToken = PrefixMatchToken;
      exports2.SuffixMatchToken = SuffixMatchToken;
      exports2.SubstringMatchToken = SubstringMatchToken;
      exports2.ColumnToken = ColumnToken;
      exports2.WhitespaceToken = WhitespaceToken;
      exports2.CDOToken = CDOToken;
      exports2.CDCToken = CDCToken;
      exports2.ColonToken = ColonToken;
      exports2.SemicolonToken = SemicolonToken;
      exports2.CommaToken = CommaToken;
      exports2.OpenParenToken = OpenParenToken;
      exports2.CloseParenToken = CloseParenToken;
      exports2.OpenSquareToken = OpenSquareToken;
      exports2.CloseSquareToken = CloseSquareToken;
      exports2.OpenCurlyToken = OpenCurlyToken;
      exports2.CloseCurlyToken = CloseCurlyToken;
      exports2.EOFToken = EOFToken;
      exports2.CSSParserToken = CSSParserToken;
      exports2.GroupingToken = GroupingToken;
    });
  }
});

// node_modules/playwright-core/lib/server/common/cssParser.js
var require_cssParser = __commonJS({
  "node_modules/playwright-core/lib/server/common/cssParser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseCSS = parseCSS;
    exports.serializeSelector = serializeSelector;
    var css2 = _interopRequireWildcard(require_cssTokenizer());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function parseCSS(selector, customNames) {
      let tokens;
      try {
        tokens = css2.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css2.EOFToken))
          tokens.push(new css2.EOFToken());
      } catch (e) {
        const newMessage = e.message + ` while parsing selector "${selector}"`;
        const index = (e.stack || "").indexOf(e.message);
        if (index !== -1)
          e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
        e.message = newMessage;
        throw e;
      }
      const unsupportedToken = tokens.find((token) => {
        return token instanceof css2.AtKeywordToken || token instanceof css2.BadStringToken || token instanceof css2.BadURLToken || token instanceof css2.ColumnToken || token instanceof css2.CDOToken || token instanceof css2.CDCToken || token instanceof css2.SemicolonToken || token instanceof css2.OpenCurlyToken || token instanceof css2.CloseCurlyToken || token instanceof css2.URLToken || token instanceof css2.PercentageToken;
      });
      if (unsupportedToken)
        throw new Error(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);
      let pos = 0;
      const names = new Set();
      function unexpected() {
        return new Error(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);
      }
      function skipWhitespace() {
        while (tokens[pos] instanceof css2.WhitespaceToken)
          pos++;
      }
      function isIdent(p = pos) {
        return tokens[p] instanceof css2.IdentToken;
      }
      function isString(p = pos) {
        return tokens[p] instanceof css2.StringToken;
      }
      function isNumber(p = pos) {
        return tokens[p] instanceof css2.NumberToken;
      }
      function isComma(p = pos) {
        return tokens[p] instanceof css2.CommaToken;
      }
      function isCloseParen(p = pos) {
        return tokens[p] instanceof css2.CloseParenToken;
      }
      function isStar(p = pos) {
        return tokens[p] instanceof css2.DelimToken && tokens[p].value === "*";
      }
      function isEOF(p = pos) {
        return tokens[p] instanceof css2.EOFToken;
      }
      function isClauseCombinator(p = pos) {
        return tokens[p] instanceof css2.DelimToken && [">", "+", "~"].includes(tokens[p].value);
      }
      function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css2.WhitespaceToken;
      }
      function consumeFunctionArguments() {
        const result2 = [consumeArgument()];
        while (true) {
          skipWhitespace();
          if (!isComma())
            break;
          pos++;
          result2.push(consumeArgument());
        }
        return result2;
      }
      function consumeArgument() {
        skipWhitespace();
        if (isNumber())
          return tokens[pos++].value;
        if (isString())
          return tokens[pos++].value;
        return consumeComplexSelector();
      }
      function consumeComplexSelector() {
        const result2 = {
          simples: []
        };
        skipWhitespace();
        if (isClauseCombinator()) {
          result2.simples.push({
            selector: {
              functions: [{
                name: "scope",
                args: []
              }]
            },
            combinator: ""
          });
        } else {
          result2.simples.push({
            selector: consumeSimpleSelector(),
            combinator: ""
          });
        }
        while (true) {
          skipWhitespace();
          if (isClauseCombinator()) {
            result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;
            skipWhitespace();
          } else if (isSelectorClauseEnd()) {
            break;
          }
          result2.simples.push({
            combinator: "",
            selector: consumeSimpleSelector()
          });
        }
        return result2;
      }
      function consumeSimpleSelector() {
        let rawCSSString = "";
        const functions = [];
        while (!isSelectorClauseEnd()) {
          if (isIdent() || isStar()) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css2.HashToken) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css2.DelimToken && tokens[pos].value === ".") {
            pos++;
            if (isIdent())
              rawCSSString += "." + tokens[pos++].toSource();
            else
              throw unexpected();
          } else if (tokens[pos] instanceof css2.ColonToken) {
            pos++;
            if (isIdent()) {
              if (!customNames.has(tokens[pos].value.toLowerCase())) {
                rawCSSString += ":" + tokens[pos++].toSource();
              } else {
                const name = tokens[pos++].value.toLowerCase();
                functions.push({
                  name,
                  args: []
                });
                names.add(name);
              }
            } else if (tokens[pos] instanceof css2.FunctionToken) {
              const name = tokens[pos++].value.toLowerCase();
              if (!customNames.has(name)) {
                rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
              } else {
                functions.push({
                  name,
                  args: consumeFunctionArguments()
                });
                names.add(name);
              }
              skipWhitespace();
              if (!isCloseParen())
                throw unexpected();
              pos++;
            } else {
              throw unexpected();
            }
          } else if (tokens[pos] instanceof css2.OpenSquareToken) {
            rawCSSString += "[";
            pos++;
            while (!(tokens[pos] instanceof css2.CloseSquareToken) && !isEOF())
              rawCSSString += tokens[pos++].toSource();
            if (!(tokens[pos] instanceof css2.CloseSquareToken))
              throw unexpected();
            rawCSSString += "]";
            pos++;
          } else {
            throw unexpected();
          }
        }
        if (!rawCSSString && !functions.length)
          throw unexpected();
        return {
          css: rawCSSString || void 0,
          functions
        };
      }
      function consumeBuiltinFunctionArguments() {
        let s2 = "";
        while (!isCloseParen() && !isEOF())
          s2 += tokens[pos++].toSource();
        return s2;
      }
      const result = consumeFunctionArguments();
      if (!isEOF())
        throw new Error(`Error while parsing selector "${selector}"`);
      if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))
        throw new Error(`Error while parsing selector "${selector}"`);
      return {
        selector: result,
        names: Array.from(names)
      };
    }
    function serializeSelector(args) {
      return args.map((arg) => {
        if (typeof arg === "string")
          return `"${arg}"`;
        if (typeof arg === "number")
          return String(arg);
        return arg.simples.map(({
          selector,
          combinator
        }) => {
          let s2 = selector.css || "";
          s2 = s2 + selector.functions.map((func) => `:${func.name}(${serializeSelector(func.args)})`).join("");
          if (combinator)
            s2 += " " + combinator;
          return s2;
        }).join(" ");
      }).join(", ");
    }
  }
});

// node_modules/playwright-core/lib/server/common/selectorParser.js
var require_selectorParser = __commonJS({
  "node_modules/playwright-core/lib/server/common/selectorParser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseSelector = parseSelector;
    exports.splitSelectorByFrame = splitSelectorByFrame;
    exports.stringifySelector = stringifySelector;
    exports.customCSSNames = void 0;
    var _cssParser = require_cssParser();
    var customCSSNames = new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);
    exports.customCSSNames = customCSSNames;
    function parseSelector(selector) {
      const result = parseSelectorString(selector);
      const parts = result.parts.map((part) => {
        if (part.name === "css" || part.name === "css:light") {
          if (part.name === "css:light")
            part.body = ":light(" + part.body + ")";
          const parsedCSS = (0, _cssParser.parseCSS)(part.body, customCSSNames);
          return {
            name: "css",
            body: parsedCSS.selector,
            source: part.body
          };
        }
        return __spreadProps(__spreadValues({}, part), {
          source: part.body
        });
      });
      return {
        capture: result.capture,
        parts
      };
    }
    function splitSelectorByFrame(selectorText) {
      const selector = parseSelector(selectorText);
      const result = [];
      let chunk = {
        parts: []
      };
      let chunkStartIndex = 0;
      for (let i = 0; i < selector.parts.length; ++i) {
        const part = selector.parts[i];
        if (part.name === "control" && part.body === "enter-frame") {
          if (!chunk.parts.length)
            throw new Error("Selector cannot start with entering frame, select the iframe first");
          result.push(chunk);
          chunk = {
            parts: []
          };
          chunkStartIndex = i + 1;
          continue;
        }
        if (selector.capture === i)
          chunk.capture = i - chunkStartIndex;
        chunk.parts.push(part);
      }
      if (!chunk.parts.length)
        throw new Error(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);
      result.push(chunk);
      if (typeof selector.capture === "number" && typeof result[result.length - 1].capture !== "number")
        throw new Error(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);
      return result;
    }
    function stringifySelector(selector) {
      if (typeof selector === "string")
        return selector;
      return selector.parts.map((p, i) => {
        const prefix = p.name === "css" ? "" : p.name + "=";
        return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;
      }).join(" >> ");
    }
    function parseSelectorString(selector) {
      let index = 0;
      let quote;
      let start = 0;
      const result = {
        parts: []
      };
      const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf("=");
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
          name = part.substring(0, eqIndex).trim();
          body = part.substring(eqIndex + 1);
        } else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
          name = "text";
          body = part;
        } else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
          name = "text";
          body = part;
        } else if (/^\(*\/\//.test(part) || part.startsWith("..")) {
          name = "xpath";
          body = part;
        } else {
          name = "css";
          body = part;
        }
        let capture = false;
        if (name[0] === "*") {
          capture = true;
          name = name.substring(1);
        }
        result.parts.push({
          name,
          body
        });
        if (capture) {
          if (result.capture !== void 0)
            throw new Error(`Only one of the selectors can capture using * modifier`);
          result.capture = result.parts.length - 1;
        }
      };
      if (!selector.includes(">>")) {
        index = selector.length;
        append();
        return result;
      }
      while (index < selector.length) {
        const c = selector[index];
        if (c === "\\" && index + 1 < selector.length) {
          index += 2;
        } else if (c === quote) {
          quote = void 0;
          index++;
        } else if (!quote && (c === '"' || c === "'" || c === "`")) {
          quote = c;
          index++;
        } else if (!quote && c === ">" && selector[index + 1] === ">") {
          append();
          index += 2;
          start = index;
        } else {
          index++;
        }
      }
      append();
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/frames.js
var require_frames = __commonJS({
  "node_modules/playwright-core/lib/server/frames.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Frame = exports.FrameManager = void 0;
    var dom = _interopRequireWildcard(require_dom());
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var js = _interopRequireWildcard(require_javascript());
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var types2 = _interopRequireWildcard(require_types2());
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _utils = require_utils();
    var _async = require_async();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    var _protocolError = require_protocolError();
    var _selectorParser = require_selectorParser();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FrameManager = class {
      constructor(page) {
        this._page = void 0;
        this._frames = new Map();
        this._mainFrame = void 0;
        this._consoleMessageTags = new Map();
        this._signalBarriers = new Set();
        this._webSockets = new Map();
        this._dialogCounter = 0;
        this._page = page;
        this._mainFrame = void 0;
      }
      dispose() {
        for (const frame of this._frames.values())
          frame._stopNetworkIdleTimer();
      }
      mainFrame() {
        return this._mainFrame;
      }
      frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
          frames.push(frame);
          for (const subframe of frame.childFrames())
            collect(subframe);
        }
      }
      frame(frameId) {
        return this._frames.get(frameId) || null;
      }
      frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
          if (this._mainFrame) {
            this._frames.delete(this._mainFrame._id);
            this._mainFrame._id = frameId;
          } else {
            (0, _utils.assert)(!this._frames.has(frameId));
            this._mainFrame = new Frame(this._page, frameId, parentFrame);
          }
          this._frames.set(frameId, this._mainFrame);
          return this._mainFrame;
        } else {
          (0, _utils.assert)(!this._frames.has(frameId));
          const frame = new Frame(this._page, frameId, parentFrame);
          this._frames.set(frameId, frame);
          this._page.emit(_page.Page.Events.FrameAttached, frame);
          return frame;
        }
      }
      async waitForSignalsCreatedBy(progress, noWaitAfter, action, source) {
        if (noWaitAfter)
          return action();
        const barrier = new SignalBarrier(progress);
        this._signalBarriers.add(barrier);
        if (progress)
          progress.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
        const result = await action();
        if (source === "input")
          await this._page._delegate.inputActionEpilogue();
        await barrier.waitFor();
        this._signalBarriers.delete(barrier);
        await new Promise((0, _utils.makeWaitForNextTask)());
        return result;
      }
      frameWillPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.retain();
      }
      frameDidPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.release();
      }
      frameRequestedNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        for (const barrier of this._signalBarriers)
          barrier.addFrameNavigation(frame);
        if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
          return;
        }
        frame.setPendingDocument({
          documentId,
          request: void 0
        });
      }
      frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        this.removeChildFramesRecursively(frame);
        this.clearWebSockets(frame);
        frame._url = url;
        frame._name = name;
        let keepPending;
        const pendingDocument = frame.pendingDocument();
        if (pendingDocument) {
          if (pendingDocument.documentId === void 0) {
            pendingDocument.documentId = documentId;
          }
          if (pendingDocument.documentId === documentId) {
            frame._currentDocument = pendingDocument;
          } else {
            keepPending = pendingDocument;
            frame._currentDocument = {
              documentId,
              request: void 0
            };
          }
          frame.setPendingDocument(void 0);
        } else {
          frame._currentDocument = {
            documentId,
            request: void 0
          };
        }
        frame._onClearLifecycle();
        const navigationEvent = {
          url,
          name,
          newDocument: frame._currentDocument
        };
        frame.emit(Frame.Events.Navigation, navigationEvent);
        if (!initial) {
          _debugLogger.debugLogger.log("api", `  navigated to "${url}"`);
          this._page.frameNavigatedToNewDocument(frame);
        }
        frame.setPendingDocument(keepPending);
      }
      frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._url = url;
        const navigationEvent = {
          url,
          name: frame._name
        };
        frame.emit(Frame.Events.Navigation, navigationEvent);
        _debugLogger.debugLogger.log("api", `  navigated to "${url}"`);
      }
      frameAbortedNavigation(frameId, errorText, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame || !frame.pendingDocument())
          return;
        if (documentId !== void 0 && frame.pendingDocument().documentId !== documentId)
          return;
        const navigationEvent = {
          url: frame._url,
          name: frame._name,
          newDocument: frame.pendingDocument(),
          error: new Error(errorText)
        };
        frame.setPendingDocument(void 0);
        frame.emit(Frame.Events.Navigation, navigationEvent);
      }
      frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
          this._removeFramesRecursively(frame);
      }
      frameStoppedLoading(frameId) {
        this.frameLifecycleEvent(frameId, "domcontentloaded");
        this.frameLifecycleEvent(frameId, "load");
      }
      frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (frame)
          frame._onLifecycleEvent(event);
      }
      requestStarted(request, route) {
        const frame = request.frame();
        this._inflightRequestStarted(request);
        if (request._documentId)
          frame.setPendingDocument({
            documentId: request._documentId,
            request
          });
        if (request._isFavicon) {
          if (route)
            route.continue(request, {});
          return;
        }
        this._page._browserContext.emit(_browserContext.BrowserContext.Events.Request, request);
        if (route)
          this._page._requestStarted(request, route);
      }
      requestReceivedResponse(response) {
        if (response.request()._isFavicon)
          return;
        this._page._browserContext.emit(_browserContext.BrowserContext.Events.Response, response);
      }
      reportRequestFinished(request, response) {
        this._inflightRequestFinished(request);
        if (request._isFavicon)
          return;
        this._page._browserContext.emit(_browserContext.BrowserContext.Events.RequestFinished, {
          request,
          response
        });
      }
      requestFailed(request, canceled) {
        const frame = request.frame();
        this._inflightRequestFinished(request);
        if (frame.pendingDocument() && frame.pendingDocument().request === request) {
          let errorText = request.failure().errorText;
          if (canceled)
            errorText += "; maybe frame was detached?";
          this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
        }
        if (request._isFavicon)
          return;
        this._page._browserContext.emit(_browserContext.BrowserContext.Events.RequestFailed, request);
      }
      dialogDidOpen() {
        for (const frame of this._frames.values())
          frame._invalidateNonStallingEvaluations("JavaScript dialog interrupted evaluation");
        this._dialogCounter++;
      }
      dialogWillClose() {
        this._dialogCounter--;
      }
      removeChildFramesRecursively(frame) {
        for (const child of frame.childFrames())
          this._removeFramesRecursively(child);
      }
      _removeFramesRecursively(frame) {
        this.removeChildFramesRecursively(frame);
        frame._onDetached();
        this._frames.delete(frame._id);
        if (!this._page.isClosed())
          this._page.emit(_page.Page.Events.FrameDetached, frame);
      }
      _inflightRequestFinished(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        if (!frame._inflightRequests.has(request))
          return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
          frame._startNetworkIdleTimer();
      }
      _inflightRequestStarted(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
          frame._stopNetworkIdleTimer();
      }
      interceptConsoleMessage(message) {
        if (message.type() !== "debug")
          return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
          return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
      }
      clearWebSockets(frame) {
        if (frame.parentFrame())
          return;
        this._webSockets.clear();
      }
      onWebSocketCreated(requestId, url) {
        const ws = new network.WebSocket(this._page, url);
        this._webSockets.set(requestId, ws);
      }
      onWebSocketRequest(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          this._page.emit(_page.Page.Events.WebSocket, ws);
      }
      onWebSocketResponse(requestId, status, statusText) {
        const ws = this._webSockets.get(requestId);
        if (status < 400)
          return;
        if (ws)
          ws.error(`${statusText}: ${status}`);
      }
      onWebSocketFrameSent(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.frameSent(opcode, data);
      }
      webSocketFrameReceived(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.frameReceived(opcode, data);
      }
      webSocketClosed(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.closed();
        this._webSockets.delete(requestId);
      }
      webSocketError(requestId, errorMessage) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.error(errorMessage);
      }
    };
    exports.FrameManager = FrameManager;
    var Frame = class extends _instrumentation.SdkObject {
      constructor(page, id, parentFrame) {
        super(page, "frame");
        this._id = void 0;
        this._firedLifecycleEvents = new Set();
        this._subtreeLifecycleEvents = new Set();
        this._currentDocument = void 0;
        this._pendingDocument = void 0;
        this._page = void 0;
        this._parentFrame = void 0;
        this._url = "";
        this._detached = false;
        this._contextData = new Map();
        this._childFrames = new Set();
        this._name = "";
        this._inflightRequests = new Set();
        this._networkIdleTimer = void 0;
        this._setContentCounter = 0;
        this._detachedPromise = void 0;
        this._detachedCallback = () => {
        };
        this._nonStallingEvaluations = new Set();
        this.attribution.frame = this;
        this._id = id;
        this._page = page;
        this._parentFrame = parentFrame;
        this._currentDocument = {
          documentId: void 0,
          request: void 0
        };
        this._detachedPromise = new Promise((x) => this._detachedCallback = x);
        this._contextData.set("main", {
          contextPromise: new _async.ManualPromise(),
          context: null,
          rerunnableTasks: new Set()
        });
        this._contextData.set("utility", {
          contextPromise: new _async.ManualPromise(),
          context: null,
          rerunnableTasks: new Set()
        });
        this._setContext("main", null);
        this._setContext("utility", null);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._firedLifecycleEvents.add("commit");
        this._subtreeLifecycleEvents.add("commit");
      }
      isDetached() {
        return this._detached;
      }
      _onLifecycleEvent(event) {
        if (this._firedLifecycleEvents.has(event))
          return;
        this._firedLifecycleEvents.add(event);
        this._page.mainFrame()._recalculateLifecycle();
      }
      _onClearLifecycle() {
        this._firedLifecycleEvents.clear();
        this._page.mainFrame()._recalculateLifecycle();
        this._inflightRequests = new Set(Array.from(this._inflightRequests).filter((request) => request === this._currentDocument.request));
        this._stopNetworkIdleTimer();
        if (this._inflightRequests.size === 0)
          this._startNetworkIdleTimer();
        this._onLifecycleEvent("commit");
      }
      setPendingDocument(documentInfo) {
        this._pendingDocument = documentInfo;
        if (documentInfo)
          this._invalidateNonStallingEvaluations("Navigation interrupted the evaluation");
      }
      pendingDocument() {
        return this._pendingDocument;
      }
      _invalidateNonStallingEvaluations(message) {
        if (!this._nonStallingEvaluations)
          return;
        const error2 = new Error(message);
        for (const callback of this._nonStallingEvaluations)
          callback(error2);
      }
      async nonStallingRawEvaluateInExistingMainContext(expression) {
        if (this._pendingDocument)
          throw new Error("Frame is currently attempting a navigation");
        if (this._page._frameManager._dialogCounter)
          throw new Error("Open JavaScript dialog prevents evaluation");
        const context = this._existingMainContext();
        if (!context)
          throw new Error("Frame does not yet have a main execution context");
        let callback = () => {
        };
        const frameInvalidated = new Promise((f, r) => callback = r);
        this._nonStallingEvaluations.add(callback);
        try {
          return await Promise.race([context.rawEvaluateJSON(expression), frameInvalidated]);
        } finally {
          this._nonStallingEvaluations.delete(callback);
        }
      }
      async nonStallingEvaluateInExistingContext(expression, isFunction, world) {
        var _this$_contextData$ge;
        if (this._pendingDocument)
          throw new Error("Frame is currently attempting a navigation");
        const context = (_this$_contextData$ge = this._contextData.get(world)) === null || _this$_contextData$ge === void 0 ? void 0 : _this$_contextData$ge.context;
        if (!context)
          throw new Error("Frame does not yet have the execution context");
        let callback = () => {
        };
        const frameInvalidated = new Promise((f, r) => callback = r);
        this._nonStallingEvaluations.add(callback);
        try {
          return await Promise.race([context.evaluateExpression(expression, isFunction), frameInvalidated]);
        } finally {
          this._nonStallingEvaluations.delete(callback);
        }
      }
      _recalculateLifecycle() {
        const events = new Set(this._firedLifecycleEvents);
        for (const child of this._childFrames) {
          child._recalculateLifecycle();
          for (const event of events) {
            if (!child._subtreeLifecycleEvents.has(event))
              events.delete(event);
          }
        }
        const mainFrame = this._page.mainFrame();
        for (const event of events) {
          if (!this._subtreeLifecycleEvents.has(event)) {
            this.emit(Frame.Events.AddLifecycle, event);
            if (this === mainFrame && this._url !== "about:blank")
              _debugLogger.debugLogger.log("api", `  "${event}" event fired`);
            if (this === mainFrame && event === "load")
              this._page.emit(_page.Page.Events.Load);
            if (this === mainFrame && event === "domcontentloaded")
              this._page.emit(_page.Page.Events.DOMContentLoaded);
          }
        }
        for (const event of this._subtreeLifecycleEvents) {
          if (!events.has(event))
            this.emit(Frame.Events.RemoveLifecycle, event);
        }
        this._subtreeLifecycleEvents = events;
      }
      async raceNavigationAction(action) {
        return Promise.race([this._page._disconnectedPromise.then(() => {
          throw new Error("Navigation failed because page was closed!");
        }), this._page._crashedPromise.then(() => {
          throw new Error("Navigation failed because page crashed!");
        }), this._detachedPromise.then(() => {
          throw new Error("Navigating frame was detached!");
        }), action()]);
      }
      async goto(metadata, url, options2 = {}) {
        const constructedNavigationURL = (0, _utils.constructURLBasedOnBaseURL)(this._page._browserContext._options.baseURL, url);
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run((progress) => this._goto(progress, constructedNavigationURL, options2), this._page._timeoutSettings.navigationTimeout(options2));
      }
      async _goto(progress, url, options2) {
        return this.raceNavigationAction(async () => {
          const waitUntil = verifyLifecycle("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          progress.log(`navigating to "${url}", waiting until "${waitUntil}"`);
          const headers = this._page._state.extraHTTPHeaders || [];
          const refererHeader = headers.find((h) => h.name.toLowerCase() === "referer");
          let referer = refererHeader ? refererHeader.value : void 0;
          if (options2.referer !== void 0) {
            if (referer !== void 0 && referer !== options2.referer)
              throw new Error('"referer" is already specified as extra HTTP header');
            referer = options2.referer;
          }
          url = _helper.helper.completeUserURL(url);
          const sameDocument = _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (e) => !e.newDocument);
          const navigateResult = await this._page._delegate.navigateFrame(this, url, referer);
          let event;
          if (navigateResult.newDocumentId) {
            sameDocument.dispose();
            event = await _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event2) => {
              return event2.newDocument && (event2.newDocument.documentId === navigateResult.newDocumentId || !event2.error);
            }).promise;
            if (event.newDocument.documentId !== navigateResult.newDocumentId) {
              throw new Error("Navigation interrupted by another one");
            }
            if (event.error)
              throw event.error;
          } else {
            event = await sameDocument.promise;
          }
          if (!this._subtreeLifecycleEvents.has(waitUntil))
            await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
          const request = event.newDocument ? event.newDocument.request : void 0;
          const response = request ? request._finalRequest().response() : null;
          await this._page._doSlowMo();
          return response;
        });
      }
      async _waitForNavigation(progress, options2) {
        const waitUntil = verifyLifecycle("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
        progress.log(`waiting for navigation until "${waitUntil}"`);
        const navigationEvent = await _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event) => {
          if (event.error)
            return true;
          progress.log(`  navigated to "${this._url}"`);
          return true;
        }).promise;
        if (navigationEvent.error)
          throw navigationEvent.error;
        if (!this._subtreeLifecycleEvents.has(waitUntil))
          await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
        const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : void 0;
        return request ? request._finalRequest().response() : null;
      }
      async _waitForLoadState(progress, state) {
        const waitUntil = verifyLifecycle("state", state);
        if (!this._subtreeLifecycleEvents.has(waitUntil))
          await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
      }
      async frameElement() {
        return this._page._delegate.getFrameElement(this);
      }
      _context(world) {
        return this._contextData.get(world).contextPromise.then((contextOrError) => {
          if (contextOrError instanceof js.ExecutionContext)
            return contextOrError;
          throw contextOrError;
        });
      }
      _mainContext() {
        return this._context("main");
      }
      _existingMainContext() {
        var _this$_contextData$ge2;
        return ((_this$_contextData$ge2 = this._contextData.get("main")) === null || _this$_contextData$ge2 === void 0 ? void 0 : _this$_contextData$ge2.context) || null;
      }
      _utilityContext() {
        return this._context("utility");
      }
      async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg, world = "main") {
        const context = await this._context(world);
        const handle = await context.evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg);
        if (world === "main")
          await this._page._doSlowMo();
        return handle;
      }
      async evaluateExpression(expression, isFunction, arg, world = "main") {
        const context = await this._context(world);
        const value = await context.evaluateExpression(expression, isFunction, arg);
        if (world === "main")
          await this._page._doSlowMo();
        return value;
      }
      async evaluateExpressionAndWaitForSignals(expression, isFunction, arg, world = "main") {
        const context = await this._context(world);
        const value = await context.evaluateExpressionAndWaitForSignals(expression, isFunction, arg);
        if (world === "main")
          await this._page._doSlowMo();
        return value;
      }
      async querySelector(selector, options2) {
        _debugLogger.debugLogger.log("api", `    finding element using the selector "${selector}"`);
        const result = await this.resolveFrameForSelectorNoWait(selector, options2);
        if (!result)
          return null;
        return this._page.selectors.query(result.frame, result.info);
      }
      async waitForSelector(metadata, selector, options2, scope) {
        const controller = new _progress.ProgressController(metadata, this);
        if (options2.visibility)
          throw new Error("options.visibility is not supported, did you mean options.state?");
        if (options2.waitFor && options2.waitFor !== "visible")
          throw new Error("options.waitFor is not supported, did you mean options.state?");
        const {
          state = "visible"
        } = options2;
        if (!["attached", "detached", "visible", "hidden"].includes(state))
          throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
        return controller.run(async (progress) => {
          progress.log(`waiting for selector "${selector}"${state === "attached" ? "" : " to be " + state}`);
          return this.retryWithProgress(progress, selector, options2, async (selectorInFrame, continuePolling) => {
            const {
              frame,
              info
            } = selectorInFrame;
            const actualScope = this === frame ? scope : void 0;
            const task = dom.waitForSelectorTask(info, state, options2.omitReturnValue, actualScope);
            const result = actualScope ? await frame._runWaitForSelectorTaskOnce(progress, (0, _selectorParser.stringifySelector)(info.parsed), info.world, task) : await frame._scheduleRerunnableHandleTask(progress, info.world, task);
            if (!result.asElement()) {
              result.dispose();
              return null;
            }
            if (options2.__testHookBeforeAdoptNode)
              await options2.__testHookBeforeAdoptNode();
            const handle = result.asElement();
            try {
              return await handle._adoptTo(await frame._mainContext());
            } catch (e) {
              return continuePolling;
            }
          }, scope);
        }, this._page._timeoutSettings.timeout(options2));
      }
      async dispatchEvent(metadata, selector, type, eventInit = {}, options2 = {}) {
        await this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => {
          progress.injectedScript.dispatchEvent(element, data.type, data.eventInit);
        }, {
          type,
          eventInit
        }, __spreadValues({
          mainWorld: true
        }, options2));
        await this._page._doSlowMo();
      }
      async evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {
        const pair = await this.resolveFrameForSelectorNoWait(selector, {
          strict
        });
        const handle = pair ? await this._page.selectors.query(pair.frame, pair.info) : null;
        if (!handle)
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        handle.dispose();
        return result;
      }
      async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        const pair = await this.resolveFrameForSelectorNoWait(selector, {});
        if (!pair)
          throw new Error(`Error: failed to find frame for selector "${selector}"`);
        const arrayHandle = await this._page.selectors._queryArray(pair.frame, pair.info);
        const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        arrayHandle.dispose();
        return result;
      }
      async querySelectorAll(selector) {
        const pair = await this.resolveFrameForSelectorNoWait(selector, {});
        if (!pair)
          return [];
        return this._page.selectors._queryAll(pair.frame, pair.info, void 0, true);
      }
      async content() {
        try {
          const context = await this._utilityContext();
          return await context.evaluate(() => {
            let retVal = "";
            if (document.doctype)
              retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
              retVal += document.documentElement.outerHTML;
            return retVal;
          });
        } catch (e) {
          if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
            throw e;
          throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);
        }
      }
      async setContent(metadata, html, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run((progress) => this.raceNavigationAction(async () => {
          const waitUntil = options2.waitUntil === void 0 ? "load" : options2.waitUntil;
          progress.log(`setting frame content, waiting until "${waitUntil}"`);
          const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
          const context = await this._utilityContext();
          const lifecyclePromise = new Promise((resolve3, reject) => {
            this._page._frameManager._consoleMessageTags.set(tag, () => {
              this._onClearLifecycle();
              this._waitForLoadState(progress, waitUntil).then(resolve3).catch(reject);
            });
          });
          const contentPromise = context.evaluate(({
            html: html2,
            tag: tag2
          }) => {
            window.stop();
            document.open();
            console.debug(tag2);
            document.write(html2);
            document.close();
          }, {
            html,
            tag
          });
          await Promise.all([contentPromise, lifecyclePromise]);
          await this._page._doSlowMo();
        }), this._page._timeoutSettings.navigationTimeout(options2));
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      async addScriptTag(params) {
        const {
          url = null,
          content = null,
          type = ""
        } = params;
        if (!url && !content)
          throw new Error("Provide an object with a `url`, `path` or `content` property");
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
          if (url !== null)
            return (await context.evaluateHandle(addScriptUrl, {
              url,
              type
            })).asElement();
          const result = (await context.evaluateHandle(addScriptContent, {
            content,
            type
          })).asElement();
          if (this._page._delegate.cspErrorsAsynchronousForInlineScipts)
            await context.evaluate(() => true);
          return result;
        });
        async function addScriptUrl(params2) {
          const script = document.createElement("script");
          script.src = params2.url;
          if (params2.type)
            script.type = params2.type;
          const promise = new Promise((res, rej) => {
            script.onload = res;
            script.onerror = (e) => rej(typeof e === "string" ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
          });
          document.head.appendChild(script);
          await promise;
          return script;
        }
        function addScriptContent(params2) {
          const script = document.createElement("script");
          script.type = params2.type || "text/javascript";
          script.text = params2.content;
          let error2 = null;
          script.onerror = (e) => error2 = e;
          document.head.appendChild(script);
          if (error2)
            throw error2;
          return script;
        }
      }
      async addStyleTag(params) {
        const {
          url = null,
          content = null
        } = params;
        if (!url && !content)
          throw new Error("Provide an object with a `url`, `path` or `content` property");
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
          if (url !== null)
            return (await context.evaluateHandle(addStyleUrl, url)).asElement();
          return (await context.evaluateHandle(addStyleContent, content)).asElement();
        });
        async function addStyleUrl(url2) {
          const link = document.createElement("link");
          link.rel = "stylesheet";
          link.href = url2;
          const promise = new Promise((res, rej) => {
            link.onload = res;
            link.onerror = rej;
          });
          document.head.appendChild(link);
          await promise;
          return link;
        }
        async function addStyleContent(content2) {
          const style = document.createElement("style");
          style.type = "text/css";
          style.appendChild(document.createTextNode(content2));
          const promise = new Promise((res, rej) => {
            style.onload = res;
            style.onerror = rej;
          });
          document.head.appendChild(style);
          await promise;
          return style;
        }
      }
      async _raceWithCSPError(func) {
        const listeners = [];
        let result;
        let error2;
        let cspMessage;
        const actionPromise = func().then((r) => result = r).catch((e) => error2 = e);
        const errorPromise = new Promise((resolve3) => {
          listeners.push(_eventsHelper.eventsHelper.addEventListener(this._page, _page.Page.Events.Console, (message) => {
            if (message.type() === "error" && message.text().includes("Content Security Policy")) {
              cspMessage = message;
              resolve3();
            }
          }));
        });
        await Promise.race([actionPromise, errorPromise]);
        _eventsHelper.eventsHelper.removeEventListeners(listeners);
        if (cspMessage)
          throw new Error(cspMessage.text());
        if (error2)
          throw error2;
        return result;
      }
      async retryWithProgress(progress, selector, options2, action, scope) {
        const continuePolling = Symbol("continuePolling");
        while (progress.isRunning()) {
          let selectorInFrame;
          if (options2.omitAttached) {
            selectorInFrame = await this.resolveFrameForSelectorNoWait(selector, options2, scope);
          } else {
            selectorInFrame = await this._resolveFrameForSelector(progress, selector, options2, scope);
            if (!selectorInFrame) {
              await new Promise((f) => setTimeout(f, 100));
              continue;
            }
          }
          try {
            const result = await action(selectorInFrame, continuePolling);
            if (result === continuePolling)
              continue;
            return result;
          } catch (e) {
            var _selectorInFrame, _selectorInFrame2;
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            if (((_selectorInFrame = selectorInFrame) === null || _selectorInFrame === void 0 ? void 0 : _selectorInFrame.frame) !== this && (_selectorInFrame2 = selectorInFrame) !== null && _selectorInFrame2 !== void 0 && _selectorInFrame2.frame.isDetached())
              continue;
            throw e;
          }
        }
        progress.throwIfAborted();
        return void 0;
      }
      async _retryWithProgressIfNotConnected(progress, selector, strict, action) {
        return this.retryWithProgress(progress, selector, {
          strict
        }, async (selectorInFrame, continuePolling) => {
          const {
            frame,
            info
          } = selectorInFrame;
          const task = dom.waitForSelectorTask(info, "attached");
          progress.log(`waiting for selector "${selector}"`);
          const handle = await frame._scheduleRerunnableHandleTask(progress, info.world, task);
          const element = handle.asElement();
          try {
            const result = await action(element);
            if (result === "error:notconnected") {
              progress.log("element was detached from the DOM, retrying");
              return continuePolling;
            }
            return result;
          } finally {
            element === null || element === void 0 ? void 0 : element.dispose();
          }
        });
      }
      async click(metadata, selector, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._click(progress, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async dblclick(metadata, selector, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._dblclick(progress, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async dragAndDrop(metadata, source, target, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        await controller.run(async (progress) => {
          dom.assertDone(await this._retryWithProgressIfNotConnected(progress, source, options2.strict, async (handle) => {
            return handle._retryPointerAction(progress, "move and down", false, async (point) => {
              await this._page.mouse.move(point.x, point.y);
              await this._page.mouse.down();
            }, __spreadProps(__spreadValues({}, options2), {
              position: options2.sourcePosition,
              timeout: progress.timeUntilDeadline()
            }));
          }));
          dom.assertDone(await this._retryWithProgressIfNotConnected(progress, target, options2.strict, async (handle) => {
            return handle._retryPointerAction(progress, "move and up", false, async (point) => {
              await this._page.mouse.move(point.x, point.y);
              await this._page.mouse.up();
            }, __spreadProps(__spreadValues({}, options2), {
              position: options2.targetPosition,
              timeout: progress.timeUntilDeadline()
            }));
          }));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async tap(metadata, selector, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._tap(progress, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async fill(metadata, selector, value, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._fill(progress, value, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async focus(metadata, selector, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        await controller.run(async (progress) => {
          dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, void 0, (handle) => handle._focus(progress)));
          await this._page._doSlowMo();
        }, this._page._timeoutSettings.timeout(options2));
      }
      async textContent(metadata, selector, options2 = {}) {
        return this._scheduleRerunnableTask(metadata, selector, (progress, element) => element.textContent, void 0, options2);
      }
      async innerText(metadata, selector, options2 = {}) {
        return this._scheduleRerunnableTask(metadata, selector, (progress, element) => {
          if (element.namespaceURI !== "http://www.w3.org/1999/xhtml")
            throw progress.injectedScript.createStacklessError("Node is not an HTMLElement");
          return element.innerText;
        }, void 0, options2);
      }
      async innerHTML(metadata, selector, options2 = {}) {
        return this._scheduleRerunnableTask(metadata, selector, (progress, element) => element.innerHTML, void 0, options2);
      }
      async getAttribute(metadata, selector, name, options2 = {}) {
        return this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => element.getAttribute(data.name), {
          name
        }, options2);
      }
      async inputValue(metadata, selector, options2 = {}) {
        return this._scheduleRerunnableTask(metadata, selector, (progress, element) => {
          if (element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")
            throw progress.injectedScript.createStacklessError("Node is not an <input>, <textarea> or <select> element");
          return element.value;
        }, void 0, options2);
      }
      async _elementState(metadata, selector, state, options2 = {}) {
        const result = await this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => {
          const injected = progress.injectedScript;
          return injected.elementState(element, data.state);
        }, {
          state
        }, options2);
        return dom.throwRetargetableDOMError(result);
      }
      async isVisible(metadata, selector, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          progress.log(`  checking visibility of "${selector}"`);
          const pair = await this.resolveFrameForSelectorNoWait(selector, options2);
          if (!pair)
            return false;
          const element = await this._page.selectors.query(pair.frame, pair.info);
          return element ? await element.isVisible() : false;
        }, this._page._timeoutSettings.timeout({}));
      }
      async isHidden(metadata, selector, options2 = {}) {
        return !await this.isVisible(metadata, selector, options2);
      }
      async isDisabled(metadata, selector, options2 = {}) {
        return this._elementState(metadata, selector, "disabled", options2);
      }
      async isEnabled(metadata, selector, options2 = {}) {
        return this._elementState(metadata, selector, "enabled", options2);
      }
      async isEditable(metadata, selector, options2 = {}) {
        return this._elementState(metadata, selector, "editable", options2);
      }
      async isChecked(metadata, selector, options2 = {}) {
        return this._elementState(metadata, selector, "checked", options2);
      }
      async hover(metadata, selector, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._hover(progress, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async selectOption(metadata, selector, elements, values, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._selectOption(progress, elements, values, options2));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async setInputFiles(metadata, selector, files, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._setInputFiles(progress, files, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async type(metadata, selector, text, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._type(progress, text, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async press(metadata, selector, key, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._press(progress, key, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async check(metadata, selector, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._setChecked(progress, true, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async uncheck(metadata, selector, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options2.strict, (handle) => handle._setChecked(progress, false, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async waitForTimeout(metadata, timeout) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run(async () => {
          await new Promise((resolve3) => setTimeout(resolve3, timeout));
        });
      }
      async expect(metadata, selector, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        const isArray = options2.expression === "to.have.count" || options2.expression.endsWith(".array");
        const mainWorld = options2.expression === "to.have.property";
        let omitAttached = false;
        if (!options2.isNot && options2.expression === "to.be.hidden")
          omitAttached = true;
        else if (options2.isNot && options2.expression === "to.be.visible")
          omitAttached = true;
        else if (!options2.isNot && options2.expression === "to.have.count" && options2.expectedNumber === 0)
          omitAttached = true;
        else if (options2.isNot && options2.expression === "to.have.count" && options2.expectedNumber !== 0)
          omitAttached = true;
        else if (!options2.isNot && options2.expression.endsWith(".array") && options2.expectedText.length === 0)
          omitAttached = true;
        else if (options2.isNot && options2.expression.endsWith(".array") && options2.expectedText.length > 0)
          omitAttached = true;
        return await this._scheduleRerunnableTaskWithController(controller, selector, (progress, element, options3, elements) => {
          let result;
          if (options3.isArray) {
            result = progress.injectedScript.expectArray(elements, options3);
          } else {
            if (!element) {
              if (!options3.isNot && options3.expression === "to.be.hidden")
                return {
                  matches: true
                };
              if (options3.isNot && options3.expression === "to.be.visible")
                return {
                  matches: false
                };
              return progress.continuePolling;
            }
            result = progress.injectedScript.expectSingleElement(progress, element, options3);
          }
          if (result.matches === options3.isNot) {
            progress.setIntermediateResult(result.received);
            if (!Array.isArray(result.received))
              progress.log(`  unexpected value "${result.received}"`);
            return progress.continuePolling;
          }
          return result;
        }, __spreadProps(__spreadValues({}, options2), {
          isArray
        }), __spreadValues({
          strict: true,
          querySelectorAll: isArray,
          mainWorld,
          omitAttached,
          logScale: true
        }, options2)).catch((e) => {
          if (js.isJavaScriptErrorInEvaluate(e))
            throw e;
          return {
            received: controller.lastIntermediateResult(),
            matches: options2.isNot,
            log: metadata.log
          };
        });
      }
      async _waitForFunctionExpression(metadata, expression, isFunction, arg, options2, world = "main") {
        const controller = new _progress.ProgressController(metadata, this);
        if (typeof options2.pollingInterval === "number")
          (0, _utils.assert)(options2.pollingInterval > 0, "Cannot poll with non-positive interval: " + options2.pollingInterval);
        expression = js.normalizeEvaluationExpression(expression, isFunction);
        const task = (injectedScript) => injectedScript.evaluateHandle((injectedScript2, {
          expression: expression2,
          isFunction: isFunction2,
          polling,
          arg: arg2
        }) => {
          const predicate = (arg3) => {
            let result = self.eval(expression2);
            if (isFunction2 === true) {
              result = result(arg3);
            } else if (isFunction2 === false) {
              result = result;
            } else {
              if (typeof result === "function")
                result = result(arg3);
            }
            return result;
          };
          if (typeof polling !== "number")
            return injectedScript2.pollRaf((progress) => predicate(arg2) || progress.continuePolling);
          return injectedScript2.pollInterval(polling, (progress) => predicate(arg2) || progress.continuePolling);
        }, {
          expression,
          isFunction,
          polling: options2.pollingInterval,
          arg
        });
        return controller.run((progress) => this._scheduleRerunnableHandleTask(progress, world, task), this._page._timeoutSettings.timeout(options2));
      }
      async waitForFunctionValueInUtility(progress, pageFunction) {
        const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
        const handle = await this._waitForFunctionExpression((0, _instrumentation.internalCallMetadata)(), expression, true, void 0, {
          timeout: progress.timeUntilDeadline()
        }, "utility");
        return JSON.parse(handle.rawValue());
      }
      async title() {
        const context = await this._utilityContext();
        return context.evaluate(() => document.title);
      }
      _onDetached() {
        this._stopNetworkIdleTimer();
        this._detached = true;
        this._detachedCallback();
        const error2 = new Error("Frame was detached");
        for (const data of this._contextData.values()) {
          if (data.context)
            data.context.contextDestroyed(error2);
          data.contextPromise.resolve(error2);
          for (const rerunnableTask of data.rerunnableTasks)
            rerunnableTask.terminate(error2);
        }
        if (this._parentFrame)
          this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
      }
      async _scheduleRerunnableTask(metadata, selector, body, taskData, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return this._scheduleRerunnableTaskWithController(controller, selector, body, taskData, options2);
      }
      async _scheduleRerunnableTaskWithController(controller, selector, body, taskData, options2 = {}) {
        const callbackText = body.toString();
        return controller.run(async (progress) => {
          return this.retryWithProgress(progress, selector, options2, async (selectorInFrame) => {
            progress.log(`waiting for selector "${selector}"`);
            const {
              frame,
              info
            } = selectorInFrame || {
              frame: this,
              info: {
                parsed: {
                  parts: [{
                    name: "control",
                    body: "return-empty",
                    source: "control=return-empty"
                  }]
                },
                world: "utility",
                strict: !!options2.strict
              }
            };
            return await frame._scheduleRerunnableTaskInFrame(progress, info, callbackText, taskData, options2);
          });
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _scheduleRerunnableTaskInFrame(progress, info, callbackText, taskData, options2) {
        progress.throwIfAborted();
        const data = this._contextData.get(options2.mainWorld ? "main" : info.world);
        {
          const rerunnableTask = new RerunnableTask(data, progress, (injectedScript) => {
            return injectedScript.evaluateHandle((injected, {
              info: info2,
              taskData: taskData2,
              callbackText: callbackText2,
              querySelectorAll,
              logScale,
              omitAttached,
              snapshotName
            }) => {
              const callback = injected.eval(callbackText2);
              const poller = logScale ? injected.pollLogScale.bind(injected) : injected.pollRaf.bind(injected);
              let markedElements = new Set();
              return poller((progress2) => {
                let element;
                let elements = [];
                if (querySelectorAll) {
                  elements = injected.querySelectorAll(info2.parsed, document);
                  element = elements[0];
                  progress2.logRepeating(`  selector resolved to ${elements.length} element${elements.length === 1 ? "" : "s"}`);
                } else {
                  element = injected.querySelector(info2.parsed, document, info2.strict);
                  elements = element ? [element] : [];
                  if (element)
                    progress2.logRepeating(`  selector resolved to ${injected.previewNode(element)}`);
                }
                if (!element && !omitAttached)
                  return progress2.continuePolling;
                if (snapshotName) {
                  const previouslyMarkedElements = markedElements;
                  markedElements = new Set(elements);
                  for (const e of previouslyMarkedElements) {
                    if (!markedElements.has(e))
                      e.removeAttribute("__playwright_target__");
                  }
                  for (const e of markedElements) {
                    if (!previouslyMarkedElements.has(e))
                      e.setAttribute("__playwright_target__", snapshotName);
                  }
                }
                return callback(progress2, element, taskData2, elements);
              });
            }, {
              info,
              taskData,
              callbackText,
              querySelectorAll: options2.querySelectorAll,
              logScale: options2.logScale,
              omitAttached: options2.omitAttached,
              snapshotName: progress.metadata.afterSnapshot
            });
          }, true);
          if (this._detached)
            rerunnableTask.terminate(new Error("Frame got detached."));
          if (data.context)
            rerunnableTask.rerun(data.context);
          return await rerunnableTask.promise;
        }
      }
      _scheduleRerunnableHandleTask(progress, world, task) {
        const data = this._contextData.get(world);
        const rerunnableTask = new RerunnableTask(data, progress, task, false);
        if (this._detached)
          rerunnableTask.terminate(new Error("waitForFunction failed: frame got detached."));
        if (data.context)
          rerunnableTask.rerun(data.context);
        return rerunnableTask.handlePromise;
      }
      _setContext(world, context) {
        const data = this._contextData.get(world);
        data.context = context;
        if (context) {
          data.contextPromise.resolve(context);
          for (const rerunnableTask of data.rerunnableTasks)
            rerunnableTask.rerun(context);
        } else {
          data.contextPromise = new _async.ManualPromise();
        }
      }
      _contextCreated(world, context) {
        const data = this._contextData.get(world);
        if (data.context) {
          data.context.contextDestroyed(new Error("Execution context was destroyed, most likely because of a navigation"));
          this._setContext(world, null);
        }
        this._setContext(world, context);
      }
      _contextDestroyed(context) {
        if (this._detached)
          return;
        context.contextDestroyed(new Error("Execution context was destroyed, most likely because of a navigation"));
        for (const [world, data] of this._contextData) {
          if (data.context === context)
            this._setContext(world, null);
        }
      }
      _startNetworkIdleTimer() {
        (0, _utils.assert)(!this._networkIdleTimer);
        if (this._firedLifecycleEvents.has("networkidle") || this._detached)
          return;
        this._networkIdleTimer = setTimeout(() => this._onLifecycleEvent("networkidle"), 500);
      }
      _stopNetworkIdleTimer() {
        if (this._networkIdleTimer)
          clearTimeout(this._networkIdleTimer);
        this._networkIdleTimer = void 0;
      }
      async extendInjectedScript(source, arg) {
        const context = await this._context("main");
        const injectedScriptHandle = await context.injectedScript();
        return injectedScriptHandle.evaluateHandle((injectedScript, {
          source: source2,
          arg: arg2
        }) => {
          return injectedScript.extend(source2, arg2);
        }, {
          source,
          arg
        });
      }
      async _resolveFrameForSelector(progress, selector, options2, scope) {
        const elementPath = [];
        progress.cleanupWhenAborted(() => {
          for (const element of elementPath)
            element.dispose();
        });
        let frame = this;
        const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);
        for (let i = 0; i < frameChunks.length - 1 && progress.isRunning(); ++i) {
          const info = this._page.parseSelector(frameChunks[i], options2);
          const task = dom.waitForSelectorTask(info, "attached", false, i === 0 ? scope : void 0);
          progress.log(`  waiting for frame "${(0, _selectorParser.stringifySelector)(frameChunks[i])}"`);
          const handle = i === 0 && scope ? await frame._runWaitForSelectorTaskOnce(progress, (0, _selectorParser.stringifySelector)(info.parsed), info.world, task) : await frame._scheduleRerunnableHandleTask(progress, info.world, task);
          const element = handle.asElement();
          const isIframe = await element.isIframeElement();
          if (isIframe === "error:notconnected")
            return null;
          if (!isIframe)
            throw new Error(`Selector "${(0, _selectorParser.stringifySelector)(info.parsed)}" resolved to ${element.preview()}, <iframe> was expected`);
          frame = await element.contentFrame();
          element.dispose();
          if (!frame)
            return null;
        }
        return {
          frame,
          info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options2)
        };
      }
      async resolveFrameForSelectorNoWait(selector, options2, scope) {
        let frame = this;
        const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);
        for (let i = 0; i < frameChunks.length - 1; ++i) {
          const info = this._page.parseSelector(frameChunks[i], options2);
          const element = await this._page.selectors.query(frame, info, i === 0 ? scope : void 0);
          if (!element)
            return null;
          frame = await element.contentFrame();
          element.dispose();
          if (!frame)
            throw new Error(`Selector "${(0, _selectorParser.stringifySelector)(info.parsed)}" resolved to ${element.preview()}, <iframe> was expected`);
        }
        return {
          frame,
          info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options2)
        };
      }
      async _runWaitForSelectorTaskOnce(progress, selector, world, task) {
        const context = await this._context(world);
        const injected = await context.injectedScript();
        try {
          const pollHandler = new dom.InjectedScriptPollHandler(progress, await task(injected));
          const result = await pollHandler.finishHandle();
          progress.cleanupWhenAborted(() => result.dispose());
          return result;
        } catch (e) {
          throw new Error(`Error: frame navigated while waiting for selector "${selector}"`);
        }
      }
    };
    exports.Frame = Frame;
    Frame.Events = {
      Navigation: "navigation",
      AddLifecycle: "addlifecycle",
      RemoveLifecycle: "removelifecycle"
    };
    var RerunnableTask = class {
      constructor(data, progress, task, returnByValue) {
        this.promise = void 0;
        this.handlePromise = void 0;
        this._task = void 0;
        this._progress = void 0;
        this._returnByValue = void 0;
        this._contextData = void 0;
        this._task = task;
        this._progress = progress;
        this._returnByValue = returnByValue;
        if (returnByValue)
          this.promise = new _async.ManualPromise();
        else
          this.handlePromise = new _async.ManualPromise();
        this._contextData = data;
        this._contextData.rerunnableTasks.add(this);
      }
      terminate(error2) {
        this._reject(error2);
      }
      _resolve(value) {
        if (this.promise)
          this.promise.resolve(value);
        if (this.handlePromise)
          this.handlePromise.resolve(value);
      }
      _reject(error2) {
        if (this.promise)
          this.promise.reject(error2);
        if (this.handlePromise)
          this.handlePromise.reject(error2);
      }
      async rerun(context) {
        try {
          const injectedScript = await context.injectedScript();
          const pollHandler = new dom.InjectedScriptPollHandler(this._progress, await this._task(injectedScript));
          const result = this._returnByValue ? await pollHandler.finish() : await pollHandler.finishHandle();
          this._contextData.rerunnableTasks.delete(this);
          this._resolve(result);
        } catch (e) {
          if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) {
            this._contextData.rerunnableTasks.delete(this);
            this._reject(e);
          }
        }
      }
    };
    var SignalBarrier = class {
      constructor(progress) {
        this._progress = void 0;
        this._protectCount = 0;
        this._promise = new _async.ManualPromise();
        this._progress = progress;
        this.retain();
      }
      waitFor() {
        this.release();
        return this._promise;
      }
      async addFrameNavigation(frame) {
        if (frame.parentFrame())
          return;
        this.retain();
        const waiter = _helper.helper.waitForEvent(null, frame, Frame.Events.Navigation, (e) => {
          if (!e.error && this._progress)
            this._progress.log(`  navigated to "${frame._url}"`);
          return true;
        });
        await Promise.race([frame._page._disconnectedPromise, frame._page._crashedPromise, frame._detachedPromise, waiter.promise]).catch((e) => {
        });
        waiter.dispose();
        this.release();
      }
      retain() {
        ++this._protectCount;
      }
      release() {
        --this._protectCount;
        if (!this._protectCount)
          this._promise.resolve();
      }
    };
    function verifyLifecycle(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!types2.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
      return waitUntil;
    }
  }
});

// node_modules/playwright-core/lib/server/usKeyboardLayout.js
var require_usKeyboardLayout = __commonJS({
  "node_modules/playwright-core/lib/server/usKeyboardLayout.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.USKeyboardLayout = exports.keypadLocation = void 0;
    var keypadLocation = 3;
    exports.keypadLocation = keypadLocation;
    var USKeyboardLayout = {
      "Escape": {
        "keyCode": 27,
        "key": "Escape"
      },
      "F1": {
        "keyCode": 112,
        "key": "F1"
      },
      "F2": {
        "keyCode": 113,
        "key": "F2"
      },
      "F3": {
        "keyCode": 114,
        "key": "F3"
      },
      "F4": {
        "keyCode": 115,
        "key": "F4"
      },
      "F5": {
        "keyCode": 116,
        "key": "F5"
      },
      "F6": {
        "keyCode": 117,
        "key": "F6"
      },
      "F7": {
        "keyCode": 118,
        "key": "F7"
      },
      "F8": {
        "keyCode": 119,
        "key": "F8"
      },
      "F9": {
        "keyCode": 120,
        "key": "F9"
      },
      "F10": {
        "keyCode": 121,
        "key": "F10"
      },
      "F11": {
        "keyCode": 122,
        "key": "F11"
      },
      "F12": {
        "keyCode": 123,
        "key": "F12"
      },
      "Backquote": {
        "keyCode": 192,
        "shiftKey": "~",
        "key": "`"
      },
      "Digit1": {
        "keyCode": 49,
        "shiftKey": "!",
        "key": "1"
      },
      "Digit2": {
        "keyCode": 50,
        "shiftKey": "@",
        "key": "2"
      },
      "Digit3": {
        "keyCode": 51,
        "shiftKey": "#",
        "key": "3"
      },
      "Digit4": {
        "keyCode": 52,
        "shiftKey": "$",
        "key": "4"
      },
      "Digit5": {
        "keyCode": 53,
        "shiftKey": "%",
        "key": "5"
      },
      "Digit6": {
        "keyCode": 54,
        "shiftKey": "^",
        "key": "6"
      },
      "Digit7": {
        "keyCode": 55,
        "shiftKey": "&",
        "key": "7"
      },
      "Digit8": {
        "keyCode": 56,
        "shiftKey": "*",
        "key": "8"
      },
      "Digit9": {
        "keyCode": 57,
        "shiftKey": "(",
        "key": "9"
      },
      "Digit0": {
        "keyCode": 48,
        "shiftKey": ")",
        "key": "0"
      },
      "Minus": {
        "keyCode": 189,
        "shiftKey": "_",
        "key": "-"
      },
      "Equal": {
        "keyCode": 187,
        "shiftKey": "+",
        "key": "="
      },
      "Backslash": {
        "keyCode": 220,
        "shiftKey": "|",
        "key": "\\"
      },
      "Backspace": {
        "keyCode": 8,
        "key": "Backspace"
      },
      "Tab": {
        "keyCode": 9,
        "key": "Tab"
      },
      "KeyQ": {
        "keyCode": 81,
        "shiftKey": "Q",
        "key": "q"
      },
      "KeyW": {
        "keyCode": 87,
        "shiftKey": "W",
        "key": "w"
      },
      "KeyE": {
        "keyCode": 69,
        "shiftKey": "E",
        "key": "e"
      },
      "KeyR": {
        "keyCode": 82,
        "shiftKey": "R",
        "key": "r"
      },
      "KeyT": {
        "keyCode": 84,
        "shiftKey": "T",
        "key": "t"
      },
      "KeyY": {
        "keyCode": 89,
        "shiftKey": "Y",
        "key": "y"
      },
      "KeyU": {
        "keyCode": 85,
        "shiftKey": "U",
        "key": "u"
      },
      "KeyI": {
        "keyCode": 73,
        "shiftKey": "I",
        "key": "i"
      },
      "KeyO": {
        "keyCode": 79,
        "shiftKey": "O",
        "key": "o"
      },
      "KeyP": {
        "keyCode": 80,
        "shiftKey": "P",
        "key": "p"
      },
      "BracketLeft": {
        "keyCode": 219,
        "shiftKey": "{",
        "key": "["
      },
      "BracketRight": {
        "keyCode": 221,
        "shiftKey": "}",
        "key": "]"
      },
      "CapsLock": {
        "keyCode": 20,
        "key": "CapsLock"
      },
      "KeyA": {
        "keyCode": 65,
        "shiftKey": "A",
        "key": "a"
      },
      "KeyS": {
        "keyCode": 83,
        "shiftKey": "S",
        "key": "s"
      },
      "KeyD": {
        "keyCode": 68,
        "shiftKey": "D",
        "key": "d"
      },
      "KeyF": {
        "keyCode": 70,
        "shiftKey": "F",
        "key": "f"
      },
      "KeyG": {
        "keyCode": 71,
        "shiftKey": "G",
        "key": "g"
      },
      "KeyH": {
        "keyCode": 72,
        "shiftKey": "H",
        "key": "h"
      },
      "KeyJ": {
        "keyCode": 74,
        "shiftKey": "J",
        "key": "j"
      },
      "KeyK": {
        "keyCode": 75,
        "shiftKey": "K",
        "key": "k"
      },
      "KeyL": {
        "keyCode": 76,
        "shiftKey": "L",
        "key": "l"
      },
      "Semicolon": {
        "keyCode": 186,
        "shiftKey": ":",
        "key": ";"
      },
      "Quote": {
        "keyCode": 222,
        "shiftKey": '"',
        "key": "'"
      },
      "Enter": {
        "keyCode": 13,
        "key": "Enter",
        "text": "\r"
      },
      "ShiftLeft": {
        "keyCode": 160,
        "keyCodeWithoutLocation": 16,
        "key": "Shift",
        "location": 1
      },
      "KeyZ": {
        "keyCode": 90,
        "shiftKey": "Z",
        "key": "z"
      },
      "KeyX": {
        "keyCode": 88,
        "shiftKey": "X",
        "key": "x"
      },
      "KeyC": {
        "keyCode": 67,
        "shiftKey": "C",
        "key": "c"
      },
      "KeyV": {
        "keyCode": 86,
        "shiftKey": "V",
        "key": "v"
      },
      "KeyB": {
        "keyCode": 66,
        "shiftKey": "B",
        "key": "b"
      },
      "KeyN": {
        "keyCode": 78,
        "shiftKey": "N",
        "key": "n"
      },
      "KeyM": {
        "keyCode": 77,
        "shiftKey": "M",
        "key": "m"
      },
      "Comma": {
        "keyCode": 188,
        "shiftKey": "<",
        "key": ","
      },
      "Period": {
        "keyCode": 190,
        "shiftKey": ">",
        "key": "."
      },
      "Slash": {
        "keyCode": 191,
        "shiftKey": "?",
        "key": "/"
      },
      "ShiftRight": {
        "keyCode": 161,
        "keyCodeWithoutLocation": 16,
        "key": "Shift",
        "location": 2
      },
      "ControlLeft": {
        "keyCode": 162,
        "keyCodeWithoutLocation": 17,
        "key": "Control",
        "location": 1
      },
      "MetaLeft": {
        "keyCode": 91,
        "key": "Meta",
        "location": 1
      },
      "AltLeft": {
        "keyCode": 164,
        "keyCodeWithoutLocation": 18,
        "key": "Alt",
        "location": 1
      },
      "Space": {
        "keyCode": 32,
        "key": " "
      },
      "AltRight": {
        "keyCode": 165,
        "keyCodeWithoutLocation": 18,
        "key": "Alt",
        "location": 2
      },
      "AltGraph": {
        "keyCode": 225,
        "key": "AltGraph"
      },
      "MetaRight": {
        "keyCode": 92,
        "key": "Meta",
        "location": 2
      },
      "ContextMenu": {
        "keyCode": 93,
        "key": "ContextMenu"
      },
      "ControlRight": {
        "keyCode": 163,
        "keyCodeWithoutLocation": 17,
        "key": "Control",
        "location": 2
      },
      "PrintScreen": {
        "keyCode": 44,
        "key": "PrintScreen"
      },
      "ScrollLock": {
        "keyCode": 145,
        "key": "ScrollLock"
      },
      "Pause": {
        "keyCode": 19,
        "key": "Pause"
      },
      "PageUp": {
        "keyCode": 33,
        "key": "PageUp"
      },
      "PageDown": {
        "keyCode": 34,
        "key": "PageDown"
      },
      "Insert": {
        "keyCode": 45,
        "key": "Insert"
      },
      "Delete": {
        "keyCode": 46,
        "key": "Delete"
      },
      "Home": {
        "keyCode": 36,
        "key": "Home"
      },
      "End": {
        "keyCode": 35,
        "key": "End"
      },
      "ArrowLeft": {
        "keyCode": 37,
        "key": "ArrowLeft"
      },
      "ArrowUp": {
        "keyCode": 38,
        "key": "ArrowUp"
      },
      "ArrowRight": {
        "keyCode": 39,
        "key": "ArrowRight"
      },
      "ArrowDown": {
        "keyCode": 40,
        "key": "ArrowDown"
      },
      "NumLock": {
        "keyCode": 144,
        "key": "NumLock"
      },
      "NumpadDivide": {
        "keyCode": 111,
        "key": "/",
        "location": 3
      },
      "NumpadMultiply": {
        "keyCode": 106,
        "key": "*",
        "location": 3
      },
      "NumpadSubtract": {
        "keyCode": 109,
        "key": "-",
        "location": 3
      },
      "Numpad7": {
        "keyCode": 36,
        "shiftKeyCode": 103,
        "key": "Home",
        "shiftKey": "7",
        "location": 3
      },
      "Numpad8": {
        "keyCode": 38,
        "shiftKeyCode": 104,
        "key": "ArrowUp",
        "shiftKey": "8",
        "location": 3
      },
      "Numpad9": {
        "keyCode": 33,
        "shiftKeyCode": 105,
        "key": "PageUp",
        "shiftKey": "9",
        "location": 3
      },
      "Numpad4": {
        "keyCode": 37,
        "shiftKeyCode": 100,
        "key": "ArrowLeft",
        "shiftKey": "4",
        "location": 3
      },
      "Numpad5": {
        "keyCode": 12,
        "shiftKeyCode": 101,
        "key": "Clear",
        "shiftKey": "5",
        "location": 3
      },
      "Numpad6": {
        "keyCode": 39,
        "shiftKeyCode": 102,
        "key": "ArrowRight",
        "shiftKey": "6",
        "location": 3
      },
      "NumpadAdd": {
        "keyCode": 107,
        "key": "+",
        "location": 3
      },
      "Numpad1": {
        "keyCode": 35,
        "shiftKeyCode": 97,
        "key": "End",
        "shiftKey": "1",
        "location": 3
      },
      "Numpad2": {
        "keyCode": 40,
        "shiftKeyCode": 98,
        "key": "ArrowDown",
        "shiftKey": "2",
        "location": 3
      },
      "Numpad3": {
        "keyCode": 34,
        "shiftKeyCode": 99,
        "key": "PageDown",
        "shiftKey": "3",
        "location": 3
      },
      "Numpad0": {
        "keyCode": 45,
        "shiftKeyCode": 96,
        "key": "Insert",
        "shiftKey": "0",
        "location": 3
      },
      "NumpadDecimal": {
        "keyCode": 46,
        "shiftKeyCode": 110,
        "key": "\0",
        "shiftKey": ".",
        "location": 3
      },
      "NumpadEnter": {
        "keyCode": 13,
        "key": "Enter",
        "text": "\r",
        "location": 3
      }
    };
    exports.USKeyboardLayout = USKeyboardLayout;
  }
});

// node_modules/playwright-core/lib/server/input.js
var require_input = __commonJS({
  "node_modules/playwright-core/lib/server/input.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Touchscreen = exports.Mouse = exports.Keyboard = exports.keypadLocation = void 0;
    var _utils = require_utils();
    var keyboardLayout = _interopRequireWildcard(require_usKeyboardLayout());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var keypadLocation = keyboardLayout.keypadLocation;
    exports.keypadLocation = keypadLocation;
    var kModifiers = ["Alt", "Control", "Meta", "Shift"];
    var Keyboard = class {
      constructor(raw, page) {
        this._pressedModifiers = new Set();
        this._pressedKeys = new Set();
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
      }
      async down(key) {
        const description = this._keyDescriptionForString(key);
        const autoRepeat = this._pressedKeys.has(description.code);
        this._pressedKeys.add(description.code);
        if (kModifiers.includes(description.key))
          this._pressedModifiers.add(description.key);
        const text = description.text;
        await this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);
        await this._page._doSlowMo();
      }
      _keyDescriptionForString(keyString) {
        let description = usKeyboardLayout.get(keyString);
        (0, _utils.assert)(description, `Unknown key: "${keyString}"`);
        const shift = this._pressedModifiers.has("Shift");
        description = shift && description.shifted ? description.shifted : description;
        if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has("Shift") && this._pressedModifiers.size === 1)
          return __spreadProps(__spreadValues({}, description), {
            text: ""
          });
        return description;
      }
      async up(key) {
        const description = this._keyDescriptionForString(key);
        if (kModifiers.includes(description.key))
          this._pressedModifiers.delete(description.key);
        this._pressedKeys.delete(description.code);
        await this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);
        await this._page._doSlowMo();
      }
      async insertText(text) {
        await this._raw.sendText(text);
        await this._page._doSlowMo();
      }
      async type(text, options2) {
        const delay = options2 && options2.delay || void 0;
        for (const char of text) {
          if (usKeyboardLayout.has(char)) {
            await this.press(char, {
              delay
            });
          } else {
            if (delay)
              await new Promise((f) => setTimeout(f, delay));
            await this.insertText(char);
          }
        }
      }
      async press(key, options2 = {}) {
        function split(keyString) {
          const keys = [];
          let building = "";
          for (const char of keyString) {
            if (char === "+" && building) {
              keys.push(building);
              building = "";
            } else {
              building += char;
            }
          }
          keys.push(building);
          return keys;
        }
        const tokens = split(key);
        const promises = [];
        key = tokens[tokens.length - 1];
        for (let i = 0; i < tokens.length - 1; ++i)
          promises.push(this.down(tokens[i]));
        promises.push(this.down(key));
        if (options2.delay) {
          await Promise.all(promises);
          await new Promise((f) => setTimeout(f, options2.delay));
        }
        promises.push(this.up(key));
        for (let i = tokens.length - 2; i >= 0; --i)
          promises.push(this.up(tokens[i]));
        await Promise.all(promises);
      }
      async _ensureModifiers(modifiers) {
        for (const modifier of modifiers) {
          if (!kModifiers.includes(modifier))
            throw new Error("Unknown modifier " + modifier);
        }
        const restore = Array.from(this._pressedModifiers);
        const promises = [];
        for (const key of kModifiers) {
          const needDown = modifiers.includes(key);
          const isDown = this._pressedModifiers.has(key);
          if (needDown && !isDown)
            promises.push(this.down(key));
          else if (!needDown && isDown)
            promises.push(this.up(key));
        }
        await Promise.all(promises);
        return restore;
      }
      _modifiers() {
        return this._pressedModifiers;
      }
    };
    exports.Keyboard = Keyboard;
    var Mouse = class {
      constructor(raw, page) {
        this._keyboard = void 0;
        this._x = 0;
        this._y = 0;
        this._lastButton = "none";
        this._buttons = new Set();
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
        this._keyboard = this._page.keyboard;
      }
      async move(x, y, options2 = {}) {
        const {
          steps = 1
        } = options2;
        const fromX = this._x;
        const fromY = this._y;
        this._x = x;
        this._y = y;
        for (let i = 1; i <= steps; i++) {
          const middleX = fromX + (x - fromX) * (i / steps);
          const middleY = fromY + (y - fromY) * (i / steps);
          await this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers());
          await this._page._doSlowMo();
        }
      }
      async down(options2 = {}) {
        const {
          button = "left",
          clickCount = 1
        } = options2;
        this._lastButton = button;
        this._buttons.add(button);
        await this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
        await this._page._doSlowMo();
      }
      async up(options2 = {}) {
        const {
          button = "left",
          clickCount = 1
        } = options2;
        this._lastButton = "none";
        this._buttons.delete(button);
        await this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
        await this._page._doSlowMo();
      }
      async click(x, y, options2 = {}) {
        const {
          delay = null,
          clickCount = 1
        } = options2;
        if (delay) {
          this.move(x, y);
          for (let cc = 1; cc <= clickCount; ++cc) {
            await this.down(__spreadProps(__spreadValues({}, options2), {
              clickCount: cc
            }));
            await new Promise((f) => setTimeout(f, delay));
            await this.up(__spreadProps(__spreadValues({}, options2), {
              clickCount: cc
            }));
            if (cc < clickCount)
              await new Promise((f) => setTimeout(f, delay));
          }
        } else {
          const promises = [];
          promises.push(this.move(x, y));
          for (let cc = 1; cc <= clickCount; ++cc) {
            promises.push(this.down(__spreadProps(__spreadValues({}, options2), {
              clickCount: cc
            })));
            promises.push(this.up(__spreadProps(__spreadValues({}, options2), {
              clickCount: cc
            })));
          }
          await Promise.all(promises);
        }
      }
      async dblclick(x, y, options2 = {}) {
        await this.click(x, y, __spreadProps(__spreadValues({}, options2), {
          clickCount: 2
        }));
      }
      async wheel(deltaX, deltaY) {
        await this._raw.wheel(this._x, this._y, this._buttons, this._keyboard._modifiers(), deltaX, deltaY);
        await this._page._doSlowMo();
      }
    };
    exports.Mouse = Mouse;
    var aliases = new Map([["ShiftLeft", ["Shift"]], ["ControlLeft", ["Control"]], ["AltLeft", ["Alt"]], ["MetaLeft", ["Meta"]], ["Enter", ["\n", "\r"]]]);
    var usKeyboardLayout = buildLayoutClosure(keyboardLayout.USKeyboardLayout);
    function buildLayoutClosure(layout) {
      const result = new Map();
      for (const code in layout) {
        const definition = layout[code];
        const description = {
          key: definition.key || "",
          keyCode: definition.keyCode || 0,
          keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
          code,
          text: definition.text || "",
          location: definition.location || 0
        };
        if (definition.key.length === 1)
          description.text = description.key;
        let shiftedDescription;
        if (definition.shiftKey) {
          (0, _utils.assert)(definition.shiftKey.length === 1);
          shiftedDescription = __spreadValues({}, description);
          shiftedDescription.key = definition.shiftKey;
          shiftedDescription.text = definition.shiftKey;
          if (definition.shiftKeyCode)
            shiftedDescription.keyCode = definition.shiftKeyCode;
        }
        result.set(code, __spreadProps(__spreadValues({}, description), {
          shifted: shiftedDescription
        }));
        if (aliases.has(code)) {
          for (const alias of aliases.get(code))
            result.set(alias, description);
        }
        if (definition.location)
          continue;
        if (description.key.length === 1)
          result.set(description.key, description);
        if (shiftedDescription)
          result.set(shiftedDescription.key, __spreadProps(__spreadValues({}, shiftedDescription), {
            shifted: void 0
          }));
      }
      return result;
    }
    var Touchscreen = class {
      constructor(raw, page) {
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
      }
      async tap(x, y) {
        if (!this._page._browserContext._options.hasTouch)
          throw new Error("hasTouch must be enabled on the browser context before using the touchscreen.");
        await this._raw.tap(x, y, this._page.keyboard._modifiers());
        await this._page._doSlowMo();
      }
    };
    exports.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright-core/lib/server/screenshotter.js
var require_screenshotter = __commonJS({
  "node_modules/playwright-core/lib/server/screenshotter.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Screenshotter = void 0;
    var _helper = require_helper();
    var _utils = require_utils();
    var Screenshotter = class {
      constructor(page) {
        this._queue = new TaskQueue();
        this._page = void 0;
        this._page = page;
        this._queue = new TaskQueue();
      }
      async _originalViewportSize(progress) {
        const originalViewportSize = this._page.viewportSize();
        let viewportSize = originalViewportSize;
        if (!viewportSize)
          viewportSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
            width: window.innerWidth,
            height: window.innerHeight
          }));
        return {
          viewportSize,
          originalViewportSize
        };
      }
      async _fullPageSize(progress) {
        const fullPageSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => {
          if (!document.body || !document.documentElement)
            return null;
          return {
            width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
            height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
          };
        });
        return fullPageSize;
      }
      async screenshotPage(progress, options2) {
        const format2 = validateScreenshotOptions(options2);
        return this._queue.postTask(async () => {
          const {
            viewportSize,
            originalViewportSize
          } = await this._originalViewportSize(progress);
          if (options2.fullPage) {
            const fullPageSize = await this._fullPageSize(progress);
            let documentRect = {
              x: 0,
              y: 0,
              width: fullPageSize.width,
              height: fullPageSize.height
            };
            let overriddenViewportSize = null;
            const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
            if (!this._page._delegate.canScreenshotOutsideViewport() && !fitsViewport) {
              overriddenViewportSize = fullPageSize;
              progress.throwIfAborted();
              await this._page.setViewportSize(overriddenViewportSize);
              progress.cleanupWhenAborted(() => this._restoreViewport(originalViewportSize));
            }
            if (options2.clip)
              documentRect = trimClipToSize(options2.clip, documentRect);
            const buffer = await this._screenshot(progress, format2, documentRect, void 0, options2);
            progress.throwIfAborted();
            if (overriddenViewportSize)
              await this._restoreViewport(originalViewportSize);
            return buffer;
          }
          const viewportRect = options2.clip ? trimClipToSize(options2.clip, viewportSize) : __spreadValues({
            x: 0,
            y: 0
          }, viewportSize);
          return await this._screenshot(progress, format2, void 0, viewportRect, options2);
        });
      }
      async screenshotElement(progress, handle, options2 = {}) {
        const format2 = validateScreenshotOptions(options2);
        return this._queue.postTask(async () => {
          const {
            viewportSize,
            originalViewportSize
          } = await this._originalViewportSize(progress);
          await handle._waitAndScrollIntoViewIfNeeded(progress);
          progress.throwIfAborted();
          let boundingBox = await handle.boundingBox();
          (0, _utils.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
          (0, _utils.assert)(boundingBox.width !== 0, "Node has 0 width.");
          (0, _utils.assert)(boundingBox.height !== 0, "Node has 0 height.");
          let overriddenViewportSize = null;
          const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
          if (!this._page._delegate.canScreenshotOutsideViewport() && !fitsViewport) {
            overriddenViewportSize = _helper.helper.enclosingIntSize({
              width: Math.max(viewportSize.width, boundingBox.width),
              height: Math.max(viewportSize.height, boundingBox.height)
            });
            progress.throwIfAborted();
            await this._page.setViewportSize(overriddenViewportSize);
            progress.cleanupWhenAborted(() => this._restoreViewport(originalViewportSize));
            progress.throwIfAborted();
            await handle._waitAndScrollIntoViewIfNeeded(progress);
            boundingBox = await handle.boundingBox();
            (0, _utils.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
            (0, _utils.assert)(boundingBox.width !== 0, "Node has 0 width.");
            (0, _utils.assert)(boundingBox.height !== 0, "Node has 0 height.");
          }
          progress.throwIfAborted();
          const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
            x: window.scrollX,
            y: window.scrollY
          }));
          const documentRect = __spreadValues({}, boundingBox);
          documentRect.x += scrollOffset.x;
          documentRect.y += scrollOffset.y;
          const buffer = await this._screenshot(progress, format2, _helper.helper.enclosingIntRect(documentRect), void 0, options2);
          progress.throwIfAborted();
          if (overriddenViewportSize)
            await this._restoreViewport(originalViewportSize);
          return buffer;
        });
      }
      async _screenshot(progress, format2, documentRect, viewportRect, options2) {
        if (options2.__testHookBeforeScreenshot)
          await options2.__testHookBeforeScreenshot();
        progress.throwIfAborted();
        const shouldSetDefaultBackground = options2.omitBackground && format2 === "png";
        if (shouldSetDefaultBackground) {
          await this._page._delegate.setBackgroundColor({
            r: 0,
            g: 0,
            b: 0,
            a: 0
          });
          progress.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());
        }
        progress.throwIfAborted();
        const buffer = await this._page._delegate.takeScreenshot(progress, format2, documentRect, viewportRect, options2.quality);
        progress.throwIfAborted();
        if (shouldSetDefaultBackground)
          await this._page._delegate.setBackgroundColor();
        progress.throwIfAborted();
        if (options2.__testHookAfterScreenshot)
          await options2.__testHookAfterScreenshot();
        return buffer;
      }
      async _restoreViewport(originalViewportSize) {
        (0, _utils.assert)(!this._page._delegate.canScreenshotOutsideViewport());
        if (originalViewportSize)
          await this._page.setViewportSize(originalViewportSize);
        else
          await this._page._delegate.resetViewport();
      }
    };
    exports.Screenshotter = Screenshotter;
    var TaskQueue = class {
      constructor() {
        this._chain = void 0;
        this._chain = Promise.resolve();
      }
      postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => {
        });
        return result;
      }
    };
    function trimClipToSize(clip, size) {
      const p1 = {
        x: Math.max(0, Math.min(clip.x, size.width)),
        y: Math.max(0, Math.min(clip.y, size.height))
      };
      const p2 = {
        x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
        y: Math.max(0, Math.min(clip.y + clip.height, size.height))
      };
      const result = {
        x: p1.x,
        y: p1.y,
        width: p2.x - p1.x,
        height: p2.y - p1.y
      };
      (0, _utils.assert)(result.width && result.height, "Clipped area is either empty or outside the resulting image");
      return result;
    }
    function validateScreenshotOptions(options2) {
      let format2 = null;
      if (options2.type) {
        (0, _utils.assert)(options2.type === "png" || options2.type === "jpeg", "Unknown options.type value: " + options2.type);
        format2 = options2.type;
      }
      if (!format2)
        format2 = "png";
      if (options2.quality !== void 0) {
        (0, _utils.assert)(format2 === "jpeg", "options.quality is unsupported for the " + format2 + " screenshots");
        (0, _utils.assert)(typeof options2.quality === "number", "Expected options.quality to be a number but found " + typeof options2.quality);
        (0, _utils.assert)(Number.isInteger(options2.quality), "Expected options.quality to be an integer");
        (0, _utils.assert)(options2.quality >= 0 && options2.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options2.quality);
      }
      if (options2.clip) {
        (0, _utils.assert)(typeof options2.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options2.clip.x);
        (0, _utils.assert)(typeof options2.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options2.clip.y);
        (0, _utils.assert)(typeof options2.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options2.clip.width);
        (0, _utils.assert)(typeof options2.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options2.clip.height);
        (0, _utils.assert)(options2.clip.width !== 0, "Expected options.clip.width not to be 0.");
        (0, _utils.assert)(options2.clip.height !== 0, "Expected options.clip.height not to be 0.");
      }
      return format2;
    }
  }
});

// node_modules/playwright-core/lib/server/console.js
var require_console = __commonJS({
  "node_modules/playwright-core/lib/server/console.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ConsoleMessage = void 0;
    var _instrumentation = require_instrumentation();
    var ConsoleMessage = class extends _instrumentation.SdkObject {
      constructor(parent, type, text, args, location2) {
        super(parent, "console-message");
        this._type = void 0;
        this._text = void 0;
        this._args = void 0;
        this._location = void 0;
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location2 || {
          url: "",
          lineNumber: 0,
          columnNumber: 0
        };
      }
      type() {
        return this._type;
      }
      text() {
        if (this._text === void 0)
          this._text = this._args.map((arg) => arg.preview()).join(" ");
        return this._text;
      }
      args() {
        return this._args;
      }
      location() {
        return this._location;
      }
    };
    exports.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright-core/lib/server/accessibility.js
var require_accessibility = __commonJS({
  "node_modules/playwright-core/lib/server/accessibility.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Accessibility = void 0;
    var Accessibility = class {
      constructor(getAXTree) {
        this._getAXTree = void 0;
        this._getAXTree = getAXTree;
      }
      async snapshot(options2 = {}) {
        const {
          interestingOnly = true,
          root = null
        } = options2;
        const {
          tree,
          needle
        } = await this._getAXTree(root || void 0);
        if (!interestingOnly) {
          if (root)
            return needle && serializeTree(needle)[0];
          return serializeTree(tree)[0];
        }
        const interestingNodes = new Set();
        collectInterestingNodes(interestingNodes, tree, false);
        if (root && (!needle || !interestingNodes.has(needle)))
          return null;
        return serializeTree(needle || tree, interestingNodes)[0];
      }
    };
    exports.Accessibility = Accessibility;
    function collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl))
        collection.add(node);
      if (node.isLeafNode())
        return;
      insideControl = insideControl || node.isControl();
      for (const child of node.children())
        collectInterestingNodes(collection, child, insideControl);
    }
    function serializeTree(node, whitelistedNodes) {
      const children = [];
      for (const child of node.children())
        children.push(...serializeTree(child, whitelistedNodes));
      if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
      const serializedNode = node.serialize();
      if (children.length)
        serializedNode.children = children;
      return [serializedNode];
    }
  }
});

// node_modules/playwright-core/lib/server/fileChooser.js
var require_fileChooser = __commonJS({
  "node_modules/playwright-core/lib/server/fileChooser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = void 0;
        this._elementHandle = void 0;
        this._isMultiple = void 0;
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
    };
    exports.FileChooser = FileChooser;
  }
});

// node_modules/playwright-core/lib/server/page.js
var require_page = __commonJS({
  "node_modules/playwright-core/lib/server/page.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PageBinding = exports.Worker = exports.Page = void 0;
    var frames = _interopRequireWildcard(require_frames());
    var input = _interopRequireWildcard(require_input());
    var js = _interopRequireWildcard(require_javascript());
    var network = _interopRequireWildcard(require_network());
    var _screenshotter = require_screenshotter();
    var _timeoutSettings = require_timeoutSettings();
    var _browserContext = require_browserContext();
    var _console = require_console();
    var accessibility = _interopRequireWildcard(require_accessibility());
    var _fileChooser = require_fileChooser();
    var _progress = require_progress2();
    var _utils = require_utils();
    var _async = require_async();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Page = class extends _instrumentation.SdkObject {
      constructor(delegate, browserContext) {
        super(browserContext, "page");
        this._closedState = "open";
        this._closedPromise = new _async.ManualPromise();
        this._disconnected = false;
        this._initialized = false;
        this._disconnectedPromise = new _async.ManualPromise();
        this._crashedPromise = new _async.ManualPromise();
        this._browserContext = void 0;
        this.keyboard = void 0;
        this.mouse = void 0;
        this.touchscreen = void 0;
        this._timeoutSettings = void 0;
        this._delegate = void 0;
        this._state = void 0;
        this._pageBindings = new Map();
        this._evaluateOnNewDocumentSources = [];
        this._screenshotter = void 0;
        this._frameManager = void 0;
        this.accessibility = void 0;
        this._workers = new Map();
        this.pdf = void 0;
        this.coverage = void 0;
        this._clientRequestInterceptor = void 0;
        this._serverRequestInterceptor = void 0;
        this._ownedContext = void 0;
        this.selectors = void 0;
        this._pageIsError = void 0;
        this._video = null;
        this._opener = void 0;
        this._frameThrottler = new FrameThrottler(10, 200);
        this.attribution.page = this;
        this._delegate = delegate;
        this._browserContext = browserContext;
        this._state = {
          emulatedSize: browserContext._options.viewport ? {
            viewport: browserContext._options.viewport,
            screen: browserContext._options.screen || browserContext._options.viewport
          } : null,
          mediaType: null,
          colorScheme: browserContext._options.colorScheme !== void 0 ? browserContext._options.colorScheme : "light",
          reducedMotion: browserContext._options.reducedMotion !== void 0 ? browserContext._options.reducedMotion : "no-preference",
          forcedColors: browserContext._options.forcedColors !== void 0 ? browserContext._options.forcedColors : "none",
          extraHTTPHeaders: null
        };
        this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));
        this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);
        this.mouse = new input.Mouse(delegate.rawMouse, this);
        this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(browserContext._timeoutSettings);
        this._screenshotter = new _screenshotter.Screenshotter(this);
        this._frameManager = new frames.FrameManager(this);
        if (delegate.pdf)
          this.pdf = delegate.pdf.bind(delegate);
        this.coverage = delegate.coverage ? delegate.coverage() : null;
        this.selectors = browserContext.selectors();
      }
      async initOpener(opener) {
        if (!opener)
          return;
        const openerPage = await opener.pageOrError();
        if (openerPage instanceof Page && !openerPage.isClosed())
          this._opener = openerPage;
      }
      reportAsNew(error2) {
        if (error2) {
          if (this._browserContext.isClosingOrClosed())
            return;
          this._setIsError(error2);
        }
        this._initialized = true;
        this._browserContext.emit(_browserContext.BrowserContext.Events.Page, this);
        if (this.isClosed())
          this.emit(Page.Events.Close);
      }
      initializedOrUndefined() {
        return this._initialized ? this : void 0;
      }
      async _doSlowMo() {
        const slowMo = this._browserContext._browser.options.slowMo;
        if (!slowMo)
          return;
        await new Promise((x) => setTimeout(x, slowMo));
      }
      _didClose() {
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        (0, _utils.assert)(this._closedState !== "closed", "Page closed twice");
        this._closedState = "closed";
        this.emit(Page.Events.Close);
        this._closedPromise.resolve();
      }
      _didCrash() {
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        this.emit(Page.Events.Crash);
        this._crashedPromise.resolve(new Error("Page crashed"));
      }
      _didDisconnect() {
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        (0, _utils.assert)(!this._disconnected, "Page disconnected twice");
        this._disconnected = true;
        this._disconnectedPromise.resolve(new Error("Page closed"));
      }
      async _onFileChooserOpened(handle) {
        let multiple;
        try {
          multiple = await handle.evaluate((element) => !!element.multiple);
        } catch (e) {
          return;
        }
        if (!this.listenerCount(Page.Events.FileChooser)) {
          handle.dispose();
          return;
        }
        const fileChooser = new _fileChooser.FileChooser(this, handle, multiple);
        this.emit(Page.Events.FileChooser, fileChooser);
      }
      context() {
        return this._browserContext;
      }
      opener() {
        return this._opener;
      }
      mainFrame() {
        return this._frameManager.mainFrame();
      }
      frames() {
        return this._frameManager.frames();
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async exposeBinding(name, needsHandle, playwrightBinding) {
        if (this._pageBindings.has(name))
          throw new Error(`Function "${name}" has been already registered`);
        if (this._browserContext._pageBindings.has(name))
          throw new Error(`Function "${name}" has been already registered in the browser context`);
        const binding = new PageBinding(name, playwrightBinding, needsHandle);
        this._pageBindings.set(name, binding);
        await this._delegate.exposeBinding(binding);
      }
      setExtraHTTPHeaders(headers) {
        this._state.extraHTTPHeaders = headers;
        return this._delegate.updateExtraHTTPHeaders();
      }
      async _onBindingCalled(payload, context) {
        if (this._disconnected || this._closedState === "closed")
          return;
        await PageBinding.dispatch(this, payload, context);
      }
      _addConsoleMessage(type, args, location2, text) {
        const message = new _console.ConsoleMessage(this, type, text, args, location2);
        const intercepted = this._frameManager.interceptConsoleMessage(message);
        if (intercepted || !this.listenerCount(Page.Events.Console))
          args.forEach((arg) => arg.dispose());
        else
          this.emit(Page.Events.Console, message);
      }
      async reload(metadata, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run((progress) => this.mainFrame().raceNavigationAction(async () => {
          const [response] = await Promise.all([this.mainFrame()._waitForNavigation(progress, options2), this._delegate.reload()]);
          await this._doSlowMo();
          return response;
        }), this._timeoutSettings.navigationTimeout(options2));
      }
      async goBack(metadata, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run((progress) => this.mainFrame().raceNavigationAction(async () => {
          let error2;
          const waitPromise = this.mainFrame()._waitForNavigation(progress, options2).catch((e) => {
            error2 = e;
            return null;
          });
          const result = await this._delegate.goBack();
          if (!result)
            return null;
          const response = await waitPromise;
          if (error2)
            throw error2;
          await this._doSlowMo();
          return response;
        }), this._timeoutSettings.navigationTimeout(options2));
      }
      async goForward(metadata, options2) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run((progress) => this.mainFrame().raceNavigationAction(async () => {
          let error2;
          const waitPromise = this.mainFrame()._waitForNavigation(progress, options2).catch((e) => {
            error2 = e;
            return null;
          });
          const result = await this._delegate.goForward();
          if (!result)
            return null;
          const response = await waitPromise;
          if (error2)
            throw error2;
          await this._doSlowMo();
          return response;
        }), this._timeoutSettings.navigationTimeout(options2));
      }
      async emulateMedia(options2) {
        if (options2.media !== void 0)
          this._state.mediaType = options2.media;
        if (options2.colorScheme !== void 0)
          this._state.colorScheme = options2.colorScheme;
        if (options2.reducedMotion !== void 0)
          this._state.reducedMotion = options2.reducedMotion;
        if (options2.forcedColors !== void 0)
          this._state.forcedColors = options2.forcedColors;
        await this._delegate.updateEmulateMedia();
        await this._doSlowMo();
      }
      async setViewportSize(viewportSize) {
        this._state.emulatedSize = {
          viewport: __spreadValues({}, viewportSize),
          screen: __spreadValues({}, viewportSize)
        };
        await this._delegate.setEmulatedSize(this._state.emulatedSize);
        await this._doSlowMo();
      }
      viewportSize() {
        var _this$_state$emulated;
        return ((_this$_state$emulated = this._state.emulatedSize) === null || _this$_state$emulated === void 0 ? void 0 : _this$_state$emulated.viewport) || null;
      }
      async bringToFront() {
        await this._delegate.bringToFront();
      }
      async _addInitScriptExpression(source) {
        this._evaluateOnNewDocumentSources.push(source);
        await this._delegate.evaluateOnNewDocument(source);
      }
      _needsRequestInterception() {
        return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;
      }
      async _setClientRequestInterceptor(handler) {
        this._clientRequestInterceptor = handler;
        await this._delegate.updateRequestInterception();
      }
      async _setServerRequestInterceptor(handler) {
        this._serverRequestInterceptor = handler;
        await this._delegate.updateRequestInterception();
      }
      _requestStarted(request, routeDelegate) {
        const route = new network.Route(request, routeDelegate);
        if (this._serverRequestInterceptor) {
          this._serverRequestInterceptor(route, request);
          return;
        }
        if (this._clientRequestInterceptor) {
          this._clientRequestInterceptor(route, request);
          return;
        }
        if (this._browserContext._requestInterceptor) {
          this._browserContext._requestInterceptor(route, request);
          return;
        }
        route.continue();
      }
      async screenshot(metadata, options2 = {}) {
        const controller = new _progress.ProgressController(metadata, this);
        return controller.run((progress) => this._screenshotter.screenshotPage(progress, options2), this._timeoutSettings.timeout(options2));
      }
      async close(metadata, options2) {
        if (this._closedState === "closed")
          return;
        const runBeforeUnload = !!options2 && !!options2.runBeforeUnload;
        if (this._closedState !== "closing") {
          this._closedState = "closing";
          (0, _utils.assert)(!this._disconnected, "Target closed");
          await this._delegate.closePage(runBeforeUnload).catch((e) => _debugLogger.debugLogger.log("error", e));
        }
        if (!runBeforeUnload)
          await this._closedPromise;
        if (this._ownedContext)
          await this._ownedContext.close(metadata);
      }
      _setIsError(error2) {
        this._pageIsError = error2;
        if (!this._frameManager.mainFrame())
          this._frameManager.frameAttached("<dummy>", null);
      }
      isClosed() {
        return this._closedState === "closed";
      }
      _addWorker(workerId, worker) {
        this._workers.set(workerId, worker);
        this.emit(Page.Events.Worker, worker);
      }
      _removeWorker(workerId) {
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.didClose();
        this._workers.delete(workerId);
      }
      _clearWorkers() {
        for (const [workerId, worker] of this._workers) {
          worker.didClose();
          this._workers.delete(workerId);
        }
      }
      async _setFileChooserIntercepted(enabled) {
        await this._delegate.setFileChooserIntercepted(enabled);
      }
      frameNavigatedToNewDocument(frame) {
        this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);
        const url = frame.url();
        if (!url.startsWith("http"))
          return;
        const purl = network.parsedURL(url);
        if (purl)
          this._browserContext.addVisitedOrigin(purl.origin);
      }
      allBindings() {
        return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
      }
      getBinding(name) {
        return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);
      }
      setScreencastOptions(options2) {
        this._delegate.setScreencastOptions(options2).catch((e) => _debugLogger.debugLogger.log("error", e));
        this._frameThrottler.setEnabled(!!options2);
      }
      throttleScreencastFrameAck(ack) {
        this._frameThrottler.ack(ack);
      }
      temporarlyDisableTracingScreencastThrottling() {
        this._frameThrottler.recharge();
      }
      firePageError(error2) {
        this.emit(Page.Events.PageError, error2);
      }
      parseSelector(selector, options2) {
        const strict = typeof (options2 === null || options2 === void 0 ? void 0 : options2.strict) === "boolean" ? options2.strict : !!this.context()._options.strictSelectors;
        return this.selectors.parseSelector(selector, strict);
      }
    };
    exports.Page = Page;
    Page.Events = {
      Close: "close",
      Crash: "crash",
      Console: "console",
      Dialog: "dialog",
      Download: "download",
      FileChooser: "filechooser",
      DOMContentLoaded: "domcontentloaded",
      PageError: "pageerror",
      FrameAttached: "frameattached",
      FrameDetached: "framedetached",
      InternalFrameNavigatedToNewDocument: "internalframenavigatedtonewdocument",
      Load: "load",
      ScreencastFrame: "screencastframe",
      Video: "video",
      WebSocket: "websocket",
      Worker: "worker"
    };
    var Worker = class extends _instrumentation.SdkObject {
      constructor(parent, url) {
        super(parent, "worker");
        this._url = void 0;
        this._executionContextPromise = void 0;
        this._executionContextCallback = void 0;
        this._existingExecutionContext = null;
        this._url = url;
        this._executionContextCallback = () => {
        };
        this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
      }
      _createExecutionContext(delegate) {
        this._existingExecutionContext = new js.ExecutionContext(this, delegate);
        this._executionContextCallback(this._existingExecutionContext);
      }
      url() {
        return this._url;
      }
      didClose() {
        if (this._existingExecutionContext)
          this._existingExecutionContext.contextDestroyed(new Error("Worker was closed"));
        this.emit(Worker.Events.Close, this);
      }
      async evaluateExpression(expression, isFunction, arg) {
        return js.evaluateExpression(await this._executionContextPromise, true, expression, isFunction, arg);
      }
      async evaluateExpressionHandle(expression, isFunction, arg) {
        return js.evaluateExpression(await this._executionContextPromise, false, expression, isFunction, arg);
      }
    };
    exports.Worker = Worker;
    Worker.Events = {
      Close: "close"
    };
    var PageBinding = class {
      constructor(name, playwrightFunction, needsHandle) {
        this.name = void 0;
        this.playwrightFunction = void 0;
        this.source = void 0;
        this.needsHandle = void 0;
        this.name = name;
        this.playwrightFunction = playwrightFunction;
        this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle})`;
        this.needsHandle = needsHandle;
      }
      static async dispatch(page, payload, context) {
        const {
          name,
          seq,
          args
        } = JSON.parse(payload);
        try {
          (0, _utils.assert)(context.world);
          const binding = page.getBinding(name);
          let result;
          if (binding.needsHandle) {
            const handle = await context.evaluateHandle(takeHandle, {
              name,
              seq
            }).catch((e) => null);
            result = await binding.playwrightFunction({
              frame: context.frame,
              page,
              context: page._browserContext
            }, handle);
          } else {
            result = await binding.playwrightFunction({
              frame: context.frame,
              page,
              context: page._browserContext
            }, ...args);
          }
          context.evaluate(deliverResult, {
            name,
            seq,
            result
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        } catch (error2) {
          if ((0, _utils.isError)(error2))
            context.evaluate(deliverError, {
              name,
              seq,
              message: error2.message,
              stack: error2.stack
            }).catch((e) => _debugLogger.debugLogger.log("error", e));
          else
            context.evaluate(deliverErrorValue, {
              name,
              seq,
              error: error2
            }).catch((e) => _debugLogger.debugLogger.log("error", e));
        }
        function takeHandle(arg) {
          const handle = globalThis[arg.name]["handles"].get(arg.seq);
          globalThis[arg.name]["handles"].delete(arg.seq);
          return handle;
        }
        function deliverResult(arg) {
          globalThis[arg.name]["callbacks"].get(arg.seq).resolve(arg.result);
          globalThis[arg.name]["callbacks"].delete(arg.seq);
        }
        function deliverError(arg) {
          const error2 = new Error(arg.message);
          error2.stack = arg.stack;
          globalThis[arg.name]["callbacks"].get(arg.seq).reject(error2);
          globalThis[arg.name]["callbacks"].delete(arg.seq);
        }
        function deliverErrorValue(arg) {
          globalThis[arg.name]["callbacks"].get(arg.seq).reject(arg.error);
          globalThis[arg.name]["callbacks"].delete(arg.seq);
        }
      }
    };
    exports.PageBinding = PageBinding;
    function addPageBinding(bindingName, needsHandle) {
      const binding = globalThis[bindingName];
      if (binding.__installed)
        return;
      globalThis[bindingName] = (...args) => {
        const me = globalThis[bindingName];
        if (needsHandle && args.slice(1).some((arg) => arg !== void 0))
          throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
        let callbacks = me["callbacks"];
        if (!callbacks) {
          callbacks = new Map();
          me["callbacks"] = callbacks;
        }
        const seq = (me["lastSeq"] || 0) + 1;
        me["lastSeq"] = seq;
        let handles = me["handles"];
        if (!handles) {
          handles = new Map();
          me["handles"] = handles;
        }
        const promise = new Promise((resolve3, reject) => callbacks.set(seq, {
          resolve: resolve3,
          reject
        }));
        if (needsHandle) {
          handles.set(seq, args[0]);
          binding(JSON.stringify({
            name: bindingName,
            seq
          }));
        } else {
          binding(JSON.stringify({
            name: bindingName,
            seq,
            args
          }));
        }
        return promise;
      };
      globalThis[bindingName].__installed = true;
    }
    var FrameThrottler = class {
      constructor(nonThrottledFrames, interval) {
        this._acks = [];
        this._interval = void 0;
        this._nonThrottledFrames = void 0;
        this._budget = void 0;
        this._intervalId = void 0;
        this._nonThrottledFrames = nonThrottledFrames;
        this._budget = nonThrottledFrames;
        this._interval = interval;
      }
      setEnabled(enabled) {
        if (enabled) {
          if (this._intervalId)
            clearInterval(this._intervalId);
          this._intervalId = setInterval(() => this._tick(), this._interval);
        } else if (this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
      }
      recharge() {
        for (const ack of this._acks)
          ack();
        this._acks = [];
        this._budget = this._nonThrottledFrames;
      }
      ack(ack) {
        if (!this._intervalId) {
          ack();
          return;
        }
        if (--this._budget > 0) {
          ack();
          return;
        }
        this._acks.push(ack);
      }
      _tick() {
        var _this$_acks$shift;
        (_this$_acks$shift = this._acks.shift()) === null || _this$_acks$shift === void 0 ? void 0 : _this$_acks$shift();
      }
    };
  }
});

// node_modules/playwright-core/lib/protocol/channels.js
var require_channels = __commonJS({
  "node_modules/playwright-core/lib/protocol/channels.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pausesBeforeInputActions = exports.commandsWithTracingSnapshots = void 0;
    var commandsWithTracingSnapshots = new Set(["EventTarget.waitForEventInfo", "BrowserContext.waitForEventInfo", "Page.waitForEventInfo", "WebSocket.waitForEventInfo", "ElectronApplication.waitForEventInfo", "AndroidDevice.waitForEventInfo", "Page.goBack", "Page.goForward", "Page.reload", "Page.setViewportSize", "Page.keyboardDown", "Page.keyboardUp", "Page.keyboardInsertText", "Page.keyboardType", "Page.keyboardPress", "Page.mouseMove", "Page.mouseDown", "Page.mouseUp", "Page.mouseClick", "Page.mouseWheel", "Page.touchscreenTap", "Frame.evalOnSelector", "Frame.evalOnSelectorAll", "Frame.addScriptTag", "Frame.addStyleTag", "Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.dispatchEvent", "Frame.evaluateExpression", "Frame.evaluateExpressionHandle", "Frame.fill", "Frame.focus", "Frame.getAttribute", "Frame.goto", "Frame.hover", "Frame.innerHTML", "Frame.innerText", "Frame.inputValue", "Frame.isChecked", "Frame.isDisabled", "Frame.isEnabled", "Frame.isHidden", "Frame.isVisible", "Frame.isEditable", "Frame.press", "Frame.selectOption", "Frame.setContent", "Frame.setInputFiles", "Frame.tap", "Frame.textContent", "Frame.type", "Frame.uncheck", "Frame.waitForTimeout", "Frame.waitForFunction", "Frame.waitForSelector", "Frame.expect", "JSHandle.evaluateExpression", "ElementHandle.evaluateExpression", "JSHandle.evaluateExpressionHandle", "ElementHandle.evaluateExpressionHandle", "ElementHandle.evalOnSelector", "ElementHandle.evalOnSelectorAll", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.dispatchEvent", "ElementHandle.fill", "ElementHandle.hover", "ElementHandle.innerHTML", "ElementHandle.innerText", "ElementHandle.inputValue", "ElementHandle.isChecked", "ElementHandle.isDisabled", "ElementHandle.isEditable", "ElementHandle.isEnabled", "ElementHandle.isHidden", "ElementHandle.isVisible", "ElementHandle.press", "ElementHandle.scrollIntoViewIfNeeded", "ElementHandle.selectOption", "ElementHandle.selectText", "ElementHandle.setInputFiles", "ElementHandle.tap", "ElementHandle.textContent", "ElementHandle.type", "ElementHandle.uncheck", "ElementHandle.waitForElementState", "ElementHandle.waitForSelector"]);
    exports.commandsWithTracingSnapshots = commandsWithTracingSnapshots;
    var pausesBeforeInputActions = new Set(["Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.fill", "Frame.hover", "Frame.press", "Frame.selectOption", "Frame.setInputFiles", "Frame.tap", "Frame.type", "Frame.uncheck", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.fill", "ElementHandle.hover", "ElementHandle.press", "ElementHandle.selectOption", "ElementHandle.setInputFiles", "ElementHandle.tap", "ElementHandle.type", "ElementHandle.uncheck"]);
    exports.pausesBeforeInputActions = pausesBeforeInputActions;
  }
});

// node_modules/playwright-core/lib/server/supplements/debugger.js
var require_debugger = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/debugger.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Debugger = void 0;
    var _events = __require("events");
    var _utils = require_utils();
    var _debugLogger = require_debugLogger();
    var _channels = require_channels();
    var symbol = Symbol("Debugger");
    var Debugger = class extends _events.EventEmitter {
      constructor(context) {
        super();
        this._pauseOnNextStatement = false;
        this._pausedCallsMetadata = new Map();
        this._enabled = void 0;
        this._context = void 0;
        this._muted = false;
        this._context = context;
        this._context[symbol] = this;
        this._enabled = (0, _utils.debugMode)() === "inspector";
        if (this._enabled)
          this.pauseOnNextStatement();
      }
      static lookup(context) {
        if (!context)
          return;
        return context[symbol];
      }
      async setMuted(muted) {
        this._muted = muted;
      }
      async onBeforeCall(sdkObject, metadata) {
        if (this._muted)
          return;
        if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseBeforeStep(metadata))
          await this.pause(sdkObject, metadata);
      }
      async onBeforeInputAction(sdkObject, metadata) {
        if (this._muted)
          return;
        if (this._enabled && this._pauseOnNextStatement)
          await this.pause(sdkObject, metadata);
      }
      async onCallLog(logName, message, sdkObject, metadata) {
        _debugLogger.debugLogger.log(logName, message);
      }
      async pause(sdkObject, metadata) {
        if (this._muted)
          return;
        this._enabled = true;
        metadata.pauseStartTime = (0, _utils.monotonicTime)();
        const result = new Promise((resolve3) => {
          this._pausedCallsMetadata.set(metadata, {
            resolve: resolve3,
            sdkObject
          });
        });
        this.emit(Debugger.Events.PausedStateChanged);
        return result;
      }
      resume(step) {
        this._pauseOnNextStatement = step;
        const endTime = (0, _utils.monotonicTime)();
        for (const [metadata, {
          resolve: resolve3
        }] of this._pausedCallsMetadata) {
          metadata.pauseEndTime = endTime;
          resolve3();
        }
        this._pausedCallsMetadata.clear();
        this.emit(Debugger.Events.PausedStateChanged);
      }
      pauseOnNextStatement() {
        this._pauseOnNextStatement = true;
      }
      isPaused(metadata) {
        if (metadata)
          return this._pausedCallsMetadata.has(metadata);
        return !!this._pausedCallsMetadata.size;
      }
      pausedDetails() {
        const result = [];
        for (const [metadata, {
          sdkObject
        }] of this._pausedCallsMetadata)
          result.push({
            metadata,
            sdkObject
          });
        return result;
      }
    };
    exports.Debugger = Debugger;
    Debugger.Events = {
      PausedStateChanged: "pausedstatechanged"
    };
    function shouldPauseOnCall(sdkObject, metadata) {
      var _sdkObject$attributio;
      if (!((_sdkObject$attributio = sdkObject.attribution.browser) !== null && _sdkObject$attributio !== void 0 && _sdkObject$attributio.options.headful) && !(0, _utils.isUnderTest)())
        return false;
      return metadata.method === "pause";
    }
    function shouldPauseBeforeStep(metadata) {
      if (metadata.method === "close")
        return true;
      if (metadata.method === "waitForSelector" || metadata.method === "waitForEventInfo")
        return false;
      const step = metadata.type + "." + metadata.method;
      return _channels.commandsWithTracingSnapshots.has(step) && !_channels.pausesBeforeInputActions.has(metadata.type + "." + metadata.method);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports, module) {
    init_shims();
    var Buffer2 = __require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module.exports = crc32;
  }
});

// node_modules/yazl/index.js
var require_yazl = __commonJS({
  "node_modules/yazl/index.js"(exports) {
    init_shims();
    var fs2 = __require("fs");
    var Transform = __require("stream").Transform;
    var PassThrough2 = __require("stream").PassThrough;
    var zlib2 = __require("zlib");
    var util = __require("util");
    var EventEmitter = __require("events").EventEmitter;
    var crc32 = require_buffer_crc32();
    exports.ZipFile = ZipFile;
    exports.dateToDosDateTime = dateToDosDateTime;
    util.inherits(ZipFile, EventEmitter);
    function ZipFile() {
      this.outputStream = new PassThrough2();
      this.entries = [];
      this.outputStreamCursor = 0;
      this.ended = false;
      this.allDone = false;
      this.forceZip64Eocd = false;
    }
    ZipFile.prototype.addFile = function(realPath, metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options2 == null)
        options2 = {};
      var entry = new Entry(metadataPath, false, options2);
      self2.entries.push(entry);
      fs2.stat(realPath, function(err, stats) {
        if (err)
          return self2.emit("error", err);
        if (!stats.isFile())
          return self2.emit("error", new Error("not a file: " + realPath));
        entry.uncompressedSize = stats.size;
        if (options2.mtime == null)
          entry.setLastModDate(stats.mtime);
        if (options2.mode == null)
          entry.setFileAttributesMode(stats.mode);
        entry.setFileDataPumpFunction(function() {
          var readStream = fs2.createReadStream(realPath);
          entry.state = Entry.FILE_DATA_IN_PROGRESS;
          readStream.on("error", function(err2) {
            self2.emit("error", err2);
          });
          pumpFileDataReadStream(self2, entry, readStream);
        });
        pumpEntries(self2);
      });
    };
    ZipFile.prototype.addReadStream = function(readStream, metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options2 == null)
        options2 = {};
      var entry = new Entry(metadataPath, false, options2);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        entry.state = Entry.FILE_DATA_IN_PROGRESS;
        pumpFileDataReadStream(self2, entry, readStream);
      });
      pumpEntries(self2);
    };
    ZipFile.prototype.addBuffer = function(buffer, metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (buffer.length > 1073741823)
        throw new Error("buffer too large: " + buffer.length + " > " + 1073741823);
      if (options2 == null)
        options2 = {};
      if (options2.size != null)
        throw new Error("options.size not allowed");
      var entry = new Entry(metadataPath, false, options2);
      entry.uncompressedSize = buffer.length;
      entry.crc32 = crc32.unsigned(buffer);
      entry.crcAndFileSizeKnown = true;
      self2.entries.push(entry);
      if (!entry.compress) {
        setCompressedBuffer(buffer);
      } else {
        zlib2.deflateRaw(buffer, function(err, compressedBuffer) {
          setCompressedBuffer(compressedBuffer);
        });
      }
      function setCompressedBuffer(compressedBuffer) {
        entry.compressedSize = compressedBuffer.length;
        entry.setFileDataPumpFunction(function() {
          writeToOutputStream(self2, compressedBuffer);
          writeToOutputStream(self2, entry.getDataDescriptor());
          entry.state = Entry.FILE_DATA_DONE;
          setImmediate(function() {
            pumpEntries(self2);
          });
        });
        pumpEntries(self2);
      }
    };
    ZipFile.prototype.addEmptyDirectory = function(metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, true);
      if (options2 == null)
        options2 = {};
      if (options2.size != null)
        throw new Error("options.size not allowed");
      if (options2.compress != null)
        throw new Error("options.compress not allowed");
      var entry = new Entry(metadataPath, true, options2);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
      pumpEntries(self2);
    };
    var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
    ZipFile.prototype.end = function(options2, finalSizeCallback) {
      if (typeof options2 === "function") {
        finalSizeCallback = options2;
        options2 = null;
      }
      if (options2 == null)
        options2 = {};
      if (this.ended)
        return;
      this.ended = true;
      this.finalSizeCallback = finalSizeCallback;
      this.forceZip64Eocd = !!options2.forceZip64Format;
      if (options2.comment) {
        if (typeof options2.comment === "string") {
          this.comment = encodeCp437(options2.comment);
        } else {
          this.comment = options2.comment;
        }
        if (this.comment.length > 65535)
          throw new Error("comment is too large");
        if (bufferIncludes(this.comment, eocdrSignatureBuffer))
          throw new Error("comment contains end of central directory record signature");
      } else {
        this.comment = EMPTY_BUFFER;
      }
      pumpEntries(this);
    };
    function writeToOutputStream(self2, buffer) {
      self2.outputStream.write(buffer);
      self2.outputStreamCursor += buffer.length;
    }
    function pumpFileDataReadStream(self2, entry, readStream) {
      var crc32Watcher = new Crc32Watcher();
      var uncompressedSizeCounter = new ByteCounter();
      var compressor = entry.compress ? new zlib2.DeflateRaw() : new PassThrough2();
      var compressedSizeCounter = new ByteCounter();
      readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
      compressedSizeCounter.on("end", function() {
        entry.crc32 = crc32Watcher.crc32;
        if (entry.uncompressedSize == null) {
          entry.uncompressedSize = uncompressedSizeCounter.byteCount;
        } else {
          if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount)
            return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
        }
        entry.compressedSize = compressedSizeCounter.byteCount;
        self2.outputStreamCursor += entry.compressedSize;
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
    }
    function pumpEntries(self2) {
      if (self2.allDone)
        return;
      if (self2.ended && self2.finalSizeCallback != null) {
        var finalSize = calculateFinalSize(self2);
        if (finalSize != null) {
          self2.finalSizeCallback(finalSize);
          self2.finalSizeCallback = null;
        }
      }
      var entry = getFirstNotDoneEntry();
      function getFirstNotDoneEntry() {
        for (var i = 0; i < self2.entries.length; i++) {
          var entry2 = self2.entries[i];
          if (entry2.state < Entry.FILE_DATA_DONE)
            return entry2;
        }
        return null;
      }
      if (entry != null) {
        if (entry.state < Entry.READY_TO_PUMP_FILE_DATA)
          return;
        if (entry.state === Entry.FILE_DATA_IN_PROGRESS)
          return;
        entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
        var localFileHeader = entry.getLocalFileHeader();
        writeToOutputStream(self2, localFileHeader);
        entry.doFileDataPump();
      } else {
        if (self2.ended) {
          self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
          self2.entries.forEach(function(entry2) {
            var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
            writeToOutputStream(self2, centralDirectoryRecord);
          });
          writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
          self2.outputStream.end();
          self2.allDone = true;
        }
      }
    }
    function calculateFinalSize(self2) {
      var pretendOutputCursor = 0;
      var centralDirectorySize = 0;
      for (var i = 0; i < self2.entries.length; i++) {
        var entry = self2.entries[i];
        if (entry.compress)
          return -1;
        if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
          if (entry.uncompressedSize == null)
            return -1;
        } else {
          if (entry.uncompressedSize == null)
            return null;
        }
        entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
        var useZip64Format = entry.useZip64Format();
        pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
        pretendOutputCursor += entry.uncompressedSize;
        if (!entry.crcAndFileSizeKnown) {
          if (useZip64Format) {
            pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
          } else {
            pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
          }
        }
        centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
        if (useZip64Format) {
          centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
        }
      }
      var endOfCentralDirectorySize = 0;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
        endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
      }
      endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
      return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
    }
    var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
    var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
    var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
    function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
      var needZip64Format = false;
      var normalEntriesLength = self2.entries.length;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
        normalEntriesLength = 65535;
        needZip64Format = true;
      }
      var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
      var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
      if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
        normalSizeOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
      if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
        normalOffsetOfStartOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      if (actuallyJustTellMeHowLongItWouldBe) {
        if (needZip64Format) {
          return ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE + END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        } else {
          return END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        }
      }
      var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
      eocdrBuffer.writeUInt32LE(101010256, 0);
      eocdrBuffer.writeUInt16LE(0, 4);
      eocdrBuffer.writeUInt16LE(0, 6);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
      eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
      eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
      eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
      self2.comment.copy(eocdrBuffer, 22);
      if (!needZip64Format)
        return eocdrBuffer;
      var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
      zip64EocdrBuffer.writeUInt32LE(101075792, 0);
      writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
      zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
      zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
      zip64EocdrBuffer.writeUInt32LE(0, 16);
      zip64EocdrBuffer.writeUInt32LE(0, 20);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
      writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
      writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
      var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
      zip64EocdlBuffer.writeUInt32LE(117853008, 0);
      zip64EocdlBuffer.writeUInt32LE(0, 4);
      writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
      zip64EocdlBuffer.writeUInt32LE(1, 16);
      return Buffer.concat([
        zip64EocdrBuffer,
        zip64EocdlBuffer,
        eocdrBuffer
      ]);
    }
    function validateMetadataPath(metadataPath, isDirectory) {
      if (metadataPath === "")
        throw new Error("empty metadataPath");
      metadataPath = metadataPath.replace(/\\/g, "/");
      if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath))
        throw new Error("absolute path: " + metadataPath);
      if (metadataPath.split("/").indexOf("..") !== -1)
        throw new Error("invalid relative path: " + metadataPath);
      var looksLikeDirectory = /\/$/.test(metadataPath);
      if (isDirectory) {
        if (!looksLikeDirectory)
          metadataPath += "/";
      } else {
        if (looksLikeDirectory)
          throw new Error("file path cannot end with '/': " + metadataPath);
      }
      return metadataPath;
    }
    var EMPTY_BUFFER = bufferAlloc(0);
    function Entry(metadataPath, isDirectory, options2) {
      this.utf8FileName = bufferFrom(metadataPath);
      if (this.utf8FileName.length > 65535)
        throw new Error("utf8 file name too long. " + utf8FileName.length + " > " + 65535);
      this.isDirectory = isDirectory;
      this.state = Entry.WAITING_FOR_METADATA;
      this.setLastModDate(options2.mtime != null ? options2.mtime : new Date());
      if (options2.mode != null) {
        this.setFileAttributesMode(options2.mode);
      } else {
        this.setFileAttributesMode(isDirectory ? 16893 : 33204);
      }
      if (isDirectory) {
        this.crcAndFileSizeKnown = true;
        this.crc32 = 0;
        this.uncompressedSize = 0;
        this.compressedSize = 0;
      } else {
        this.crcAndFileSizeKnown = false;
        this.crc32 = null;
        this.uncompressedSize = null;
        this.compressedSize = null;
        if (options2.size != null)
          this.uncompressedSize = options2.size;
      }
      if (isDirectory) {
        this.compress = false;
      } else {
        this.compress = true;
        if (options2.compress != null)
          this.compress = !!options2.compress;
      }
      this.forceZip64Format = !!options2.forceZip64Format;
      if (options2.fileComment) {
        if (typeof options2.fileComment === "string") {
          this.fileComment = bufferFrom(options2.fileComment, "utf-8");
        } else {
          this.fileComment = options2.fileComment;
        }
        if (this.fileComment.length > 65535)
          throw new Error("fileComment is too large");
      } else {
        this.fileComment = EMPTY_BUFFER;
      }
    }
    Entry.WAITING_FOR_METADATA = 0;
    Entry.READY_TO_PUMP_FILE_DATA = 1;
    Entry.FILE_DATA_IN_PROGRESS = 2;
    Entry.FILE_DATA_DONE = 3;
    Entry.prototype.setLastModDate = function(date) {
      var dosDateTime = dateToDosDateTime(date);
      this.lastModFileTime = dosDateTime.time;
      this.lastModFileDate = dosDateTime.date;
    };
    Entry.prototype.setFileAttributesMode = function(mode) {
      if ((mode & 65535) !== mode)
        throw new Error("invalid mode. expected: 0 <= " + mode + " <= " + 65535);
      this.externalFileAttributes = mode << 16 >>> 0;
    };
    Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
      this.doFileDataPump = doFileDataPump;
      this.state = Entry.READY_TO_PUMP_FILE_DATA;
    };
    Entry.prototype.useZip64Format = function() {
      return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
    };
    var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
    var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
    var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
    var VERSION_MADE_BY = 3 << 8 | 63;
    var FILE_NAME_IS_UTF8 = 1 << 11;
    var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
    Entry.prototype.getLocalFileHeader = function() {
      var crc322 = 0;
      var compressedSize = 0;
      var uncompressedSize = 0;
      if (this.crcAndFileSizeKnown) {
        crc322 = this.crc32;
        compressedSize = this.compressedSize;
        uncompressedSize = this.uncompressedSize;
      }
      var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      fixedSizeStuff.writeUInt32LE(67324752, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
      fixedSizeStuff.writeUInt32LE(crc322, 14);
      fixedSizeStuff.writeUInt32LE(compressedSize, 18);
      fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
      fixedSizeStuff.writeUInt16LE(0, 28);
      return Buffer.concat([
        fixedSizeStuff,
        this.utf8FileName
      ]);
    };
    var DATA_DESCRIPTOR_SIZE = 16;
    var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
    Entry.prototype.getDataDescriptor = function() {
      if (this.crcAndFileSizeKnown) {
        return EMPTY_BUFFER;
      }
      if (!this.useZip64Format()) {
        var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        buffer.writeUInt32LE(this.compressedSize, 8);
        buffer.writeUInt32LE(this.uncompressedSize, 12);
        return buffer;
      } else {
        var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        writeUInt64LE(buffer, this.compressedSize, 8);
        writeUInt64LE(buffer, this.uncompressedSize, 16);
        return buffer;
      }
    };
    var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
    var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
    Entry.prototype.getCentralDirectoryRecord = function() {
      var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      var normalCompressedSize = this.compressedSize;
      var normalUncompressedSize = this.uncompressedSize;
      var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
      var versionNeededToExtract;
      var zeiefBuffer;
      if (this.useZip64Format()) {
        normalCompressedSize = 4294967295;
        normalUncompressedSize = 4294967295;
        normalRelativeOffsetOfLocalHeader = 4294967295;
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
        zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
        zeiefBuffer.writeUInt16LE(1, 0);
        zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
        writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
        writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
        writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
      } else {
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
        zeiefBuffer = EMPTY_BUFFER;
      }
      fixedSizeStuff.writeUInt32LE(33639248, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
      fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
      fixedSizeStuff.writeUInt32LE(this.crc32, 16);
      fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
      fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
      fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
      fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
      fixedSizeStuff.writeUInt16LE(0, 34);
      fixedSizeStuff.writeUInt16LE(0, 36);
      fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
      fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
      return Buffer.concat([
        fixedSizeStuff,
        this.utf8FileName,
        zeiefBuffer,
        this.fileComment
      ]);
    };
    Entry.prototype.getCompressionMethod = function() {
      var NO_COMPRESSION = 0;
      var DEFLATE_COMPRESSION = 8;
      return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
    };
    function dateToDosDateTime(jsDate) {
      var date = 0;
      date |= jsDate.getDate() & 31;
      date |= (jsDate.getMonth() + 1 & 15) << 5;
      date |= (jsDate.getFullYear() - 1980 & 127) << 9;
      var time = 0;
      time |= Math.floor(jsDate.getSeconds() / 2);
      time |= (jsDate.getMinutes() & 63) << 5;
      time |= (jsDate.getHours() & 31) << 11;
      return { date, time };
    }
    function writeUInt64LE(buffer, n, offset) {
      var high = Math.floor(n / 4294967296);
      var low = n % 4294967296;
      buffer.writeUInt32LE(low, offset);
      buffer.writeUInt32LE(high, offset + 4);
    }
    util.inherits(ByteCounter, Transform);
    function ByteCounter(options2) {
      Transform.call(this, options2);
      this.byteCount = 0;
    }
    ByteCounter.prototype._transform = function(chunk, encoding, cb) {
      this.byteCount += chunk.length;
      cb(null, chunk);
    };
    util.inherits(Crc32Watcher, Transform);
    function Crc32Watcher(options2) {
      Transform.call(this, options2);
      this.crc32 = 0;
    }
    Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
      this.crc32 = crc32.unsigned(chunk, this.crc32);
      cb(null, chunk);
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    if (cp437.length !== 256)
      throw new Error("assertion failure");
    var reverseCp437 = null;
    function encodeCp437(string) {
      if (/^[\x20-\x7e]*$/.test(string)) {
        return bufferFrom(string, "utf-8");
      }
      if (reverseCp437 == null) {
        reverseCp437 = {};
        for (var i = 0; i < cp437.length; i++) {
          reverseCp437[cp437[i]] = i;
        }
      }
      var result = bufferAlloc(string.length);
      for (var i = 0; i < string.length; i++) {
        var b = reverseCp437[string[i]];
        if (b == null)
          throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
        result[i] = b;
      }
      return result;
    }
    function bufferAlloc(size) {
      bufferAlloc = modern;
      try {
        return bufferAlloc(size);
      } catch (e) {
        bufferAlloc = legacy;
        return bufferAlloc(size);
      }
      function modern(size2) {
        return Buffer.allocUnsafe(size2);
      }
      function legacy(size2) {
        return new Buffer(size2);
      }
    }
    function bufferFrom(something, encoding) {
      bufferFrom = modern;
      try {
        return bufferFrom(something, encoding);
      } catch (e) {
        bufferFrom = legacy;
        return bufferFrom(something, encoding);
      }
      function modern(something2, encoding2) {
        return Buffer.from(something2, encoding2);
      }
      function legacy(something2, encoding2) {
        return new Buffer(something2, encoding2);
      }
    }
    function bufferIncludes(buffer, content) {
      bufferIncludes = modern;
      try {
        return bufferIncludes(buffer, content);
      } catch (e) {
        bufferIncludes = legacy;
        return bufferIncludes(buffer, content);
      }
      function modern(buffer2, content2) {
        return buffer2.includes(content2);
      }
      function legacy(buffer2, content2) {
        for (var i = 0; i <= buffer2.length - content2.length; i++) {
          for (var j = 0; ; j++) {
            if (j === content2.length)
              return true;
            if (buffer2[i + j] !== content2[j])
              break;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/artifact.js
var require_artifact = __commonJS({
  "node_modules/playwright-core/lib/server/artifact.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Artifact = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var _utils = require_utils();
    var _async = require_async();
    var _instrumentation = require_instrumentation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Artifact = class extends _instrumentation.SdkObject {
      constructor(parent, localPath, unaccessibleErrorMessage, cancelCallback) {
        super(parent, "artifact");
        this._localPath = void 0;
        this._unaccessibleErrorMessage = void 0;
        this._cancelCallback = void 0;
        this._finishedPromise = new _async.ManualPromise();
        this._saveCallbacks = [];
        this._finished = false;
        this._deleted = false;
        this._failureError = null;
        this._localPath = localPath;
        this._unaccessibleErrorMessage = unaccessibleErrorMessage;
        this._cancelCallback = cancelCallback;
      }
      finishedPromise() {
        return this._finishedPromise;
      }
      localPath() {
        return this._localPath;
      }
      async localPathAfterFinished() {
        if (this._unaccessibleErrorMessage)
          throw new Error(this._unaccessibleErrorMessage);
        await this._finishedPromise;
        if (this._failureError)
          return null;
        return this._localPath;
      }
      saveAs(saveCallback) {
        if (this._unaccessibleErrorMessage)
          throw new Error(this._unaccessibleErrorMessage);
        if (this._deleted)
          throw new Error(`File already deleted. Save before deleting.`);
        if (this._failureError)
          throw new Error(`File not found on disk. Check download.failure() for details.`);
        if (this._finished) {
          saveCallback(this._localPath).catch((e) => {
          });
          return;
        }
        this._saveCallbacks.push(saveCallback);
      }
      async failureError() {
        if (this._unaccessibleErrorMessage)
          return this._unaccessibleErrorMessage;
        await this._finishedPromise;
        return this._failureError;
      }
      async cancel() {
        (0, _utils.assert)(this._cancelCallback !== void 0);
        return this._cancelCallback();
      }
      async delete() {
        if (this._unaccessibleErrorMessage)
          return;
        const fileName = await this.localPathAfterFinished();
        if (this._deleted)
          return;
        this._deleted = true;
        if (fileName)
          await _fs.default.promises.unlink(fileName).catch((e) => {
          });
      }
      async deleteOnContextClose() {
        if (this._deleted)
          return;
        this._deleted = true;
        if (!this._unaccessibleErrorMessage)
          await _fs.default.promises.unlink(this._localPath).catch((e) => {
          });
        await this.reportFinished("File deleted upon browser context closure.");
      }
      async reportFinished(error2) {
        if (this._finished)
          return;
        this._finished = true;
        this._failureError = error2 || null;
        if (error2) {
          for (const callback of this._saveCallbacks)
            await callback("", error2);
        } else {
          for (const callback of this._saveCallbacks)
            await callback(this._localPath);
        }
        this._saveCallbacks = [];
        this._finishedPromise.resolve();
      }
    };
    exports.Artifact = Artifact;
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js
var require_snapshotterInjected = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.frameSnapshotStreamer = frameSnapshotStreamer;
    function frameSnapshotStreamer(snapshotStreamer) {
      if (window[snapshotStreamer])
        return;
      const kShadowAttribute = "__playwright_shadow_root_";
      const kScrollTopAttribute = "__playwright_scroll_top_";
      const kScrollLeftAttribute = "__playwright_scroll_left_";
      const kStyleSheetAttribute = "__playwright_style_sheet_";
      const kBlobUrlPrefix = "http://playwright.bloburl/#";
      const kSnapshotFrameId = Symbol("__playwright_snapshot_frameid_");
      const kCachedData = Symbol("__playwright_snapshot_cache_");
      const kEndOfList = Symbol("__playwright_end_of_list_");
      function resetCachedData(obj) {
        delete obj[kCachedData];
      }
      function ensureCachedData(obj) {
        if (!obj[kCachedData])
          obj[kCachedData] = {};
        return obj[kCachedData];
      }
      function removeHash(url) {
        try {
          const u = new URL(url);
          u.hash = "";
          return u.toString();
        } catch (e) {
          return url;
        }
      }
      class Streamer {
        constructor() {
          this._removeNoScript = true;
          this._lastSnapshotNumber = 0;
          this._staleStyleSheets = new Set();
          this._readingStyleSheet = false;
          this._fakeBase = void 0;
          this._observer = void 0;
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "insertRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "deleteRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "addRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "removeRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "rules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "cssRules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "replaceSync", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeAsyncMethod(window.CSSStyleSheet.prototype, "replace", (sheet) => this._invalidateStyleSheet(sheet));
          this._fakeBase = document.createElement("base");
          this._observer = new MutationObserver((list2) => this._handleMutations(list2));
          const observerConfig = {
            attributes: true,
            subtree: true
          };
          this._observer.observe(document, observerConfig);
        }
        _interceptNativeMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = function(...args) {
            const result = native.call(this, ...args);
            cb(this, result);
            return result;
          };
        }
        _interceptNativeAsyncMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = async function(...args) {
            const result = await native.call(this, ...args);
            cb(this, result);
            return result;
          };
        }
        _interceptNativeGetter(obj, prop, cb) {
          const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          Object.defineProperty(obj, prop, __spreadProps(__spreadValues({}, descriptor), {
            get: function() {
              const result = descriptor.get.call(this);
              cb(this, result);
              return result;
            }
          }));
        }
        _handleMutations(list2) {
          for (const mutation of list2)
            ensureCachedData(mutation.target).attributesCached = void 0;
        }
        _invalidateStyleSheet(sheet) {
          if (this._readingStyleSheet)
            return;
          this._staleStyleSheets.add(sheet);
        }
        _updateStyleElementStyleSheetTextIfNeeded(sheet, forceText) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet) || forceText && data.cssText === void 0) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
            } catch (e) {
              data.cssText = "";
            }
          }
          return data.cssText;
        }
        _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet)) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
              data.cssRef = snapshotNumber;
              return data.cssText;
            } catch (e) {
            }
          }
          return data.cssRef === void 0 ? void 0 : snapshotNumber - data.cssRef;
        }
        markIframe(iframeElement, frameId) {
          iframeElement[kSnapshotFrameId] = frameId;
        }
        reset() {
          this._staleStyleSheets.clear();
          const visitNode = (node) => {
            resetCachedData(node);
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (element.shadowRoot)
                visitNode(element.shadowRoot);
            }
            for (let child = node.firstChild; child; child = child.nextSibling)
              visitNode(child);
          };
          visitNode(document.documentElement);
          visitNode(this._fakeBase);
        }
        _sanitizeUrl(url) {
          if (url.startsWith("javascript:"))
            return "";
          if (url.startsWith("blob:"))
            return kBlobUrlPrefix + url;
          return url;
        }
        _sanitizeSrcSet(srcset) {
          return srcset.split(",").map((src2) => {
            src2 = src2.trim();
            const spaceIndex = src2.lastIndexOf(" ");
            if (spaceIndex === -1)
              return this._sanitizeUrl(src2);
            return this._sanitizeUrl(src2.substring(0, spaceIndex).trim()) + src2.substring(spaceIndex);
          }).join(", ");
        }
        _resolveUrl(base2, url) {
          if (url === "")
            return "";
          try {
            return new URL(url, base2).href;
          } catch (e) {
            return url;
          }
        }
        _getSheetBase(sheet) {
          let rootSheet = sheet;
          while (rootSheet.parentStyleSheet)
            rootSheet = rootSheet.parentStyleSheet;
          if (rootSheet.ownerNode)
            return rootSheet.ownerNode.baseURI;
          return document.baseURI;
        }
        _getSheetText(sheet) {
          this._readingStyleSheet = true;
          try {
            const rules = [];
            for (const rule of sheet.cssRules)
              rules.push(rule.cssText);
            return rules.join("\n");
          } finally {
            this._readingStyleSheet = false;
          }
        }
        captureSnapshot() {
          const timestamp = performance.now();
          const snapshotNumber = ++this._lastSnapshotNumber;
          let nodeCounter = 0;
          let shadowDomNesting = 0;
          this._handleMutations(this._observer.takeRecords());
          const visitNode = (node) => {
            const nodeType = node.nodeType;
            const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? "template" : node.nodeName;
            if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE)
              return;
            if (nodeName === "SCRIPT")
              return;
            if (nodeName === "LINK" && nodeType === Node.ELEMENT_NODE) {
              var _getAttribute;
              const rel = (_getAttribute = node.getAttribute("rel")) === null || _getAttribute === void 0 ? void 0 : _getAttribute.toLowerCase();
              if (rel === "preload" || rel === "prefetch")
                return;
            }
            if (this._removeNoScript && nodeName === "NOSCRIPT")
              return;
            if (nodeName === "META" && node.httpEquiv.toLowerCase() === "content-security-policy")
              return;
            const data = ensureCachedData(node);
            const values = [];
            let equals = !!data.cached;
            let extraNodes = 0;
            const expectValue = (value) => {
              equals = equals && data.cached[values.length] === value;
              values.push(value);
            };
            const checkAndReturn = (n) => {
              data.attributesCached = true;
              if (equals)
                return {
                  equals: true,
                  n: [[snapshotNumber - data.ref[0], data.ref[1]]]
                };
              nodeCounter += extraNodes;
              data.ref = [snapshotNumber, nodeCounter++];
              data.cached = values;
              return {
                equals: false,
                n
              };
            };
            if (nodeType === Node.TEXT_NODE) {
              const value = node.nodeValue || "";
              expectValue(value);
              return checkAndReturn(value);
            }
            if (nodeName === "STYLE") {
              const sheet = node.sheet;
              let cssText;
              if (sheet)
                cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
              cssText = cssText || node.textContent || "";
              expectValue(cssText);
              extraNodes++;
              return checkAndReturn(["style", {}, cssText]);
            }
            const attrs = {};
            const result2 = [nodeName, attrs];
            const visitChild = (child) => {
              const snapshot = visitNode(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            const visitChildStyleSheet = (child) => {
              const snapshot = visitStyleSheet(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            if (nodeType === Node.DOCUMENT_FRAGMENT_NODE)
              attrs[kShadowAttribute] = "open";
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (nodeName === "INPUT") {
                const value = element.value;
                expectValue("value");
                expectValue(value);
                attrs["value"] = value;
                if (element.checked) {
                  expectValue("checked");
                  attrs["checked"] = "";
                }
              }
              if (element.scrollTop) {
                expectValue(kScrollTopAttribute);
                expectValue(element.scrollTop);
                attrs[kScrollTopAttribute] = "" + element.scrollTop;
              }
              if (element.scrollLeft) {
                expectValue(kScrollLeftAttribute);
                expectValue(element.scrollLeft);
                attrs[kScrollLeftAttribute] = "" + element.scrollLeft;
              }
              if (element.shadowRoot) {
                ++shadowDomNesting;
                visitChild(element.shadowRoot);
                --shadowDomNesting;
              }
            }
            if (nodeName === "TEXTAREA") {
              const value = node.value;
              expectValue(value);
              extraNodes++;
              result2.push(value);
            } else {
              if (nodeName === "HEAD") {
                this._fakeBase.setAttribute("href", document.baseURI);
                visitChild(this._fakeBase);
              }
              for (let child = node.firstChild; child; child = child.nextSibling)
                visitChild(child);
              expectValue(kEndOfList);
              let documentOrShadowRoot = null;
              if (node.ownerDocument.documentElement === node)
                documentOrShadowRoot = node.ownerDocument;
              else if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
                documentOrShadowRoot = node;
              if (documentOrShadowRoot) {
                for (const sheet of documentOrShadowRoot.adoptedStyleSheets || [])
                  visitChildStyleSheet(sheet);
                expectValue(kEndOfList);
              }
            }
            if (nodeName === "IFRAME" || nodeName === "FRAME") {
              const element = node;
              const frameId = element[kSnapshotFrameId];
              const name = "src";
              const value = frameId ? `/snapshot/${frameId}` : "";
              expectValue(name);
              expectValue(value);
              attrs[name] = value;
            }
            if (equals && data.attributesCached && !shadowDomNesting)
              return checkAndReturn(result2);
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              for (let i = 0; i < element.attributes.length; i++) {
                const name = element.attributes[i].name;
                if (name === "value" && (nodeName === "INPUT" || nodeName === "TEXTAREA"))
                  continue;
                if (nodeName === "LINK" && name === "integrity")
                  continue;
                if (nodeName === "IFRAME" && name === "src")
                  continue;
                let value = element.attributes[i].value;
                if (name === "src" && nodeName === "IMG")
                  value = this._sanitizeUrl(value);
                else if (name === "srcset" && nodeName === "IMG")
                  value = this._sanitizeSrcSet(value);
                else if (name === "srcset" && nodeName === "SOURCE")
                  value = this._sanitizeSrcSet(value);
                else if (name === "href" && nodeName === "LINK")
                  value = this._sanitizeUrl(value);
                else if (name.startsWith("on"))
                  value = "";
                expectValue(name);
                expectValue(value);
                attrs[name] = value;
              }
              expectValue(kEndOfList);
            }
            if (result2.length === 2 && !Object.keys(attrs).length)
              result2.pop();
            return checkAndReturn(result2);
          };
          const visitStyleSheet = (sheet) => {
            const data = ensureCachedData(sheet);
            const oldCSSText = data.cssText;
            const cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet, true);
            if (cssText === oldCSSText)
              return {
                equals: true,
                n: [[snapshotNumber - data.ref[0], data.ref[1]]]
              };
            data.ref = [snapshotNumber, nodeCounter++];
            return {
              equals: false,
              n: ["template", {
                [kStyleSheetAttribute]: cssText
              }]
            };
          };
          let html;
          if (document.documentElement) {
            const {
              n
            } = visitNode(document.documentElement);
            html = n;
          } else {
            html = ["html"];
          }
          const result = {
            html,
            doctype: document.doctype ? document.doctype.name : void 0,
            resourceOverrides: [],
            viewport: {
              width: window.innerWidth,
              height: window.innerHeight
            },
            url: location.href,
            timestamp,
            collectionTime: 0
          };
          for (const sheet of this._staleStyleSheets) {
            if (sheet.href === null)
              continue;
            const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);
            if (content === void 0) {
              continue;
            }
            const base2 = this._getSheetBase(sheet);
            const url = removeHash(this._resolveUrl(base2, sheet.href));
            result.resourceOverrides.push({
              url,
              content,
              contentType: "text/css"
            });
          }
          result.collectionTime = performance.now() - result.timestamp;
          return result;
        }
      }
      window[snapshotStreamer] = new Streamer();
    }
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js
var require_snapshotter = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Snapshotter = void 0;
    var _browserContext = require_browserContext();
    var _page = require_page();
    var _eventsHelper = require_eventsHelper();
    var _debugLogger = require_debugLogger();
    var _snapshotterInjected = require_snapshotterInjected();
    var _utils = require_utils();
    var mime = _interopRequireWildcard(require_mime());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Snapshotter = class {
      constructor(context, delegate) {
        this._context = void 0;
        this._delegate = void 0;
        this._eventListeners = [];
        this._snapshotStreamer = void 0;
        this._initialized = false;
        this._started = false;
        this._context = context;
        this._delegate = delegate;
        const guid = (0, _utils.createGuid)();
        this._snapshotStreamer = "__playwright_snapshot_streamer_" + guid;
      }
      started() {
        return this._started;
      }
      async start() {
        this._started = true;
        if (!this._initialized) {
          this._initialized = true;
          await this._initialize();
        }
        await this.reset();
      }
      async reset() {
        if (this._started)
          await this._runInAllFrames(`window["${this._snapshotStreamer}"].reset()`);
      }
      async stop() {
        this._started = false;
      }
      async _initialize() {
        for (const page of this._context.pages())
          this._onPage(page);
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._onPage.bind(this))];
        const initScript = `(${_snapshotterInjected.frameSnapshotStreamer})("${this._snapshotStreamer}")`;
        await this._context._doAddInitScript(initScript);
        await this._runInAllFrames(initScript);
      }
      async _runInAllFrames(expression) {
        const frames = [];
        for (const page of this._context.pages())
          frames.push(...page.frames());
        await Promise.all(frames.map((frame) => {
          return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => _debugLogger.debugLogger.log("error", e));
        }));
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      async captureSnapshot(page, snapshotName, element) {
        const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`;
        element === null || element === void 0 ? void 0 : element.callFunctionNoReply((element2, snapshotName2) => {
          element2.setAttribute("__playwright_target__", snapshotName2);
        }, snapshotName);
        const snapshots = page.frames().map(async (frame) => {
          const data = await frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => _debugLogger.debugLogger.log("error", e));
          if (!data || !this._started)
            return;
          const snapshot = {
            snapshotName,
            pageId: page.guid,
            frameId: frame.guid,
            frameUrl: data.url,
            doctype: data.doctype,
            html: data.html,
            viewport: data.viewport,
            timestamp: (0, _utils.monotonicTime)(),
            collectionTime: data.collectionTime,
            resourceOverrides: [],
            isMainFrame: page.mainFrame() === frame
          };
          for (const {
            url,
            content,
            contentType
          } of data.resourceOverrides) {
            if (typeof content === "string") {
              const buffer = Buffer.from(content);
              const sha1 = (0, _utils.calculateSha1)(buffer) + "." + (mime.getExtension(contentType) || "dat");
              this._delegate.onSnapshotterBlob({
                sha1,
                buffer
              });
              snapshot.resourceOverrides.push({
                url,
                sha1
              });
            } else {
              snapshot.resourceOverrides.push({
                url,
                ref: content
              });
            }
          }
          this._delegate.onFrameSnapshot(snapshot);
        });
        await Promise.all(snapshots);
      }
      _onPage(page) {
        for (const frame of page.frames())
          this._annotateFrameHierarchy(frame);
        this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.FrameAttached, (frame) => this._annotateFrameHierarchy(frame)));
      }
      async _annotateFrameHierarchy(frame) {
        try {
          const frameElement = await frame.frameElement();
          const parent = frame.parentFrame();
          if (!parent)
            return;
          const context = await parent._mainContext();
          await (context === null || context === void 0 ? void 0 : context.evaluate(({
            snapshotStreamer,
            frameElement: frameElement2,
            frameId
          }) => {
            window[snapshotStreamer].markIframe(frameElement2, frameId);
          }, {
            snapshotStreamer: this._snapshotStreamer,
            frameElement,
            frameId: frame.guid
          }));
          frameElement.dispose();
        } catch (e) {
        }
      }
    };
    exports.Snapshotter = Snapshotter;
  }
});

// node_modules/playwright-core/lib/server/supplements/har/harTracer.js
var require_harTracer = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/har/harTracer.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.HarTracer = void 0;
    var _browserContext = require_browserContext();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _utils = require_utils();
    var _eventsHelper = require_eventsHelper();
    var mime = _interopRequireWildcard(require_mime());
    var _async = require_async();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FALLBACK_HTTP_VERSION = "HTTP/1.1";
    var HarTracer = class {
      constructor(context, delegate, options2) {
        this._context = void 0;
        this._barrierPromises = new Set();
        this._delegate = void 0;
        this._options = void 0;
        this._pageEntries = new Map();
        this._eventListeners = [];
        this._started = false;
        this._entrySymbol = void 0;
        this._context = context;
        this._delegate = delegate;
        this._options = options2;
        this._entrySymbol = Symbol("requestHarEntry");
      }
      start() {
        if (this._started)
          return;
        this._started = true;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, (page) => this._ensurePageEntry(page)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Request, (request) => this._onRequest(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFinished, ({
          request,
          response
        }) => this._onRequestFinished(request, response).catch(() => {
        })), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Response, (response) => this._onResponse(response))];
      }
      _entryForRequest(request) {
        return request[this._entrySymbol];
      }
      _ensurePageEntry(page) {
        let pageEntry = this._pageEntries.get(page);
        if (!pageEntry) {
          page.on(_page.Page.Events.DOMContentLoaded, () => this._onDOMContentLoaded(page));
          page.on(_page.Page.Events.Load, () => this._onLoad(page));
          pageEntry = {
            startedDateTime: new Date(),
            id: page.guid,
            title: "",
            pageTimings: {
              onContentLoad: -1,
              onLoad: -1
            }
          };
          this._pageEntries.set(page, pageEntry);
        }
        return pageEntry;
      }
      _onDOMContentLoaded(page) {
        const pageEntry = this._ensurePageEntry(page);
        const promise = page.mainFrame().evaluateExpression(String(() => {
          return {
            title: document.title,
            domContentLoaded: performance.timing.domContentLoadedEventStart
          };
        }), true, void 0, "utility").then((result) => {
          pageEntry.title = result.title;
          pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
        }).catch(() => {
        });
        this._addBarrier(page, promise);
      }
      _onLoad(page) {
        const pageEntry = this._ensurePageEntry(page);
        const promise = page.mainFrame().evaluateExpression(String(() => {
          return {
            title: document.title,
            loaded: performance.timing.loadEventStart
          };
        }), true, void 0, "utility").then((result) => {
          pageEntry.title = result.title;
          pageEntry.pageTimings.onLoad = result.loaded;
        }).catch(() => {
        });
        this._addBarrier(page, promise);
      }
      _addBarrier(page, promise) {
        if (!this._options.waitForContentOnStop)
          return;
        const race = Promise.race([new Promise((f) => page.on("close", () => {
          this._barrierPromises.delete(race);
          f();
        })), promise]);
        this._barrierPromises.add(race);
      }
      _onRequest(request) {
        const page = request.frame()._page;
        const url = network.parsedURL(request.url());
        if (!url)
          return;
        const pageEntry = this._ensurePageEntry(page);
        const harEntry = {
          pageref: pageEntry.id,
          _requestref: request.guid,
          _frameref: request.frame().guid,
          _monotonicTime: (0, _utils.monotonicTime)(),
          startedDateTime: new Date(),
          time: -1,
          request: {
            method: request.method(),
            url: request.url(),
            httpVersion: FALLBACK_HTTP_VERSION,
            cookies: [],
            headers: [],
            queryString: [...url.searchParams].map((e) => ({
              name: e[0],
              value: e[1]
            })),
            postData: postDataForHar(request, this._options.content),
            headersSize: -1,
            bodySize: request.bodySize()
          },
          response: {
            status: -1,
            statusText: "",
            httpVersion: FALLBACK_HTTP_VERSION,
            cookies: [],
            headers: [],
            content: {
              size: -1,
              mimeType: request.headerValue("content-type") || "x-unknown"
            },
            headersSize: -1,
            bodySize: -1,
            redirectURL: "",
            _transferSize: -1
          },
          cache: {
            beforeRequest: null,
            afterRequest: null
          },
          timings: {
            send: -1,
            wait: -1,
            receive: -1
          }
        };
        if (request.redirectedFrom()) {
          const fromEntry = this._entryForRequest(request.redirectedFrom());
          if (fromEntry)
            fromEntry.response.redirectURL = request.url();
        }
        request[this._entrySymbol] = harEntry;
        if (this._started)
          this._delegate.onEntryStarted(harEntry);
      }
      async _onRequestFinished(request, response) {
        if (!response)
          return;
        const page = request.frame()._page;
        const harEntry = this._entryForRequest(request);
        if (!harEntry)
          return;
        const httpVersion = response.httpVersion();
        harEntry.request.httpVersion = httpVersion;
        harEntry.response.httpVersion = httpVersion;
        const compressionCalculationBarrier = {
          _encodedBodySize: -1,
          _decodedBodySize: -1,
          barrier: new _async.ManualPromise(),
          _check: function() {
            if (this._encodedBodySize !== -1 && this._decodedBodySize !== -1) {
              harEntry.response.content.compression = Math.max(0, this._decodedBodySize - this._encodedBodySize);
              this.barrier.resolve();
            }
          },
          setEncodedBodySize: function(encodedBodySize) {
            this._encodedBodySize = encodedBodySize;
            this._check();
          },
          setDecodedBodySize: function(decodedBodySize) {
            this._decodedBodySize = decodedBodySize;
            this._check();
          }
        };
        this._addBarrier(page, compressionCalculationBarrier.barrier);
        const promise = response.body().then((buffer) => {
          if (this._options.skipScripts && request.resourceType() === "script") {
            compressionCalculationBarrier.setDecodedBodySize(0);
            return;
          }
          const content = harEntry.response.content;
          content.size = buffer.length;
          compressionCalculationBarrier.setDecodedBodySize(buffer.length);
          if (buffer && buffer.length > 0) {
            if (this._options.content === "embedded") {
              content.text = buffer.toString("base64");
              content.encoding = "base64";
            } else if (this._options.content === "sha1") {
              content._sha1 = (0, _utils.calculateSha1)(buffer) + "." + (mime.getExtension(content.mimeType) || "dat");
              if (this._started)
                this._delegate.onContentBlob(content._sha1, buffer);
            }
          }
        }).catch(() => {
          compressionCalculationBarrier.setDecodedBodySize(0);
        }).then(() => {
          const postData = response.request().postDataBuffer();
          if (postData && harEntry.request.postData && this._options.content === "sha1") {
            harEntry.request.postData._sha1 = (0, _utils.calculateSha1)(postData) + "." + (mime.getExtension(harEntry.request.postData.mimeType) || "dat");
            if (this._started)
              this._delegate.onContentBlob(harEntry.request.postData._sha1, postData);
          }
          if (this._started)
            this._delegate.onEntryFinished(harEntry);
        });
        this._addBarrier(page, promise);
        this._addBarrier(page, response.sizes().then((sizes) => {
          harEntry.response.bodySize = sizes.responseBodySize;
          harEntry.response.headersSize = sizes.responseHeadersSize;
          harEntry.response._transferSize = response.request().responseSize.transferSize || sizes.responseHeadersSize + sizes.responseBodySize;
          harEntry.request.headersSize = sizes.requestHeadersSize;
          compressionCalculationBarrier.setEncodedBodySize(sizes.responseBodySize);
        }));
      }
      _onResponse(response) {
        const page = response.frame()._page;
        const pageEntry = this._ensurePageEntry(page);
        const harEntry = this._entryForRequest(response.request());
        if (!harEntry)
          return;
        const request = response.request();
        harEntry.request.postData = postDataForHar(request, this._options.content);
        harEntry.response = {
          status: response.status(),
          statusText: response.statusText(),
          httpVersion: response.httpVersion(),
          cookies: [],
          headers: [],
          content: {
            size: -1,
            mimeType: "x-unknown"
          },
          headersSize: -1,
          bodySize: -1,
          redirectURL: "",
          _transferSize: -1
        };
        const timing = response.timing();
        if (pageEntry.startedDateTime.valueOf() > timing.startTime)
          pageEntry.startedDateTime = new Date(timing.startTime);
        const dns = timing.domainLookupEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;
        const connect = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;
        const ssl = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;
        const wait = timing.responseStart !== -1 ? _helper.helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;
        const receive = response.request()._responseEndTiming !== -1 ? _helper.helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;
        harEntry.timings = {
          dns,
          connect,
          ssl,
          send: 0,
          wait,
          receive
        };
        harEntry.time = [dns, connect, ssl, wait, receive].reduce((pre, cur) => cur > 0 ? cur + pre : pre, 0);
        this._addBarrier(page, response.serverAddr().then((server) => {
          if (server !== null && server !== void 0 && server.ipAddress)
            harEntry.serverIPAddress = server.ipAddress;
          if (server !== null && server !== void 0 && server.port)
            harEntry._serverPort = server.port;
        }));
        this._addBarrier(page, response.securityDetails().then((details) => {
          if (details)
            harEntry._securityDetails = details;
        }));
        this._addBarrier(page, request.rawRequestHeaders().then((headers) => {
          for (const header of headers.filter((header2) => header2.name.toLowerCase() === "cookie"))
            harEntry.request.cookies.push(...header.value.split(";").map(parseCookie));
          harEntry.request.headers = headers;
        }));
        this._addBarrier(page, response.rawResponseHeaders().then((headers) => {
          for (const header of headers.filter((header2) => header2.name.toLowerCase() === "set-cookie"))
            harEntry.response.cookies.push(parseCookie(header.value));
          harEntry.response.headers = headers;
          const contentType = headers.find((header) => header.name.toLowerCase() === "content-type");
          if (contentType)
            harEntry.response.content.mimeType = contentType.value;
        }));
      }
      async flush() {
        await Promise.all(this._barrierPromises);
      }
      stop() {
        this._started = false;
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._barrierPromises.clear();
        const log = {
          version: "1.2",
          creator: {
            name: "Playwright",
            version: require_package()["version"]
          },
          browser: {
            name: this._context._browser.options.name,
            version: this._context._browser.version()
          },
          pages: Array.from(this._pageEntries.values()),
          entries: []
        };
        for (const pageEntry of log.pages) {
          if (pageEntry.pageTimings.onContentLoad >= 0)
            pageEntry.pageTimings.onContentLoad -= pageEntry.startedDateTime.valueOf();
          else
            pageEntry.pageTimings.onContentLoad = -1;
          if (pageEntry.pageTimings.onLoad >= 0)
            pageEntry.pageTimings.onLoad -= pageEntry.startedDateTime.valueOf();
          else
            pageEntry.pageTimings.onLoad = -1;
        }
        this._pageEntries.clear();
        return log;
      }
    };
    exports.HarTracer = HarTracer;
    function postDataForHar(request, content) {
      const postData = request.postDataBuffer();
      if (!postData)
        return;
      const contentType = request.headerValue("content-type") || "application/octet-stream";
      const result = {
        mimeType: contentType,
        text: "",
        params: []
      };
      if (content === "embedded" && contentType !== "application/octet-stream")
        result.text = postData.toString();
      if (contentType === "application/x-www-form-urlencoded") {
        const parsed = new URLSearchParams(postData.toString());
        for (const [name, value] of parsed.entries())
          result.params.push({
            name,
            value
          });
      }
      return result;
    }
    function parseCookie(c) {
      const cookie = {
        name: "",
        value: ""
      };
      let first = true;
      for (const pair of c.split(/; */)) {
        const indexOfEquals = pair.indexOf("=");
        const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
        const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : "";
        if (first) {
          first = false;
          cookie.name = name;
          cookie.value = value;
          continue;
        }
        if (name === "Domain")
          cookie.domain = value;
        if (name === "Expires")
          cookie.expires = new Date(value);
        if (name === "HttpOnly")
          cookie.httpOnly = true;
        if (name === "Max-Age")
          cookie.expires = new Date(Date.now() + +value * 1e3);
        if (name === "Path")
          cookie.path = value;
        if (name === "SameSite")
          cookie.sameSite = value;
        if (name === "Secure")
          cookie.secure = true;
      }
      return cookie;
    }
  }
});

// node_modules/playwright-core/lib/server/trace/common/traceEvents.js
var require_traceEvents = __commonJS({
  "node_modules/playwright-core/lib/server/trace/common/traceEvents.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VERSION = void 0;
    var VERSION = 3;
    exports.VERSION = VERSION;
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/tracing.js
var require_tracing = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/tracing.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.shouldCaptureSnapshot = shouldCaptureSnapshot;
    exports.Tracing = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var _path = _interopRequireDefault(__require("path"));
    var _yazl = _interopRequireDefault(require_yazl());
    var _utils = require_utils();
    var _artifact = require_artifact();
    var _browserContext = require_browserContext();
    var _dom = require_dom();
    var _eventsHelper = require_eventsHelper();
    var _page = require_page();
    var _channels = require_channels();
    var _snapshotter = require_snapshotter();
    var _harTracer = require_harTracer();
    var _traceEvents = require_traceEvents();
    var _async = require_async();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kScreencastOptions = {
      width: 800,
      height: 600,
      quality: 90
    };
    var Tracing = class {
      constructor(context) {
        this._writeChain = Promise.resolve();
        this._snapshotter = void 0;
        this._harTracer = void 0;
        this._screencastListeners = [];
        this._pendingCalls = new Map();
        this._context = void 0;
        this._resourcesDir = void 0;
        this._state = void 0;
        this._isStopping = false;
        this._tracesDir = void 0;
        this._allResources = new Set();
        this._contextCreatedEvent = void 0;
        this._context = context;
        this._tracesDir = context._browser.options.tracesDir;
        this._resourcesDir = _path.default.join(this._tracesDir, "resources");
        this._snapshotter = new _snapshotter.Snapshotter(context, this);
        this._harTracer = new _harTracer.HarTracer(context, this, {
          content: "sha1",
          waitForContentOnStop: false,
          skipScripts: true
        });
        this._contextCreatedEvent = {
          version: _traceEvents.VERSION,
          type: "context-options",
          browserName: this._context._browser.options.name,
          options: this._context._options,
          platform: process.platform,
          wallTime: 0
        };
      }
      start(options2) {
        if (this._isStopping)
          throw new Error("Cannot start tracing while stopping");
        if (this._state) {
          const o = this._state.options;
          if (o.name !== options2.name || !o.screenshots !== !options2.screenshots || !o.snapshots !== !options2.snapshots)
            throw new Error("Tracing has been already started with different options");
          return;
        }
        const traceName = options2.name || (0, _utils.createGuid)();
        const traceFile = _path.default.join(this._tracesDir, traceName + ".trace");
        const networkFile = _path.default.join(this._tracesDir, traceName + ".network");
        this._state = {
          options: options2,
          traceName,
          traceFile,
          networkFile,
          filesCount: 0,
          sha1s: new Set(),
          recording: false
        };
        this._writeChain = _fs.default.promises.mkdir(this._resourcesDir, {
          recursive: true
        }).then(() => _fs.default.promises.writeFile(networkFile, ""));
        if (options2.snapshots)
          this._harTracer.start();
      }
      async startChunk(options2 = {}) {
        if (this._state && this._state.recording)
          await this.stopChunk(false, false);
        if (!this._state)
          throw new Error("Must start tracing before starting a new chunk");
        if (this._isStopping)
          throw new Error("Cannot start a trace chunk while stopping");
        const state = this._state;
        const suffix = state.filesCount ? `-${state.filesCount}` : ``;
        state.filesCount++;
        state.traceFile = _path.default.join(this._tracesDir, `${state.traceName}${suffix}.trace`);
        state.recording = true;
        this._appendTraceOperation(async () => {
          await (0, _utils.mkdirIfNeeded)(state.traceFile);
          await _fs.default.promises.appendFile(state.traceFile, JSON.stringify(__spreadProps(__spreadValues({}, this._contextCreatedEvent), {
            title: options2.title,
            wallTime: Date.now()
          })) + "\n");
        });
        this._context.instrumentation.addListener(this);
        if (state.options.screenshots)
          this._startScreencast();
        if (state.options.snapshots)
          await this._snapshotter.start();
      }
      _startScreencast() {
        for (const page of this._context.pages())
          this._startScreencastInPage(page);
        this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._startScreencastInPage.bind(this)));
      }
      _stopScreencast() {
        _eventsHelper.eventsHelper.removeEventListeners(this._screencastListeners);
        for (const page of this._context.pages())
          page.setScreencastOptions(null);
      }
      async stop() {
        if (!this._state)
          return;
        if (this._isStopping)
          throw new Error(`Tracing is already stopping`);
        if (this._state.recording)
          throw new Error(`Must stop trace file before stopping tracing`);
        this._harTracer.stop();
        await this._writeChain;
        this._state = void 0;
      }
      async dispose() {
        this._snapshotter.dispose();
        await this._writeChain;
      }
      async stopChunk(save, skipCompress) {
        var _this$_state;
        if (this._isStopping)
          throw new Error(`Tracing is already stopping`);
        this._isStopping = true;
        if (!this._state || !this._state.recording) {
          this._isStopping = false;
          if (save)
            throw new Error(`Must start tracing before stopping`);
          return {
            artifact: null,
            entries: []
          };
        }
        const state = this._state;
        this._context.instrumentation.removeListener(this);
        if ((_this$_state = this._state) !== null && _this$_state !== void 0 && _this$_state.options.screenshots)
          this._stopScreencast();
        for (const {
          sdkObject,
          metadata,
          beforeSnapshot,
          actionSnapshot,
          afterSnapshot
        } of this._pendingCalls.values()) {
          await Promise.all([beforeSnapshot, actionSnapshot, afterSnapshot]);
          let callMetadata = metadata;
          if (!afterSnapshot) {
            callMetadata = __spreadProps(__spreadValues({}, metadata), {
              error: {
                error: {
                  name: "Error",
                  message: "Action was interrupted"
                }
              }
            });
          }
          await this.onAfterCall(sdkObject, callMetadata);
        }
        if (state.options.snapshots)
          await this._snapshotter.stop();
        return await this._appendTraceOperation(async () => {
          this._isStopping = false;
          state.recording = false;
          if (!save)
            return {
              artifact: null,
              entries: []
            };
          const networkFile = _path.default.join(state.networkFile, "..", (0, _utils.createGuid)());
          await _fs.default.promises.copyFile(state.networkFile, networkFile);
          const entries = [];
          entries.push({
            name: "trace.trace",
            value: state.traceFile
          });
          entries.push({
            name: "trace.network",
            value: networkFile
          });
          for (const sha1 of state.sha1s)
            entries.push({
              name: _path.default.join("resources", sha1),
              value: _path.default.join(this._resourcesDir, sha1)
            });
          const zipArtifact = skipCompress ? null : await this._exportZip(entries, state).catch(() => null);
          return {
            artifact: zipArtifact,
            entries
          };
        }) || {
          artifact: null,
          entries: []
        };
      }
      async _exportZip(entries, state) {
        const zipFile = new _yazl.default.ZipFile();
        const result = new _async.ManualPromise();
        zipFile.on("error", (error2) => result.reject(error2));
        for (const entry of entries)
          zipFile.addFile(entry.value, entry.name);
        zipFile.end();
        const zipFileName = state.traceFile + ".zip";
        zipFile.outputStream.pipe(_fs.default.createWriteStream(zipFileName)).on("close", () => {
          const artifact = new _artifact.Artifact(this._context, zipFileName);
          artifact.reportFinished();
          result.resolve(artifact);
        });
        return result;
      }
      async _captureSnapshot(name, sdkObject, metadata, element) {
        if (!sdkObject.attribution.page)
          return;
        if (!this._snapshotter.started())
          return;
        if (!shouldCaptureSnapshot(metadata))
          return;
        const snapshotName = `${name}@${metadata.id}`;
        metadata.snapshots.push({
          title: name,
          snapshotName
        });
        if (!element && sdkObject instanceof _dom.ElementHandle)
          element = sdkObject;
        await this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName, element).catch(() => {
        });
      }
      async onBeforeCall(sdkObject, metadata) {
        var _sdkObject$attributio;
        (_sdkObject$attributio = sdkObject.attribution.page) === null || _sdkObject$attributio === void 0 ? void 0 : _sdkObject$attributio.temporarlyDisableTracingScreencastThrottling();
        metadata.afterSnapshot = `after@${metadata.id}`;
        const beforeSnapshot = this._captureSnapshot("before", sdkObject, metadata);
        this._pendingCalls.set(metadata.id, {
          sdkObject,
          metadata,
          beforeSnapshot
        });
        await beforeSnapshot;
      }
      async onBeforeInputAction(sdkObject, metadata, element) {
        var _sdkObject$attributio2;
        (_sdkObject$attributio2 = sdkObject.attribution.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.temporarlyDisableTracingScreencastThrottling();
        const actionSnapshot = this._captureSnapshot("action", sdkObject, metadata, element);
        this._pendingCalls.get(metadata.id).actionSnapshot = actionSnapshot;
        await actionSnapshot;
      }
      async onAfterCall(sdkObject, metadata) {
        var _sdkObject$attributio3;
        (_sdkObject$attributio3 = sdkObject.attribution.page) === null || _sdkObject$attributio3 === void 0 ? void 0 : _sdkObject$attributio3.temporarlyDisableTracingScreencastThrottling();
        const pendingCall = this._pendingCalls.get(metadata.id);
        if (!pendingCall || pendingCall.afterSnapshot)
          return;
        if (!sdkObject.attribution.context) {
          this._pendingCalls.delete(metadata.id);
          return;
        }
        pendingCall.afterSnapshot = this._captureSnapshot("after", sdkObject, metadata);
        await pendingCall.afterSnapshot;
        const event = {
          type: "action",
          metadata
        };
        this._appendTraceEvent(event);
        this._pendingCalls.delete(metadata.id);
      }
      onEvent(sdkObject, metadata) {
        if (!sdkObject.attribution.context)
          return;
        const event = {
          type: "event",
          metadata
        };
        this._appendTraceEvent(event);
      }
      onEntryStarted(entry) {
      }
      onEntryFinished(entry) {
        const event = {
          type: "resource-snapshot",
          snapshot: entry
        };
        this._appendTraceOperation(async () => {
          visitSha1s(event, this._state.sha1s);
          await _fs.default.promises.appendFile(this._state.networkFile, JSON.stringify(event) + "\n");
        });
      }
      onContentBlob(sha1, buffer) {
        this._appendResource(sha1, buffer);
      }
      onSnapshotterBlob(blob) {
        this._appendResource(blob.sha1, blob.buffer);
      }
      onFrameSnapshot(snapshot) {
        this._appendTraceEvent({
          type: "frame-snapshot",
          snapshot
        });
      }
      _startScreencastInPage(page) {
        page.setScreencastOptions(kScreencastOptions);
        const prefix = page.guid;
        let frameSeq = 0;
        this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.ScreencastFrame, (params) => {
          const suffix = String(++frameSeq).padStart(10, "0");
          const sha1 = `${prefix}-${suffix}.jpeg`;
          const event = {
            type: "screencast-frame",
            pageId: page.guid,
            sha1,
            width: params.width,
            height: params.height,
            timestamp: (0, _utils.monotonicTime)()
          };
          this._appendResource(sha1, params.buffer);
          this._appendTraceEvent(event);
        }));
      }
      _appendTraceEvent(event) {
        this._appendTraceOperation(async () => {
          visitSha1s(event, this._state.sha1s);
          await _fs.default.promises.appendFile(this._state.traceFile, JSON.stringify(event) + "\n");
        });
      }
      _appendResource(sha1, buffer) {
        if (this._allResources.has(sha1))
          return;
        this._allResources.add(sha1);
        this._appendTraceOperation(async () => {
          const resourcePath = _path.default.join(this._resourcesDir, sha1);
          try {
            await _fs.default.promises.access(resourcePath);
          } catch (e) {
            await _fs.default.promises.writeFile(resourcePath, buffer).catch(() => {
            });
          }
        });
      }
      async _appendTraceOperation(cb) {
        let error2;
        let result;
        this._writeChain = this._writeChain.then(async () => {
          if (!this._context._browser.isConnected())
            return;
          try {
            result = await cb();
          } catch (e) {
            error2 = e;
          }
        });
        await this._writeChain;
        if (error2)
          throw error2;
        return result;
      }
    };
    exports.Tracing = Tracing;
    function visitSha1s(object, sha1s) {
      if (Array.isArray(object)) {
        object.forEach((o) => visitSha1s(o, sha1s));
        return;
      }
      if (typeof object === "object") {
        for (const key in object) {
          if (key === "sha1" || key === "_sha1" || key.endsWith("Sha1")) {
            const sha1 = object[key];
            if (sha1)
              sha1s.add(sha1);
          }
          visitSha1s(object[key], sha1s);
        }
        return;
      }
    }
    function shouldCaptureSnapshot(metadata) {
      return _channels.commandsWithTracingSnapshots.has(metadata.type + "." + metadata.method);
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/har/harRecorder.js
var require_harRecorder = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/har/harRecorder.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.HarRecorder = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var _artifact = require_artifact();
    var _harTracer = require_harTracer();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var HarRecorder = class {
      constructor(context, options2) {
        this._artifact = void 0;
        this._isFlushed = false;
        this._options = void 0;
        this._tracer = void 0;
        this._entries = [];
        this._artifact = new _artifact.Artifact(context, options2.path);
        this._options = options2;
        this._tracer = new _harTracer.HarTracer(context, this, {
          content: options2.omitContent ? "omit" : "embedded",
          waitForContentOnStop: true,
          skipScripts: false
        });
        this._tracer.start();
      }
      onEntryStarted(entry) {
        this._entries.push(entry);
      }
      onEntryFinished(entry) {
      }
      onContentBlob(sha1, buffer) {
      }
      async flush() {
        if (this._isFlushed)
          return;
        this._isFlushed = true;
        await this._tracer.flush();
        const log = this._tracer.stop();
        log.entries = this._entries;
        await _fs.default.promises.writeFile(this._options.path, JSON.stringify({
          log
        }, void 0, 2));
      }
      async export() {
        await this.flush();
        this._artifact.reportFinished();
        return this._artifact;
      }
    };
    exports.HarRecorder = HarRecorder;
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/utils.js
var require_utils3 = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/utils.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toClickOptions = toClickOptions;
    exports.toModifiers = toModifiers;
    exports.describeFrame = describeFrame;
    exports.escapeWithQuotes = escapeWithQuotes;
    function toClickOptions(action) {
      let method = "click";
      if (action.clickCount === 2)
        method = "dblclick";
      const modifiers = toModifiers(action.modifiers);
      const options2 = {};
      if (action.button !== "left")
        options2.button = action.button;
      if (modifiers.length)
        options2.modifiers = modifiers;
      if (action.clickCount > 2)
        options2.clickCount = action.clickCount;
      if (action.position)
        options2.position = action.position;
      return {
        method,
        options: options2
      };
    }
    function toModifiers(modifiers) {
      const result = [];
      if (modifiers & 1)
        result.push("Alt");
      if (modifiers & 2)
        result.push("Control");
      if (modifiers & 4)
        result.push("Meta");
      if (modifiers & 8)
        result.push("Shift");
      return result;
    }
    function describeFrame(frame) {
      const page = frame._page;
      if (page.mainFrame() === frame)
        return {
          isMainFrame: true,
          frameUrl: frame.url()
        };
      const frames = page.frames().filter((f) => f.name() === frame.name());
      if (frames.length === 1 && frames[0] === frame)
        return {
          isMainFrame: false,
          frameUrl: frame.url(),
          frameName: frame.name()
        };
      return {
        isMainFrame: false,
        frameUrl: frame.url()
      };
    }
    function escapeWithQuotes(text, char = "'") {
      const stringified = JSON.stringify(text);
      const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\"/g, '"');
      if (char === "'")
        return char + escapedText.replace(/[']/g, "\\'") + char;
      if (char === '"')
        return char + escapedText.replace(/["]/g, '\\"') + char;
      if (char === "`")
        return char + escapedText.replace(/[`]/g, "`") + char;
      throw new Error("Invalid escape char");
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/codeGenerator.js
var require_codeGenerator = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/codeGenerator.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CodeGenerator = void 0;
    var _events = __require("events");
    var _utils = require_utils3();
    var CodeGenerator = class extends _events.EventEmitter {
      constructor(browserName, generateHeaders, launchOptions, contextOptions, deviceName, saveStorage) {
        super();
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this._enabled = void 0;
        this._options = void 0;
        launchOptions = __spreadValues({
          headless: false
        }, launchOptions);
        contextOptions = __spreadValues({}, contextOptions);
        this._enabled = generateHeaders;
        this._options = {
          browserName,
          generateHeaders,
          launchOptions,
          contextOptions,
          deviceName,
          saveStorage
        };
        this.restart();
      }
      restart() {
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this.emit("change");
      }
      setEnabled(enabled) {
        this._enabled = enabled;
      }
      addAction(action) {
        if (!this._enabled)
          return;
        this.willPerformAction(action);
        this.didPerformAction(action);
      }
      willPerformAction(action) {
        if (!this._enabled)
          return;
        this._currentAction = action;
      }
      performedActionFailed(action) {
        if (!this._enabled)
          return;
        if (this._currentAction === action)
          this._currentAction = null;
      }
      didPerformAction(actionInContext) {
        if (!this._enabled)
          return;
        const {
          action,
          pageAlias
        } = actionInContext;
        let eraseLastAction = false;
        if (this._lastAction && this._lastAction.pageAlias === pageAlias) {
          const {
            action: lastAction
          } = this._lastAction;
          if (this._lastAction && action.name === "fill" && lastAction.name === "fill") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "click" && lastAction.name === "click") {
            if (action.selector === lastAction.selector && action.clickCount > lastAction.clickCount)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "navigate" && lastAction.name === "navigate") {
            if (action.url === lastAction.url) {
              this._currentAction = null;
              return;
            }
          }
          if (lastAction && (action.name === "check" || action.name === "uncheck") && lastAction.name === "click") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
        }
        this._lastAction = actionInContext;
        this._currentAction = null;
        if (eraseLastAction)
          this._actions.pop();
        this._actions.push(actionInContext);
        this.emit("change");
      }
      commitLastAction() {
        if (!this._enabled)
          return;
        const action = this._lastAction;
        if (action)
          action.committed = true;
      }
      signal(pageAlias, frame, signal) {
        if (!this._enabled)
          return;
        if (signal.name === "download")
          this._options.contextOptions.acceptDownloads = true;
        if (this._currentAction) {
          this._currentAction.action.signals.push(signal);
          return;
        }
        if (this._lastAction && !this._lastAction.committed) {
          const signals = this._lastAction.action.signals;
          if (signal.name === "navigation" && signals.length && signals[signals.length - 1].name === "download")
            return;
          if (signal.name === "download" && signals.length && signals[signals.length - 1].name === "navigation")
            signals.length = signals.length - 1;
          signal.isAsync = true;
          this._lastAction.action.signals.push(signal);
          this.emit("change");
          return;
        }
        if (signal.name === "navigation") {
          this.addAction(__spreadProps(__spreadValues({
            pageAlias
          }, (0, _utils.describeFrame)(frame)), {
            committed: true,
            action: {
              name: "navigate",
              url: frame.url(),
              signals: []
            }
          }));
        }
      }
      generateText(languageGenerator) {
        const text = [];
        if (this._options.generateHeaders)
          text.push(languageGenerator.generateHeader(this._options));
        for (const action of this._actions) {
          const actionText = languageGenerator.generateAction(action);
          if (actionText)
            text.push(actionText);
        }
        if (this._options.generateHeaders)
          text.push(languageGenerator.generateFooter(this._options.saveStorage));
        return text.join("\n");
      }
    };
    exports.CodeGenerator = CodeGenerator;
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/language.js
var require_language = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/language.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sanitizeDeviceOptions = sanitizeDeviceOptions;
    exports.toSignalMap = toSignalMap;
    function sanitizeDeviceOptions(device, options2) {
      const cleanedOptions = {};
      for (const property in options2) {
        if (JSON.stringify(device[property]) !== JSON.stringify(options2[property]))
          cleanedOptions[property] = options2[property];
      }
      return cleanedOptions;
    }
    function toSignalMap(action) {
      let waitForNavigation;
      let assertNavigation;
      let popup;
      let download;
      let dialog;
      for (const signal of action.signals) {
        if (signal.name === "navigation" && signal.isAsync)
          waitForNavigation = signal;
        else if (signal.name === "navigation" && !signal.isAsync)
          assertNavigation = signal;
        else if (signal.name === "popup")
          popup = signal;
        else if (signal.name === "download")
          download = signal;
        else if (signal.name === "dialog")
          dialog = signal;
      }
      return {
        waitForNavigation,
        assertNavigation,
        popup,
        download,
        dialog
      };
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/recorderActions.js
var require_recorderActions = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/recorderActions.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.actionTitle = actionTitle;
    function actionTitle(action) {
      switch (action.name) {
        case "openPage":
          return `Open new page`;
        case "closePage":
          return `Close page`;
        case "check":
          return `Check ${action.selector}`;
        case "uncheck":
          return `Uncheck ${action.selector}`;
        case "click": {
          if (action.clickCount === 1)
            return `Click ${action.selector}`;
          if (action.clickCount === 2)
            return `Double click ${action.selector}`;
          if (action.clickCount === 3)
            return `Triple click ${action.selector}`;
          return `${action.clickCount}\xD7 click`;
        }
        case "fill":
          return `Fill ${action.selector}`;
        case "setInputFiles":
          if (action.files.length === 0)
            return `Clear selected files`;
          else
            return `Upload ${action.files.join(", ")}`;
        case "navigate":
          return `Go to ${action.url}`;
        case "press":
          return `Press ${action.key}` + (action.modifiers ? " with modifiers" : "");
        case "select":
          return `Select ${action.options.join(", ")}`;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/deviceDescriptorsSource.json
var require_deviceDescriptorsSource = __commonJS({
  "node_modules/playwright-core/lib/server/deviceDescriptorsSource.json"(exports, module) {
    module.exports = {
      "Blackberry PlayBook": {
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/15.4 Safari/536.2+",
        viewport: {
          width: 600,
          height: 1024
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Blackberry PlayBook landscape": {
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/15.4 Safari/536.2+",
        viewport: {
          width: 1024,
          height: 600
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "BlackBerry Z30": {
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/15.4 Mobile Safari/537.10+",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "BlackBerry Z30 landscape": {
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/15.4 Mobile Safari/537.10+",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note 3": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note 3 landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note II": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note II landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S III": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S III landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S5": {
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S8": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 740
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S8 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 740,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S9+": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 320,
          height: 658
        },
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S9+ landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 658,
          height: 320
        },
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy Tab S4": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36",
        viewport: {
          width: 712,
          height: 1138
        },
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy Tab S4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36",
        viewport: {
          width: 1138,
          height: 712
        },
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "iPad (gen 6)": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 6) landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 7)": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 810,
          height: 1080
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 7) landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1080,
          height: 810
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Mini": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Mini landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Pro 11": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 834,
          height: 1194
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Pro 11 landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1194,
          height: 834
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone SE": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/15.4 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 320,
          height: 568
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone SE landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/15.4 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 568,
          height: 320
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone X": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 812
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone X landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 812,
          height: 375
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone XR": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 414,
          height: 896
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone XR landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 896,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 414,
          height: 715
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 800,
          height: 364
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 635
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 724,
          height: 325
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 414,
          height: 715
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 808,
          height: 364
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 340
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 340
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 428,
          height: 746
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 832,
          height: 378
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 342
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 342
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 428,
          height: 746
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 832,
          height: 380
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Mini": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 629
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Mini landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 712,
          height: 327
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "JioPhone 2": {
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:94.0.1) Gecko/48.0 Firefox/94.0.1 KAIOS/2.5",
        viewport: {
          width: 240,
          height: 320
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "firefox"
      },
      "JioPhone 2 landscape": {
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:94.0.1) Gecko/48.0 Firefox/94.0.1 KAIOS/2.5",
        viewport: {
          width: 320,
          height: 240
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "firefox"
      },
      "Kindle Fire HDX": {
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 800,
          height: 1280
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Kindle Fire HDX landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 1280,
          height: 800
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "LG Optimus L70": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640
        },
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "LG Optimus L70 landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384
        },
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 550": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 550 landscape": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 950": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 950 landscape": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 10": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36",
        viewport: {
          width: 800,
          height: 1280
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 10 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36",
        viewport: {
          width: 1280,
          height: 800
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 4": {
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5X": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5X landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6P": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6P landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 7": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36",
        viewport: {
          width: 600,
          height: 960
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 7 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36",
        viewport: {
          width: 960,
          height: 600
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia Lumia 520": {
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 320,
          height: 533
        },
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia Lumia 520 landscape": {
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 533,
          height: 320
        },
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia N9": {
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 480,
          height: 854
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Nokia N9 landscape": {
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 854,
          height: 480
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Pixel 2": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 731
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 731,
          height: 411
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 XL": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 823
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 XL landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 823,
          height: 411
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 3": {
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 393,
          height: 786
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 3 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 786,
          height: 393
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4": {
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 353,
          height: 745
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 745,
          height: 353
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4a (5G)": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        screen: {
          width: 412,
          height: 892
        },
        viewport: {
          width: 412,
          height: 765
        },
        deviceScaleFactor: 2.63,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4a (5G) landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        screen: {
          height: 892,
          width: 412
        },
        viewport: {
          width: 840,
          height: 312
        },
        deviceScaleFactor: 2.63,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 5": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        screen: {
          width: 393,
          height: 851
        },
        viewport: {
          width: 393,
          height: 727
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        screen: {
          width: 851,
          height: 393
        },
        viewport: {
          width: 802,
          height: 293
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Moto G4": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Moto G4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Desktop Chrome HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Edge HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36 Edg/98.0.4695.0",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Firefox HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0.1) Gecko/20100101 Firefox/94.0.1",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "firefox"
      },
      "Desktop Safari": {
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Safari/605.1.15",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "webkit"
      },
      "Desktop Chrome": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Edge": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4695.0 Safari/537.36 Edg/98.0.4695.0",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Firefox": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0.1) Gecko/20100101 Firefox/94.0.1",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "firefox"
      }
    };
  }
});

// node_modules/playwright-core/lib/server/deviceDescriptors.js
var require_deviceDescriptors = __commonJS({
  "node_modules/playwright-core/lib/server/deviceDescriptors.js"(exports, module) {
    init_shims();
    module.exports = require_deviceDescriptorsSource();
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/javascript.js
var require_javascript2 = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/javascript.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaScriptFormatter = exports.JavaScriptLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils = require_utils3();
    var _deviceDescriptors = _interopRequireDefault(require_deviceDescriptors());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var JavaScriptLanguageGenerator = class {
      constructor(isTest) {
        this.id = void 0;
        this.fileName = void 0;
        this.highlighter = "javascript";
        this._isTest = void 0;
        this.id = isTest ? "test" : "javascript";
        this.fileName = isTest ? "Playwright Test" : "JavaScript";
        this._isTest = isTest;
      }
      generateAction(actionInContext) {
        const {
          action,
          pageAlias
        } = actionInContext;
        const formatter = new JavaScriptFormatter(2);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          if (this._isTest)
            return "";
          formatter.add(`const ${pageAlias} = await context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.goto(${quote(action.url)});`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${formatObject({
          name: actionInContext.frameName
        })})` : `${pageAlias}.frame(${formatObject({
          url: actionInContext.frameUrl
        })})`;
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: \${dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
        }
        const emitPromiseAll = signals.waitForNavigation || signals.popup || signals.download;
        if (emitPromiseAll) {
          let leftHandSide = "";
          if (signals.popup)
            leftHandSide = `const [${signals.popup.popupAlias}] = `;
          else if (signals.download)
            leftHandSide = `const [download] = `;
          formatter.add(`${leftHandSide}await Promise.all([`);
        }
        if (signals.popup)
          formatter.add(`${pageAlias}.waitForEvent('popup'),`);
        if (signals.waitForNavigation)
          formatter.add(`${pageAlias}.waitForNavigation(/*{ url: ${quote(signals.waitForNavigation.url)} }*/),`);
        if (signals.download)
          formatter.add(`${pageAlias}.waitForEvent('download'),`);
        const prefix = signals.popup || signals.waitForNavigation || signals.download ? "" : "await ";
        const actionCall = this._generateActionCall(action);
        const suffix = signals.waitForNavigation || emitPromiseAll ? "" : ";";
        formatter.add(`${prefix}${subject}.${actionCall}${suffix}`);
        if (emitPromiseAll) {
          formatter.add(`]);`);
        } else if (signals.assertNavigation) {
          if (this._isTest)
            formatter.add(`  await expect(${pageAlias}).toHaveURL(${quote(signals.assertNavigation.url)});`);
          else
            formatter.add(`  // assert.equal(${pageAlias}.url(), ${quote(signals.assertNavigation.url)});`);
        }
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options2 = {};
            if (action.button !== "left")
              options2.button = action.button;
            if (modifiers.length)
              options2.modifiers = modifiers;
            if (action.clickCount > 2)
              options2.clickCount = action.clickCount;
            if (action.position)
              options2.position = action.position;
            const optionsString = formatOptions(options2);
            return `${method}(${quote(action.selector)}${optionsString})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `setInputFiles(${quote(action.selector)}, ${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return `selectOption(${quote(action.selector)}, ${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options2) {
        if (this._isTest)
          return this.generateTestHeader(options2);
        return this.generateStandaloneHeader(options2);
      }
      generateFooter(saveStorage) {
        if (this._isTest)
          return this.generateTestFooter(saveStorage);
        return this.generateStandaloneFooter(saveStorage);
      }
      generateTestHeader(options2) {
        const formatter = new JavaScriptFormatter();
        const useText = formatContextOptions(options2.contextOptions, options2.deviceName);
        formatter.add(`
      import { test, expect${options2.deviceName ? ", devices" : ""} } from '@playwright/test';
${useText ? "\ntest.use(" + useText + ");\n" : ""}
      test('test', async ({ page }) => {`);
        return formatter.format();
      }
      generateTestFooter(saveStorage) {
        return `
});`;
      }
      generateStandaloneHeader(options2) {
        const formatter = new JavaScriptFormatter();
        formatter.add(`
      const { ${options2.browserName}${options2.deviceName ? ", devices" : ""} } = require('playwright');

      (async () => {
        const browser = await ${options2.browserName}.launch(${formatObjectOrVoid(options2.launchOptions)});
        const context = await browser.newContext(${formatContextOptions(options2.contextOptions, options2.deviceName)});`);
        return formatter.format();
      }
      generateStandaloneFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
  await context.storageState({ path: ${quote(saveStorage)} });` : "";
        return `
  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
      }
    };
    exports.JavaScriptLanguageGenerator = JavaScriptLanguageGenerator;
    function formatOptions(value) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return ", " + formatObject(value);
    }
    function formatObject(value, indent = "  ") {
      if (typeof value === "string")
        return quote(value);
      if (Array.isArray(value))
        return `[${value.map((o) => formatObject(o)).join(", ")}]`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return "{}";
        const tokens = [];
        for (const key of keys)
          tokens.push(`${key}: ${formatObject(value[key])}`);
        return `{
${indent}${tokens.join(`,
${indent}`)}
}`;
      }
      return String(value);
    }
    function formatObjectOrVoid(value, indent = "  ") {
      const result = formatObject(value, indent);
      return result === "{}" ? "" : result;
    }
    function formatContextOptions(options2, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device)
        return formatObjectOrVoid(options2);
      let serializedObject = formatObjectOrVoid((0, _language.sanitizeDeviceOptions)(device, options2));
      if (!serializedObject)
        serializedObject = "{\n}";
      const lines = serializedObject.split("\n");
      lines.splice(1, 0, `...devices[${quote(deviceName)}],`);
      return lines.join("\n");
    }
    var JavaScriptFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(2);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]"))
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          const callCarryOver = line.startsWith(".set");
          line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : "") + line;
          if (line.endsWith("{") || line.endsWith("["))
            spaces += this._baseIndent;
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    exports.JavaScriptFormatter = JavaScriptFormatter;
    function quote(text) {
      return (0, _utils.escapeWithQuotes)(text, "'");
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/java.js
var require_java = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/java.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JavaLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils = require_utils3();
    var _deviceDescriptors = _interopRequireDefault(require_deviceDescriptors());
    var _javascript = require_javascript2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var JavaLanguageGenerator = class {
      constructor() {
        this.id = "java";
        this.fileName = "Java";
        this.highlighter = "java";
      }
      generateAction(actionInContext) {
        const {
          action,
          pageAlias
        } = actionInContext;
        const formatter = new _javascript.JavaScriptFormatter(6);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`Page ${pageAlias} = context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${pageAlias}.navigate(${quote(action.url)});`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${quote(actionInContext.frameName)})` : `${pageAlias}.frameByUrl(${quote(actionInContext.frameUrl)})`;
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
        }
        const actionCall = this._generateActionCall(action, actionInContext.isMainFrame);
        let code = `${subject}.${actionCall};`;
        if (signals.popup) {
          code = `Page ${signals.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
        }
        if (signals.download) {
          code = `Download download = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
        }
        if (signals.waitForNavigation) {
          code = `
      // ${pageAlias}.waitForNavigation(new Page.WaitForNavigationOptions().setUrl(${quote(signals.waitForNavigation.url)}), () ->
      ${pageAlias}.waitForNavigation(() -> {
        ${code}
      });`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
          formatter.add(`// assert ${pageAlias}.url().equals(${quote(signals.assertNavigation.url)});`);
        return formatter.format();
      }
      _generateActionCall(action, isPage) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options2 = {};
            if (action.button !== "left")
              options2.button = action.button;
            if (modifiers.length)
              options2.modifiers = modifiers;
            if (action.clickCount > 2)
              options2.clickCount = action.clickCount;
            if (action.position)
              options2.position = action.position;
            const optionsText = formatClickOptions(options2, isPage);
            return `${method}(${quote(action.selector)}${optionsText ? ", " : ""}${optionsText})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `setInputFiles(${quote(action.selector)}, ${formatPath(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `navigate(${quote(action.url)})`;
          case "select":
            return `selectOption(${quote(action.selector)}, ${formatSelectOption(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options2) {
        const formatter = new _javascript.JavaScriptFormatter();
        formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;
    import java.util.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options2.browserName}().launch(${formatLaunchOptions(options2.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions(options2.contextOptions, options2.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote(saveStorage)}));
` : "";
        return `${storageStateLine}    }
  }
}`;
      }
    };
    exports.JavaLanguageGenerator = JavaLanguageGenerator;
    function formatPath(files) {
      if (Array.isArray(files)) {
        if (files.length === 0)
          return "new Path[0]";
        return `new Path[] {${files.map((s2) => "Paths.get(" + quote(s2) + ")").join(", ")}}`;
      }
      return `Paths.get(${quote(files)})`;
    }
    function formatSelectOption(options2) {
      if (Array.isArray(options2)) {
        if (options2.length === 0)
          return "new String[0]";
        return `new String[] {${options2.map((s2) => quote(s2)).join(", ")}}`;
      }
      return quote(options2);
    }
    function formatLaunchOptions(options2) {
      const lines = [];
      if (!Object.keys(options2).length)
        return "";
      lines.push("new BrowserType.LaunchOptions()");
      if (typeof options2.headless === "boolean")
        lines.push(`  .setHeadless(false)`);
      if (options2.channel)
        lines.push(`  .setChannel(${quote(options2.channel)})`);
      return lines.join("\n");
    }
    function formatContextOptions(contextOptions, deviceName) {
      const lines = [];
      if (!Object.keys(contextOptions).length && !deviceName)
        return "";
      const device = deviceName ? _deviceDescriptors.default[deviceName] : {};
      const options2 = __spreadValues(__spreadValues({}, device), contextOptions);
      lines.push("new Browser.NewContextOptions()");
      if (options2.acceptDownloads)
        lines.push(`  .setAcceptDownloads(true)`);
      if (options2.bypassCSP)
        lines.push(`  .setBypassCSP(true)`);
      if (options2.colorScheme)
        lines.push(`  .setColorScheme(ColorScheme.${options2.colorScheme.toUpperCase()})`);
      if (options2.deviceScaleFactor)
        lines.push(`  .setDeviceScaleFactor(${options2.deviceScaleFactor})`);
      if (options2.geolocation)
        lines.push(`  .setGeolocation(${options2.geolocation.latitude}, ${options2.geolocation.longitude})`);
      if (options2.hasTouch)
        lines.push(`  .setHasTouch(${options2.hasTouch})`);
      if (options2.isMobile)
        lines.push(`  .setIsMobile(${options2.isMobile})`);
      if (options2.locale)
        lines.push(`  .setLocale(${quote(options2.locale)})`);
      if (options2.proxy)
        lines.push(`  .setProxy(new Proxy(${quote(options2.proxy.server)}))`);
      if (options2.storageState)
        lines.push(`  .setStorageStatePath(Paths.get(${quote(options2.storageState)}))`);
      if (options2.timezoneId)
        lines.push(`  .setTimezoneId(${quote(options2.timezoneId)})`);
      if (options2.userAgent)
        lines.push(`  .setUserAgent(${quote(options2.userAgent)})`);
      if (options2.viewport)
        lines.push(`  .setViewportSize(${options2.viewport.width}, ${options2.viewport.height})`);
      return lines.join("\n");
    }
    function formatClickOptions(options2, isPage) {
      const lines = [];
      if (options2.button)
        lines.push(`  .setButton(MouseButton.${options2.button.toUpperCase()})`);
      if (options2.modifiers)
        lines.push(`  .setModifiers(Arrays.asList(${options2.modifiers.map((m) => `KeyboardModifier.${m.toUpperCase()}`).join(", ")}))`);
      if (options2.clickCount)
        lines.push(`  .setClickCount(${options2.clickCount})`);
      if (options2.position)
        lines.push(`  .setPosition(${options2.position.x}, ${options2.position.y})`);
      if (!lines.length)
        return "";
      lines.unshift(`new ${isPage ? "Page" : "Frame"}.ClickOptions()`);
      return lines.join("\n");
    }
    function quote(text) {
      return (0, _utils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/csharp.js
var require_csharp = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/csharp.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CSharpLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils = require_utils3();
    var _deviceDescriptors = _interopRequireDefault(require_deviceDescriptors());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var CSharpLanguageGenerator = class {
      constructor() {
        this.id = "csharp";
        this.fileName = "C#";
        this.highlighter = "csharp";
      }
      generateAction(actionInContext) {
        const {
          action,
          pageAlias
        } = actionInContext;
        const formatter = new CSharpFormatter(8);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.Frame(${quote(actionInContext.frameName)})` : `${pageAlias}.FrameByUrl(${quote(actionInContext.frameUrl)})`;
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`    void ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)
      {
          Console.WriteLine($"Dialog message: {dialog.Message}");
          dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;`);
        }
        const lines = [];
        const actionCall = this._generateActionCall(action, actionInContext.isMainFrame);
        if (signals.waitForNavigation) {
          lines.push(`await ${pageAlias}.RunAndWaitForNavigationAsync(async () =>`);
          lines.push(`{`);
          lines.push(`    await ${subject}.${actionCall};`);
          lines.push(`}/*, new ${actionInContext.isMainFrame ? "Page" : "Frame"}WaitForNavigationOptions`);
          lines.push(`{`);
          lines.push(`    UrlString = ${quote(signals.waitForNavigation.url)}`);
          lines.push(`}*/);`);
        } else {
          lines.push(`await ${subject}.${actionCall};`);
        }
        if (signals.download) {
          lines.unshift(`var download${signals.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>
{`);
          lines.push(`});`);
        }
        if (signals.popup) {
          lines.unshift(`var ${signals.popup.popupAlias} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>
{`);
          lines.push(`});`);
        }
        for (const line of lines)
          formatter.add(line);
        if (signals.assertNavigation)
          formatter.add(`  // Assert.AreEqual(${quote(signals.assertNavigation.url)}, ${pageAlias}.Url);`);
        return formatter.format();
      }
      _generateActionCall(action, isPage) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "CloseAsync()";
          case "click": {
            let method = "Click";
            if (action.clickCount === 2)
              method = "DblClick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options2 = {};
            if (action.button !== "left")
              options2.button = action.button;
            if (modifiers.length)
              options2.modifiers = modifiers;
            if (action.clickCount > 2)
              options2.clickCount = action.clickCount;
            if (action.position)
              options2.position = action.position;
            if (!Object.entries(options2).length)
              return `${method}Async(${quote(action.selector)})`;
            const optionsString = formatObject(options2, "    ", (isPage ? "Page" : "Frame") + method + "Options");
            return `${method}Async(${quote(action.selector)}, ${optionsString})`;
          }
          case "check":
            return `CheckAsync(${quote(action.selector)})`;
          case "uncheck":
            return `UncheckAsync(${quote(action.selector)})`;
          case "fill":
            return `FillAsync(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `SetInputFilesAsync(${quote(action.selector)}, ${formatObject(action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `PressAsync(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `GotoAsync(${quote(action.url)})`;
          case "select":
            return `SelectOptionAsync(${quote(action.selector)}, ${formatObject(action.options)})`;
        }
      }
      generateHeader(options2) {
        const formatter = new CSharpFormatter(0);
        formatter.add(`
      using Microsoft.Playwright;
      using System;
      using System.Threading.Tasks;

      class Program
      {
          public static async Task Main()
          {
              using var playwright = await Playwright.CreateAsync();
              await using var browser = await playwright.${toPascal(options2.browserName)}.LaunchAsync(${formatObject(options2.launchOptions, "    ", "BrowserTypeLaunchOptions")});
              var context = await browser.NewContextAsync(${formatContextOptions(options2.contextOptions, options2.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
        await context.StorageStateAsync(new BrowserContextStorageStateOptions
        {
            Path = ${quote(saveStorage)}
        });
` : "";
        return `${storageStateLine}    }
}
`;
      }
    };
    exports.CSharpLanguageGenerator = CSharpLanguageGenerator;
    function formatObject(value, indent = "    ", name = "") {
      if (typeof value === "string") {
        if (["permissions", "colorScheme", "modifiers", "button"].includes(name))
          return `${getClassName(name)}.${toPascal(value)}`;
        return quote(value);
      }
      if (Array.isArray(value))
        return `new[] { ${value.map((o) => formatObject(o, indent, name)).join(", ")} }`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return name ? `new ${getClassName(name)}` : "";
        const tokens = [];
        for (const key of keys) {
          const property = getPropertyName(key);
          tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);
        }
        if (name)
          return `new ${getClassName(name)}
{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
        return `{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
      }
      if (name === "latitude" || name === "longitude")
        return String(value) + "m";
      return String(value);
    }
    function getClassName(value) {
      switch (value) {
        case "viewport":
          return "ViewportSize";
        case "proxy":
          return "ProxySettings";
        case "permissions":
          return "ContextPermission";
        case "modifiers":
          return "KeyboardModifier";
        case "button":
          return "MouseButton";
        default:
          return toPascal(value);
      }
    }
    function getPropertyName(key) {
      switch (key) {
        case "storageState":
          return "StorageStatePath";
        case "viewport":
          return "ViewportSize";
        default:
          return toPascal(key);
      }
    }
    function toPascal(value) {
      return value[0].toUpperCase() + value.slice(1);
    }
    function formatContextOptions(options2, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device) {
        if (!Object.entries(options2).length)
          return "";
        return formatObject(options2, "    ", "BrowserNewContextOptions");
      }
      options2 = (0, _language.sanitizeDeviceOptions)(device, options2);
      if (!Object.entries(options2).length)
        return `playwright.Devices[${quote(deviceName)}]`;
      return formatObject(options2, "    ", `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);
    }
    var CSharpFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]") || line.includes("});") || line === ");")
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          line = spaces + extraSpaces + line;
          if (line.endsWith("{") || line.endsWith("[") || line.endsWith("("))
            spaces += this._baseIndent;
          if (line.endsWith("));"))
            spaces = spaces.substring(this._baseIndent.length);
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    function quote(text) {
      return (0, _utils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/python.js
var require_python = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/python.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PythonLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils = require_utils3();
    var _deviceDescriptors = _interopRequireDefault(require_deviceDescriptors());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PythonLanguageGenerator = class {
      constructor(isAsync) {
        this.id = "python";
        this.fileName = "Python";
        this.highlighter = "python";
        this._awaitPrefix = void 0;
        this._asyncPrefix = void 0;
        this._isAsync = void 0;
        this.id = isAsync ? "python-async" : "python";
        this.fileName = isAsync ? "Python Async" : "Python";
        this._isAsync = isAsync;
        this._awaitPrefix = isAsync ? "await " : "";
        this._asyncPrefix = isAsync ? "async " : "";
      }
      generateAction(actionInContext) {
        const {
          action,
          pageAlias
        } = actionInContext;
        const formatter = new PythonFormatter(4);
        formatter.newLine();
        formatter.add("# " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote(action.url)})`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${formatOptions({
          name: actionInContext.frameName
        }, false)})` : `${pageAlias}.frame(${formatOptions({
          url: actionInContext.frameUrl
        }, false)})`;
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog)
          formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);
        const actionCall = this._generateActionCall(action);
        let code = `${this._awaitPrefix}${subject}.${actionCall}`;
        if (signals.popup) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as popup_info {
        ${code}
      }
      ${signals.popup.popupAlias} = ${this._awaitPrefix}popup_info.value`;
        }
        if (signals.download) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download_info {
        ${code}
      }
      download = ${this._awaitPrefix}download_info.value`;
        }
        if (signals.waitForNavigation) {
          code = `
      # ${this._asyncPrefix}with ${pageAlias}.expect_navigation(url=${quote(signals.waitForNavigation.url)}):
      ${this._asyncPrefix}with ${pageAlias}.expect_navigation() {
        ${code}
      }`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
          formatter.add(`  # assert ${pageAlias}.url == ${quote(signals.assertNavigation.url)}`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options2 = {};
            if (action.button !== "left")
              options2.button = action.button;
            if (modifiers.length)
              options2.modifiers = modifiers;
            if (action.clickCount > 2)
              options2.clickCount = action.clickCount;
            if (action.position)
              options2.position = action.position;
            const optionsString = formatOptions(options2, true);
            return `${method}(${quote(action.selector)}${optionsString})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `set_input_files(${quote(action.selector)}, ${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return `select_option(${quote(action.selector)}, ${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
        }
      }
      generateHeader(options2) {
        const formatter = new PythonFormatter();
        if (this._isAsync) {
          formatter.add(`
import asyncio

from playwright.async_api import Playwright, async_playwright


async def run(playwright: Playwright) -> None {
    browser = await playwright.${options2.browserName}.launch(${formatOptions(options2.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions(options2.contextOptions, options2.deviceName)})`);
        } else {
          formatter.add(`
from playwright.sync_api import Playwright, sync_playwright


def run(playwright: Playwright) -> None {
    browser = playwright.${options2.browserName}.launch(${formatOptions(options2.launchOptions, false)})
    context = browser.new_context(${formatContextOptions(options2.contextOptions, options2.deviceName)})`);
        }
        return formatter.format();
      }
      generateFooter(saveStorage) {
        if (this._isAsync) {
          const storageStateLine = saveStorage ? `
    await context.storage_state(path=${quote(saveStorage)})` : "";
          return `
    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()


async def main() -> None:
    async with async_playwright() as playwright:
        await run(playwright)


asyncio.run(main())
`;
        } else {
          const storageStateLine = saveStorage ? `
    context.storage_state(path=${quote(saveStorage)})` : "";
          return `
    # ---------------------${storageStateLine}
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)
`;
        }
      }
    };
    exports.PythonLanguageGenerator = PythonLanguageGenerator;
    function formatValue(value) {
      if (value === false)
        return "False";
      if (value === true)
        return "True";
      if (value === void 0)
        return "None";
      if (Array.isArray(value))
        return `[${value.map(formatValue).join(", ")}]`;
      if (typeof value === "string")
        return quote(value);
      if (typeof value === "object")
        return JSON.stringify(value);
      return String(value);
    }
    function toSnakeCase(name) {
      const toSnakeCaseRegex = /((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))/g;
      return name.replace(toSnakeCaseRegex, `_$1`).toLowerCase();
    }
    function formatOptions(value, hasArguments) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return (hasArguments ? ", " : "") + keys.map((key) => `${toSnakeCase(key)}=${formatValue(value[key])}`).join(", ");
    }
    function formatContextOptions(options2, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device)
        return formatOptions(options2, false);
      return `**playwright.devices[${quote(deviceName)}]` + formatOptions((0, _language.sanitizeDeviceOptions)(device, options2), true);
    }
    var PythonFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        const lines = [];
        this._lines.forEach((line) => {
          if (line === "")
            return lines.push(line);
          if (line === "}") {
            spaces = spaces.substring(this._baseIndent.length);
            return;
          }
          line = spaces + line;
          if (line.endsWith("{")) {
            spaces += this._baseIndent;
            line = line.substring(0, line.length - 1).trimEnd() + ":";
          }
          return lines.push(this._baseOffset + line);
        });
        return lines.join("\n");
      }
    };
    function quote(text) {
      return (0, _utils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/generated/recorderSource.js
var require_recorderSource = __commonJS({
  "node_modules/playwright-core/lib/generated/recorderSource.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.source = void 0;
    var source = 'var pwExport;(()=>{"use strict";var e={317:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCSS=function(e,t){let n;try{n=o.tokenize(e),n[n.length-1]instanceof o.EOFToken||n.push(new o.EOFToken)}catch(t){const n=t.message+` while parsing selector "${e}"`,o=(t.stack||"").indexOf(t.message);throw-1!==o&&(t.stack=t.stack.substring(0,o)+n+t.stack.substring(o+t.message.length)),t.message=n,t}const r=n.find((e=>e instanceof o.AtKeywordToken||e instanceof o.BadStringToken||e instanceof o.BadURLToken||e instanceof o.ColumnToken||e instanceof o.CDOToken||e instanceof o.CDCToken||e instanceof o.SemicolonToken||e instanceof o.OpenCurlyToken||e instanceof o.CloseCurlyToken||e instanceof o.URLToken||e instanceof o.PercentageToken));if(r)throw new Error(`Unsupported token "${r.toSource()}" while parsing selector "${e}"`);let i=0;const s=new Set;function c(){return new Error(`Unexpected token "${n[i].toSource()}" while parsing selector "${e}"`)}function a(){for(;n[i]instanceof o.WhitespaceToken;)i++}function l(e=i){return n[e]instanceof o.IdentToken}function h(e=i){return n[e]instanceof o.CommaToken}function u(e=i){return n[e]instanceof o.CloseParenToken}function p(e=i){return n[e]instanceof o.DelimToken&&"*"===n[e].value}function f(e=i){return n[e]instanceof o.EOFToken}function d(e=i){return n[e]instanceof o.DelimToken&&[">","+","~"].includes(n[e].value)}function m(e=i){return h(e)||u(e)||f(e)||d(e)||n[e]instanceof o.WhitespaceToken}function g(){const e=[y()];for(;a(),h();)i++,e.push(y());return e}function y(){return a(),function(e=i){return n[e]instanceof o.NumberToken}()||function(e=i){return n[e]instanceof o.StringToken}()?n[i++].value:function(){const e={simples:[]};for(a(),d()?e.simples.push({selector:{functions:[{name:"scope",args:[]}]},combinator:""}):e.simples.push({selector:_(),combinator:""});;){if(a(),d())e.simples[e.simples.length-1].combinator=n[i++].value,a();else if(m())break;e.simples.push({combinator:"",selector:_()})}return e}()}function _(){let e="";const r=[];for(;!m();)if(l()||p())e+=n[i++].toSource();else if(n[i]instanceof o.HashToken)e+=n[i++].toSource();else if(n[i]instanceof o.DelimToken&&"."===n[i].value){if(i++,!l())throw c();e+="."+n[i++].toSource()}else if(n[i]instanceof o.ColonToken)if(i++,l())if(t.has(n[i].value.toLowerCase())){const e=n[i++].value.toLowerCase();r.push({name:e,args:[]}),s.add(e)}else e+=":"+n[i++].toSource();else{if(!(n[i]instanceof o.FunctionToken))throw c();{const o=n[i++].value.toLowerCase();if(t.has(o)?(r.push({name:o,args:g()}),s.add(o)):e+=`:${o}(${v()})`,a(),!u())throw c();i++}}else{if(!(n[i]instanceof o.OpenSquareToken))throw c();for(e+="[",i++;!(n[i]instanceof o.CloseSquareToken||f());)e+=n[i++].toSource();if(!(n[i]instanceof o.CloseSquareToken))throw c();e+="]",i++}if(!e&&!r.length)throw c();return{css:e||void 0,functions:r}}function v(){let e="";for(;!u()&&!f();)e+=n[i++].toSource();return e}const w=g();if(!f())throw new Error(`Error while parsing selector "${e}"`);if(w.some((e=>"object"!=typeof e||!("simples"in e))))throw new Error(`Error while parsing selector "${e}"`);return{selector:w,names:Array.from(s)}},t.serializeSelector=function e(t){return t.map((t=>"string"==typeof t?`"${t}"`:"number"==typeof t?String(t):t.simples.map((({selector:t,combinator:n})=>{let o=t.css||"";return o+=t.functions.map((t=>`:${t.name}(${e(t.args)})`)).join(""),n&&(o+=" "+n),o})).join(" "))).join(", ")};var o=function(e,t){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=r(t);if(n&&n.has(e))return n.get(e);var o={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var c=i?Object.getOwnPropertyDescriptor(e,s):null;c&&(c.get||c.set)?Object.defineProperty(o,s,c):o[s]=e[s]}return o.default=e,n&&n.set(e,o),o}(n(503));function r(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(r=function(e){return e?n:t})(e)}},503:(e,t)=>{var n,o;n=function(e){var t=function(e,t,n){return e>=t&&e<=n};function n(e){return t(e,48,57)}function o(e){return n(e)||t(e,65,70)||t(e,97,102)}function r(e){return function(e){return t(e,65,90)}(e)||function(e){return t(e,97,122)}(e)}function i(e){return r(e)||function(e){return e>=128}(e)||95==e}function s(e){return i(e)||n(e)||45==e}function c(e){return t(e,0,8)||11==e||t(e,14,31)||127==e}function a(e){return 10==e}function l(e){return a(e)||9==e||32==e}var h=function(e){this.message=e};function u(e){if(e<=65535)return String.fromCharCode(e);e-=Math.pow(2,16);var t=Math.floor(e/Math.pow(2,10))+55296,n=e%Math.pow(2,10)+56320;return String.fromCharCode(t)+String.fromCharCode(n)}function p(){throw"Abstract Base Class"}function f(){return this}function d(){return this}function m(){return this}function g(){return this}function y(){return this}function _(){return this}function v(){return this}function w(){return this}function E(){throw"Abstract Base Class"}function S(){return this.value="{",this.mirror="}",this}function T(){return this.value="}",this.mirror="{",this}function b(){return this.value="[",this.mirror="]",this}function k(){return this.value="]",this.mirror="[",this}function M(){return this.value="(",this.mirror=")",this}function x(){return this.value=")",this.mirror="(",this}function C(){return this}function P(){return this}function A(){return this}function N(){return this}function O(){return this}function R(){return this}function j(){return this}function I(e){return this.value=u(e),this}function D(){throw"Abstract Base Class"}function L(e){this.value=e}function $(e){this.value=e,this.mirror=")"}function U(e){this.value=e}function q(e){this.value=e,this.type="unrestricted"}function G(e){this.value=e}function F(e){this.value=e}function H(){this.value=null,this.type="integer",this.repr=""}function K(){this.value=null,this.repr=""}function B(){this.value=null,this.type="integer",this.repr="",this.unit=""}function W(e){for(var n="",o=(e=""+e).charCodeAt(0),r=0;r<e.length;r++){var i=e.charCodeAt(r);if(0==i)throw new h("Invalid character: the input contains U+0000.");t(i,1,31)||127==i||0==r&&t(i,48,57)||1==r&&t(i,48,57)&&45==o?n+="\\\\"+i.toString(16)+" ":i>=128||45==i||95==i||t(i,48,57)||t(i,65,90)||t(i,97,122)?n+=e[r]:n+="\\\\"+e[r]}return n}function J(e){e=""+e;for(var n="",o=0;o<e.length;o++){var r=e.charCodeAt(o);if(0==r)throw new h("Invalid character: the input contains U+0000.");t(r,1,31)||127==r?n+="\\\\"+r.toString(16)+" ":n+=34==r||92==r?"\\\\"+e[o]:e[o]}return n}(h.prototype=new Error).name="InvalidCharacterError",p.prototype.toJSON=function(){return{token:this.tokenType}},p.prototype.toString=function(){return this.tokenType},p.prototype.toSource=function(){return""+this},f.prototype=Object.create(p.prototype),f.prototype.tokenType="BADSTRING",d.prototype=Object.create(p.prototype),d.prototype.tokenType="BADURL",m.prototype=Object.create(p.prototype),m.prototype.tokenType="WHITESPACE",m.prototype.toString=function(){return"WS"},m.prototype.toSource=function(){return" "},g.prototype=Object.create(p.prototype),g.prototype.tokenType="CDO",g.prototype.toSource=function(){return"\\x3c!--"},y.prototype=Object.create(p.prototype),y.prototype.tokenType="CDC",y.prototype.toSource=function(){return"--\\x3e"},_.prototype=Object.create(p.prototype),_.prototype.tokenType=":",v.prototype=Object.create(p.prototype),v.prototype.tokenType=";",w.prototype=Object.create(p.prototype),w.prototype.tokenType=",",E.prototype=Object.create(p.prototype),S.prototype=Object.create(E.prototype),S.prototype.tokenType="{",T.prototype=Object.create(E.prototype),T.prototype.tokenType="}",b.prototype=Object.create(E.prototype),b.prototype.tokenType="[",k.prototype=Object.create(E.prototype),k.prototype.tokenType="]",M.prototype=Object.create(E.prototype),M.prototype.tokenType="(",x.prototype=Object.create(E.prototype),x.prototype.tokenType=")",C.prototype=Object.create(p.prototype),C.prototype.tokenType="~=",P.prototype=Object.create(p.prototype),P.prototype.tokenType="|=",A.prototype=Object.create(p.prototype),A.prototype.tokenType="^=",N.prototype=Object.create(p.prototype),N.prototype.tokenType="$=",O.prototype=Object.create(p.prototype),O.prototype.tokenType="*=",R.prototype=Object.create(p.prototype),R.prototype.tokenType="||",j.prototype=Object.create(p.prototype),j.prototype.tokenType="EOF",j.prototype.toSource=function(){return""},I.prototype=Object.create(p.prototype),I.prototype.tokenType="DELIM",I.prototype.toString=function(){return"DELIM("+this.value+")"},I.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},I.prototype.toSource=function(){return"\\\\"==this.value?"\\\\\\n":this.value},D.prototype=Object.create(p.prototype),D.prototype.ASCIIMatch=function(e){return this.value.toLowerCase()==e.toLowerCase()},D.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},L.prototype=Object.create(D.prototype),L.prototype.tokenType="IDENT",L.prototype.toString=function(){return"IDENT("+this.value+")"},L.prototype.toSource=function(){return W(this.value)},$.prototype=Object.create(D.prototype),$.prototype.tokenType="FUNCTION",$.prototype.toString=function(){return"FUNCTION("+this.value+")"},$.prototype.toSource=function(){return W(this.value)+"("},U.prototype=Object.create(D.prototype),U.prototype.tokenType="AT-KEYWORD",U.prototype.toString=function(){return"AT("+this.value+")"},U.prototype.toSource=function(){return"@"+W(this.value)},q.prototype=Object.create(D.prototype),q.prototype.tokenType="HASH",q.prototype.toString=function(){return"HASH("+this.value+")"},q.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e},q.prototype.toSource=function(){return"id"==this.type?"#"+W(this.value):"#"+function(e){for(var n="",o=((e=""+e).charCodeAt(0),0);o<e.length;o++){var r=e.charCodeAt(o);if(0==r)throw new h("Invalid character: the input contains U+0000.");r>=128||45==r||95==r||t(r,48,57)||t(r,65,90)||t(r,97,122)?n+=e[o]:n+="\\\\"+r.toString(16)+" "}return n}(this.value)},G.prototype=Object.create(D.prototype),G.prototype.tokenType="STRING",G.prototype.toString=function(){return\'"\'+J(this.value)+\'"\'},F.prototype=Object.create(D.prototype),F.prototype.tokenType="URL",F.prototype.toString=function(){return"URL("+this.value+")"},F.prototype.toSource=function(){return\'url("\'+J(this.value)+\'")\'},H.prototype=Object.create(p.prototype),H.prototype.tokenType="NUMBER",H.prototype.toString=function(){return"integer"==this.type?"INT("+this.value+")":"NUMBER("+this.value+")"},H.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e},H.prototype.toSource=function(){return this.repr},K.prototype=Object.create(p.prototype),K.prototype.tokenType="PERCENTAGE",K.prototype.toString=function(){return"PERCENTAGE("+this.value+")"},K.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.repr=this.repr,e},K.prototype.toSource=function(){return this.repr+"%"},B.prototype=Object.create(p.prototype),B.prototype.tokenType="DIMENSION",B.prototype.toString=function(){return"DIM("+this.value+","+this.unit+")"},B.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e.unit=this.unit,e},B.prototype.toSource=function(){var e=this.repr,n=W(this.unit);return"e"!=n[0].toLowerCase()||"-"!=n[1]&&!t(n.charCodeAt(1),48,57)||(n="\\\\65 "+n.slice(1,n.length)),e+n},e.tokenize=function(e){e=function(e){for(var n=[],o=0;o<e.length;o++){var r=e.charCodeAt(o);if(13==r&&10==e.charCodeAt(o+1)&&(r=10,o++),13!=r&&12!=r||(r=10),0==r&&(r=65533),t(r,55296,56319)&&t(e.charCodeAt(o+1),56320,57343)){var i=r-55296,s=e.charCodeAt(o+1)-56320;r=Math.pow(2,16)+i*Math.pow(2,10)+s,o++}n.push(r)}return n}(e);for(var r,h=-1,p=[],E=0,D=0,W=0,J={line:E,column:D},Q=function(t){return t>=e.length?-1:e[t]},z=function(e){if(void 0===e&&(e=1),e>3)throw"Spec Error: no more than three codepoints of lookahead.";return Q(h+e)},V=function(e){return void 0===e&&(e=1),a(r=Q(h+=e))?(E+=1,W=D,D=0):D+=e,!0},X=function(){return h-=1,a(r)?(E-=1,D=W):D-=1,J.line=E,J.column=D,!0},Y=function(e){return void 0===e&&(e=r),-1==e},Z=function(){return console.log("Parse error at index "+h+", processing codepoint 0x"+r.toString(16)+"."),!0},ee=function(){if(te(),V(),l(r)){for(;l(z());)V();return new m}if(34==r)return re();if(35==r){if(s(z())||ce(z(1),z(2))){var e=new q;return le(z(1),z(2),z(3))&&(e.type="id"),e.value=pe(),e}return new I(r)}return 36==r?61==z()?(V(),new N):new I(r):39==r?re():40==r?new M:41==r?new x:42==r?61==z()?(V(),new O):new I(r):43==r?ue()?(X(),ne()):new I(r):44==r?new w:45==r?ue()?(X(),ne()):45==z(1)&&62==z(2)?(V(2),new y):he()?(X(),oe()):new I(r):46==r?ue()?(X(),ne()):new I(r):58==r?new _:59==r?new v:60==r?33==z(1)&&45==z(2)&&45==z(3)?(V(3),new g):new I(r):64==r?le(z(1),z(2),z(3))?new U(pe()):new I(r):91==r?new b:92==r?ae()?(X(),oe()):(Z(),new I(r)):93==r?new k:94==r?61==z()?(V(),new A):new I(r):123==r?new S:124==r?61==z()?(V(),new P):124==z()?(V(),new R):new I(r):125==r?new T:126==r?61==z()?(V(),new C):new I(r):n(r)?(X(),ne()):i(r)?(X(),oe()):Y()?new j:new I(r)},te=function(){for(;47==z(1)&&42==z(2);)for(V(2);;){if(V(),42==r&&47==z()){V();break}if(Y())return void Z()}},ne=function(){var e,t=fe();return le(z(1),z(2),z(3))?((e=new B).value=t.value,e.repr=t.repr,e.type=t.type,e.unit=pe(),e):37==z()?(V(),(e=new K).value=t.value,e.repr=t.repr,e):((e=new H).value=t.value,e.repr=t.repr,e.type=t.type,e)},oe=function(){var e=pe();if("url"==e.toLowerCase()&&40==z()){for(V();l(z(1))&&l(z(2));)V();return 34==z()||39==z()?new $(e):!l(z())||34!=z(2)&&39!=z(2)?ie():new $(e)}return 40==z()?(V(),new $(e)):new L(e)},re=function(e){void 0===e&&(e=r);for(var t="";V();){if(r==e||Y())return new G(t);if(a(r))return Z(),X(),new f;92==r?Y(z())||(a(z())?V():t+=u(se())):t+=u(r)}},ie=function(){for(var e=new F("");l(z());)V();if(Y(z()))return e;for(;V();){if(41==r||Y())return e;if(l(r)){for(;l(z());)V();return 41==z()||Y(z())?(V(),e):(me(),new d)}if(34==r||39==r||40==r||c(r))return Z(),me(),new d;if(92==r){if(!ae())return Z(),me(),new d;e.value+=u(se())}else e.value+=u(r)}},se=function(){if(V(),o(r)){for(var e=[r],t=0;t<5&&o(z());t++)V(),e.push(r);l(z())&&V();var n=parseInt(e.map((function(e){return String.fromCharCode(e)})).join(""),16);return n>1114111&&(n=65533),n}return Y()?65533:r},ce=function(e,t){return 92==e&&!a(t)},ae=function(){return ce(r,z())},le=function(e,t,n){return 45==e?i(t)||45==t||ce(t,n):!!i(e)||92==e&&ce(e,t)},he=function(){return le(r,z(1),z(2))},ue=function(){return e=r,t=z(1),o=z(2),43==e||45==e?!!n(t)||!(46!=t||!n(o)):46==e?!!n(t):!!n(e);var e,t,o},pe=function(){for(var e="";V();)if(s(r))e+=u(r);else{if(!ae())return X(),e;e+=u(se())}},fe=function(){var e=[],t="integer";for(43!=z()&&45!=z()||(V(),e+=u(r));n(z());)V(),e+=u(r);if(46==z(1)&&n(z(2)))for(V(),e+=u(r),V(),e+=u(r),t="number";n(z());)V(),e+=u(r);var o=z(1),i=z(2),s=z(3);if(69!=o&&101!=o||!n(i)){if((69==o||101==o)&&(43==i||45==i)&&n(s))for(V(),e+=u(r),V(),e+=u(r),V(),e+=u(r),t="number";n(z());)V(),e+=u(r)}else for(V(),e+=u(r),V(),e+=u(r),t="number";n(z());)V(),e+=u(r);return{type:t,value:de(e),repr:e}},de=function(e){return+e},me=function(){for(;V();){if(41==r||Y())return;ae()&&se()}},ge=0;!Y(z());)if(p.push(ee()),++ge>2*e.length)return"I\'m infinite-looping!";return p},e.IdentToken=L,e.FunctionToken=$,e.AtKeywordToken=U,e.HashToken=q,e.StringToken=G,e.BadStringToken=f,e.URLToken=F,e.BadURLToken=d,e.DelimToken=I,e.NumberToken=H,e.PercentageToken=K,e.DimensionToken=B,e.IncludeMatchToken=C,e.DashMatchToken=P,e.PrefixMatchToken=A,e.SuffixMatchToken=N,e.SubstringMatchToken=O,e.ColumnToken=R,e.WhitespaceToken=m,e.CDOToken=g,e.CDCToken=y,e.ColonToken=_,e.SemicolonToken=v,e.CommaToken=w,e.OpenParenToken=M,e.CloseParenToken=x,e.OpenSquareToken=b,e.CloseSquareToken=k,e.OpenCurlyToken=S,e.CloseCurlyToken=T,e.EOFToken=j,e.CSSParserToken=p,e.GroupingToken=E},void 0===(o=n.apply(t,[t]))||(e.exports=o)},461:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSelector=i,t.splitSelectorByFrame=function(e){const t=i(e),n=[];let o={parts:[]},r=0;for(let e=0;e<t.parts.length;++e){const i=t.parts[e];if("control"!==i.name||"enter-frame"!==i.body)t.capture===e&&(o.capture=e-r),o.parts.push(i);else{if(!o.parts.length)throw new Error("Selector cannot start with entering frame, select the iframe first");n.push(o),o={parts:[]},r=e+1}}if(!o.parts.length)throw new Error(`Selector cannot end with entering frame, while parsing selector ${e}`);if(n.push(o),"number"==typeof t.capture&&"number"!=typeof n[n.length-1].capture)throw new Error("Can not capture the selector before diving into the frame. Only use * after the last frame has been selected");return n},t.stringifySelector=function(e){return"string"==typeof e?e:e.parts.map(((t,n)=>{const o="css"===t.name?"":t.name+"=";return`${n===e.capture?"*":""}${o}${t.source}`})).join(" >> ")},t.customCSSNames=void 0;var o=n(317);const r=new Set(["not","is","where","has","scope","light","visible","text","text-matches","text-is","has-text","above","below","right-of","left-of","near","nth-match"]);function i(e){const t=function(e){let t,n=0,o=0;const r={parts:[]},i=()=>{const t=e.substring(o,n).trim(),i=t.indexOf("=");let s,c;-1!==i&&t.substring(0,i).trim().match(/^[a-zA-Z_0-9-+:*]+$/)?(s=t.substring(0,i).trim(),c=t.substring(i+1)):t.length>1&&\'"\'===t[0]&&\'"\'===t[t.length-1]||t.length>1&&"\'"===t[0]&&"\'"===t[t.length-1]?(s="text",c=t):/^\\(*\\/\\//.test(t)||t.startsWith("..")?(s="xpath",c=t):(s="css",c=t);let a=!1;if("*"===s[0]&&(a=!0,s=s.substring(1)),r.parts.push({name:s,body:c}),a){if(void 0!==r.capture)throw new Error("Only one of the selectors can capture using * modifier");r.capture=r.parts.length-1}};if(!e.includes(">>"))return n=e.length,i(),r;for(;n<e.length;){const r=e[n];"\\\\"===r&&n+1<e.length?n+=2:r===t?(t=void 0,n++):t||\'"\'!==r&&"\'"!==r&&"`"!==r?t||">"!==r||">"!==e[n+1]?n++:(i(),n+=2,o=n):(t=r,n++)}return i(),r}(e),n=t.parts.map((e=>"css"===e.name||"css:light"===e.name?("css:light"===e.name&&(e.body=":light("+e.body+")"),{name:"css",body:(0,o.parseCSS)(e.body,r).selector,source:e.body}):{...e,source:e.body}));return{capture:t.capture,parts:n}}t.customCSSNames=r},848:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createLaxTextMatcher=d,t.createStrictTextMatcher=m,t.createRegexTextMatcher=g,t.elementText=_,t.elementMatchesText=v,t.parentElementOrShadowHost=x,t.isVisible=A,t.SelectorEvaluatorImpl=void 0;var o=n(461);t.SelectorEvaluatorImpl=class{constructor(e){this._engines=new Map,this._cacheQueryCSS=new Map,this._cacheMatches=new Map,this._cacheQuery=new Map,this._cacheMatchesSimple=new Map,this._cacheMatchesParents=new Map,this._cacheCallMatches=new Map,this._cacheCallQuery=new Map,this._cacheQuerySimple=new Map,this._cacheText=new Map,this._scoreMap=void 0,this._retainCacheCounter=0;for(const[t,n]of e)this._engines.set(t,n);this._engines.set("not",c),this._engines.set("is",r),this._engines.set("where",r),this._engines.set("has",i),this._engines.set("scope",s),this._engines.set("light",a),this._engines.set("visible",l),this._engines.set("text",h),this._engines.set("text-is",u),this._engines.set("text-matches",p),this._engines.set("has-text",f),this._engines.set("right-of",k("right-of",w)),this._engines.set("left-of",k("left-of",E)),this._engines.set("above",k("above",S)),this._engines.set("below",k("below",T)),this._engines.set("near",k("near",b)),this._engines.set("nth-match",M);const t=[...this._engines.keys()];t.sort();const n=[...o.customCSSNames];if(n.sort(),t.join("|")!==n.join("|"))throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${t.join("|")} vs ${n.join("|")}`)}begin(){++this._retainCacheCounter}end(){--this._retainCacheCounter,this._retainCacheCounter||(this._cacheQueryCSS.clear(),this._cacheMatches.clear(),this._cacheQuery.clear(),this._cacheMatchesSimple.clear(),this._cacheMatchesParents.clear(),this._cacheCallMatches.clear(),this._cacheCallQuery.clear(),this._cacheQuerySimple.clear(),this._cacheText.clear())}_cached(e,t,n,o){e.has(t)||e.set(t,[]);const r=e.get(t),i=r.find((e=>n.every(((t,n)=>e.rest[n]===t))));if(i)return i.result;const s=o();return r.push({rest:n,result:s}),s}_checkSelector(e){if("object"!=typeof e||!e||!(Array.isArray(e)||"simples"in e&&e.simples.length))throw new Error(`Malformed selector "${e}"`);return e}matches(e,t,n){const o=this._checkSelector(t);this.begin();try{return this._cached(this._cacheMatches,e,[o,n.scope,n.pierceShadow],(()=>Array.isArray(o)?this._matchesEngine(r,e,o,n):!!this._matchesSimple(e,o.simples[o.simples.length-1].selector,n)&&this._matchesParents(e,o,o.simples.length-2,n)))}finally{this.end()}}query(e,t){const n=this._checkSelector(t);this.begin();try{return this._cached(this._cacheQuery,n,[e.scope,e.pierceShadow],(()=>{if(Array.isArray(n))return this._queryEngine(r,e,n);const t=this._scoreMap;this._scoreMap=new Map;let o=this._querySimple(e,n.simples[n.simples.length-1].selector);return o=o.filter((t=>this._matchesParents(t,n,n.simples.length-2,e))),this._scoreMap.size&&o.sort(((e,t)=>{const n=this._scoreMap.get(e),o=this._scoreMap.get(t);return n===o?0:void 0===n?1:void 0===o?-1:n-o})),this._scoreMap=t,o}))}finally{this.end()}}_markScore(e,t){this._scoreMap&&this._scoreMap.set(e,t)}_matchesSimple(e,t,n){return this._cached(this._cacheMatchesSimple,e,[t,n.scope,n.pierceShadow],(()=>{if(!t.functions.some((e=>"scope"===e.name||"is"===e.name))&&e===n.scope)return!1;if(t.css&&!this._matchesCSS(e,t.css))return!1;for(const o of t.functions)if(!this._matchesEngine(this._getEngine(o.name),e,o.args,n))return!1;return!0}))}_querySimple(e,t){return t.functions.length?this._cached(this._cacheQuerySimple,t,[e.scope,e.pierceShadow],(()=>{let n=t.css;const o=t.functions;let r;"*"===n&&o.length&&(n=void 0);let i=-1;void 0!==n?r=this._queryCSS(e,n):(i=o.findIndex((e=>void 0!==this._getEngine(e.name).query)),-1===i&&(i=0),r=this._queryEngine(this._getEngine(o[i].name),e,o[i].args));for(let t=0;t<o.length;t++){if(t===i)continue;const n=this._getEngine(o[t].name);void 0!==n.matches&&(r=r.filter((r=>this._matchesEngine(n,r,o[t].args,e))))}for(let t=0;t<o.length;t++){if(t===i)continue;const n=this._getEngine(o[t].name);void 0===n.matches&&(r=r.filter((r=>this._matchesEngine(n,r,o[t].args,e))))}return r})):this._queryCSS(e,t.css||"*")}_matchesParents(e,t,n,o){return n<0||this._cached(this._cacheMatchesParents,e,[t,n,o.scope,o.pierceShadow],(()=>{const{selector:r,combinator:i}=t.simples[n];if(">"===i){const i=C(e,o);return!(!i||!this._matchesSimple(i,r,o))&&this._matchesParents(i,t,n-1,o)}if("+"===i){const i=P(e,o);return!(!i||!this._matchesSimple(i,r,o))&&this._matchesParents(i,t,n-1,o)}if(""===i){let i=C(e,o);for(;i;){if(this._matchesSimple(i,r,o)){if(this._matchesParents(i,t,n-1,o))return!0;if(""===t.simples[n-1].combinator)break}i=C(i,o)}return!1}if("~"===i){let i=P(e,o);for(;i;){if(this._matchesSimple(i,r,o)){if(this._matchesParents(i,t,n-1,o))return!0;if("~"===t.simples[n-1].combinator)break}i=P(i,o)}return!1}if(">="===i){let i=e;for(;i;){if(this._matchesSimple(i,r,o)){if(this._matchesParents(i,t,n-1,o))return!0;if(""===t.simples[n-1].combinator)break}i=C(i,o)}return!1}throw new Error(`Unsupported combinator "${i}"`)}))}_matchesEngine(e,t,n,o){if(e.matches)return this._callMatches(e,t,n,o);if(e.query)return this._callQuery(e,n,o).includes(t);throw new Error(\'Selector engine should implement "matches" or "query"\')}_queryEngine(e,t,n){if(e.query)return this._callQuery(e,n,t);if(e.matches)return this._queryCSS(t,"*").filter((o=>this._callMatches(e,o,n,t)));throw new Error(\'Selector engine should implement "matches" or "query"\')}_callMatches(e,t,n,o){return this._cached(this._cacheCallMatches,t,[e,o.scope,o.pierceShadow,...n],(()=>e.matches(t,n,o,this)))}_callQuery(e,t,n){return this._cached(this._cacheCallQuery,e,[n.scope,n.pierceShadow,...t],(()=>e.query(n,t,this)))}_matchesCSS(e,t){return e.matches(t)}_queryCSS(e,t){return this._cached(this._cacheQueryCSS,t,[e.scope,e.pierceShadow],(()=>{let n=[];return function o(r){if(n=n.concat([...r.querySelectorAll(t)]),e.pierceShadow){r.shadowRoot&&o(r.shadowRoot);for(const e of r.querySelectorAll("*"))e.shadowRoot&&o(e.shadowRoot)}}(e.scope),n}))}_getEngine(e){const t=this._engines.get(e);if(!t)throw new Error(`Unknown selector engine "${e}"`);return t}};const r={matches(e,t,n,o){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');return t.some((t=>o.matches(e,t,n)))},query(e,t,n){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');let o=[];for(const r of t)o=o.concat(n.query(e,r));return 1===t.length?o:function(e){const t=new Map,n=[],o=[];function r(e){let o=t.get(e);if(o)return o;const i=x(e);return i?r(i).children.push(e):n.push(e),o={children:[],taken:!1},t.set(e,o),o}return e.forEach((e=>r(e).taken=!0)),n.forEach((function e(n){const r=t.get(n);if(r.taken&&o.push(n),r.children.length>1){const e=new Set(r.children);r.children=[];let t=n.firstElementChild;for(;t&&r.children.length<e.size;)e.has(t)&&r.children.push(t),t=t.nextElementSibling;for(t=n.shadowRoot?n.shadowRoot.firstElementChild:null;t&&r.children.length<e.size;)e.has(t)&&r.children.push(t),t=t.nextElementSibling}r.children.forEach(e)})),o}(o)}},i={matches(e,t,n,o){if(0===t.length)throw new Error(\'"has" engine expects non-empty selector list\');return o.query({...n,scope:e},t).length>0}},s={matches(e,t,n,o){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');return 9===n.scope.nodeType?e===n.scope.documentElement:e===n.scope},query(e,t,n){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');if(9===e.scope.nodeType){const t=e.scope.documentElement;return t?[t]:[]}return 1===e.scope.nodeType?[e.scope]:[]}},c={matches(e,t,n,o){if(0===t.length)throw new Error(\'"not" engine expects non-empty selector list\');return!o.matches(e,t,n)}},a={query:(e,t,n)=>n.query({...e,pierceShadow:!1},t),matches:(e,t,n,o)=>o.matches(e,t,{...n,pierceShadow:!1})},l={matches(e,t,n,o){if(t.length)throw new Error(\'"visible" engine expects no arguments\');return A(e)}},h={matches(e,t,n,o){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text" engine expects a single string\');return"self"===v(o,e,d(t[0]))}},u={matches(e,t,n,o){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text-is" engine expects a single string\');return"none"!==v(o,e,m(t[0]))}},p={matches(e,t,n,o){if(0===t.length||"string"!=typeof t[0]||t.length>2||2===t.length&&"string"!=typeof t[1])throw new Error(\'"text-matches" engine expects a regexp body and optional regexp flags\');return"self"===v(o,e,g(t[0],2===t.length?t[1]:void 0))}},f={matches(e,t,n,o){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"has-text" engine expects a single string\');return!y(e)&&d(t[0])(_(o,e))}};function d(e){return e=e.trim().replace(/\\s+/g," ").toLowerCase(),t=>t.full.trim().replace(/\\s+/g," ").toLowerCase().includes(e)}function m(e){return e=e.trim().replace(/\\s+/g," "),t=>!e&&!t.immediate.length||t.immediate.some((t=>t.trim().replace(/\\s+/g," ")===e))}function g(e,t){const n=new RegExp(e,t);return e=>n.test(e.full)}function y(e){return"SCRIPT"===e.nodeName||"STYLE"===e.nodeName||document.head&&document.head.contains(e)}function _(e,t){let n=e._cacheText.get(t);if(void 0===n){if(n={full:"",immediate:[]},!y(t)){let o="";if(t instanceof HTMLInputElement&&("submit"===t.type||"button"===t.type))n={full:t.value,immediate:[t.value]};else{for(let r=t.firstChild;r;r=r.nextSibling)r.nodeType===Node.TEXT_NODE?(n.full+=r.nodeValue||"",o+=r.nodeValue||""):(o&&n.immediate.push(o),o="",r.nodeType===Node.ELEMENT_NODE&&(n.full+=_(e,r).full));o&&n.immediate.push(o),t.shadowRoot&&(n.full+=_(e,t.shadowRoot).full)}}e._cacheText.set(t,n)}return n}function v(e,t,n){if(y(t))return"none";if(!n(_(e,t)))return"none";for(let o=t.firstChild;o;o=o.nextSibling)if(o.nodeType===Node.ELEMENT_NODE&&n(_(e,o)))return"selfAndChildren";return t.shadowRoot&&n(_(e,t.shadowRoot))?"selfAndChildren":"self"}function w(e,t,n){const o=e.left-t.right;if(!(o<0||void 0!==n&&o>n))return o+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function E(e,t,n){const o=t.left-e.right;if(!(o<0||void 0!==n&&o>n))return o+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function S(e,t,n){const o=t.top-e.bottom;if(!(o<0||void 0!==n&&o>n))return o+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function T(e,t,n){const o=e.top-t.bottom;if(!(o<0||void 0!==n&&o>n))return o+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function b(e,t,n){const o=void 0===n?50:n;let r=0;return e.left-t.right>=0&&(r+=e.left-t.right),t.left-e.right>=0&&(r+=t.left-e.right),t.top-e.bottom>=0&&(r+=t.top-e.bottom),e.top-t.bottom>=0&&(r+=e.top-t.bottom),r>o?void 0:r}function k(e,t){return{matches(n,o,r,i){const s=o.length&&"number"==typeof o[o.length-1]?o[o.length-1]:void 0,c=void 0===s?o:o.slice(0,o.length-1);if(o.length<1+(void 0===s?0:1))throw new Error(`"${e}" engine expects a selector list and optional maximum distance in pixels`);const a=n.getBoundingClientRect();let l;for(const e of i.query(r,c)){if(e===n)continue;const o=t(a,e.getBoundingClientRect(),s);void 0!==o&&(void 0===l||o<l)&&(l=o)}return void 0!==l&&(i._markScore(n,l),!0)}}}const M={query(e,t,n){let o=t[t.length-1];if(t.length<2)throw new Error(\'"nth-match" engine expects non-empty selector list and an index argument\');if("number"!=typeof o||o<1)throw new Error(\'"nth-match" engine expects a one-based index as the last argument\');const i=r.query(e,t.slice(0,t.length-1),n);return o--,o<i.length?[i[o]]:[]}};function x(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:void 0}function C(e,t){if(e!==t.scope)return t.pierceShadow?x(e):e.parentElement||void 0}function P(e,t){if(e!==t.scope)return e.previousElementSibling||void 0}function A(e){if(!e.ownerDocument||!e.ownerDocument.defaultView)return!0;const t=e.ownerDocument.defaultView.getComputedStyle(e);if(!t||"hidden"===t.visibility)return!1;const n=e.getBoundingClientRect();return n.width>0&&n.height>0}},854:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.querySelector=function(e,t,n){try{const o=e.parseSelector(t);return{selector:t,elements:e.querySelectorAll(o,n)}}catch(e){return{selector:t,elements:[]}}},t.generateSelector=function(e,t){e._evaluator.begin();try{const n=function(e,t){if(t.ownerDocument.documentElement===t)return[{engine:"css",selector:"html",score:1}];const n=(l,u)=>{const d=u?r:i;let m=d.get(l);return void 0===m&&(m=((r,i)=>{const l=r===t;let u=i?function(e,t,n){if("SELECT"===t.nodeName)return[];const r=(0,o.elementText)(e._evaluator,t).full.trim().replace(/\\s+/g," ").substring(0,80);if(!r)return[];const i=[];let s=r;if((r.includes(\'"\')||r.includes(">>")||"/"===r[0])&&(s=`/.*${function(e){return e.replace(/[.*+?^>${}()|[\\]\\\\]/g,"\\\\$&")}(r)}.*/`),i.push({engine:"text",selector:s,score:10}),n&&s===r){let e=t.nodeName.toLocaleLowerCase();t.hasAttribute("role")&&(e+=`[role=${h(t.getAttribute("role"))}]`),i.push({engine:"css",selector:`${e}:has-text("${r}")`,score:30})}return i}(e,r,r===t).map((e=>[e])):[];r!==t&&(u=s(u));const d=function(e,t){const n=[];for(const e of["data-testid","data-test-id","data-test"])t.hasAttribute(e)&&n.push({engine:"css",selector:`[${e}=${h(t.getAttribute(e))}]`,score:1});if("INPUT"===t.nodeName){const e=t;e.placeholder&&n.push({engine:"css",selector:`[placeholder=${h(e.placeholder)}]`,score:10})}t.hasAttribute("aria-label")&&n.push({engine:"css",selector:`[aria-label=${h(t.getAttribute("aria-label"))}]`,score:10}),t.getAttribute("alt")&&["APPLET","AREA","IMG","INPUT"].includes(t.nodeName)&&n.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[alt=${h(t.getAttribute("alt"))}]`,score:10}),t.hasAttribute("role")&&n.push({engine:"css",selector:`${t.nodeName.toLocaleLowerCase()}[role=${h(t.getAttribute("role"))}]`,score:50}),t.getAttribute("name")&&["BUTTON","FORM","FIELDSET","IFRAME","INPUT","KEYGEN","OBJECT","OUTPUT","SELECT","TEXTAREA","MAP","META","PARAM"].includes(t.nodeName)&&n.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[name=${h(t.getAttribute("name"))}]`,score:50}),["INPUT","TEXTAREA"].includes(t.nodeName)&&"hidden"!==t.getAttribute("type")&&t.getAttribute("type")&&n.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[type=${h(t.getAttribute("type"))}]`,score:50}),["INPUT","TEXTAREA","SELECT"].includes(t.nodeName)&&n.push({engine:"css",selector:t.nodeName.toLowerCase(),score:50});const o=t.getAttribute("id");return o&&!function(e){let t,n=0;for(let o=0;o<e.length;++o){const r=e[o];let i;"-"!==r&&"_"!==r&&(i=r>="a"&&r<="z"?"lower":r>="A"&&r<="Z"?"upper":r>="0"&&r<="9"?"digit":"other","lower"!==i||"upper"!==t?(t&&t!==i&&++n,t=i):t=i)}return n>=e.length/4}(o)&&n.push({engine:"css",selector:a(o),score:100}),n.push({engine:"css",selector:t.nodeName.toLocaleLowerCase(),score:200}),n}(0,r).map((e=>[e]));let m=f(e,t.ownerDocument,r,[...u,...d],l);u=s(u);const g=t=>{const o=i&&!t.length,s=[...t,...d].filter((e=>!m||p(e)<p(m)));let a=s[0];if(a)for(let t=c(r);t;t=c(t)){const i=n(t,o);if(!i)continue;if(m&&p([...i,...a])>=p(m))continue;if(a=f(e,t,r,s,l),!a)return;const c=[...i,...a];(!m||p(c)<p(m))&&(m=c)}};return g(u),r===t&&u.length&&g([]),m})(l,u),d.set(l,m)),m};return n(t,!0)}(e,t=t.closest("button,select,input,[role=button],[role=checkbox],[role=radio]")||t),d=u(n||[l(e,t)]),m=e.parseSelector(d);return{selector:d,elements:e.querySelectorAll(m,t.ownerDocument)}}finally{r.clear(),i.clear(),e._evaluator.end()}};var o=n(848);const r=new Map,i=new Map;function s(e){return e.filter((e=>"/"!==e[0].selector[0]))}function c(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:null}function a(e){return/^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(e)?"#"+e:`[id="${e}"]`}function l(e,t){const n=1e7,o=t.ownerDocument,r=[];function i(n){const o=r.slice();n&&o.unshift(n);const i=o.join(" "),s=e.parseSelector(i);return e.querySelector(s,t.ownerDocument,!1)===t?i:void 0}for(let e=t;e&&e!==o;e=c(e)){const t=e.nodeName.toLowerCase();let o="";if(e.id){const t=a(e.id),r=i(t);if(r)return{engine:"css",selector:r,score:n};o=t}const s=e.parentNode,c=[...e.classList];for(let e=0;e<c.length;++e){const t="."+c.slice(0,e+1).join("."),r=i(t);if(r)return{engine:"css",selector:r,score:n};!o&&s&&1===s.querySelectorAll(t).length&&(o=t)}if(s){const r=[...s.children],c=0===r.filter((e=>e.nodeName.toLowerCase()===t)).indexOf(e)?t:`${t}:nth-child(${1+r.indexOf(e)})`,a=i(c);if(a)return{engine:"css",selector:a,score:n};o||(o=c)}else o||(o=t);r.unshift(o)}return{engine:"css",selector:i(),score:n}}function h(e){return`"${e.replace(/"/g,\'\\\\"\').replace(/\\n/g,"\\\\n")}"`}function u(e){const t=[];let n="";for(const{engine:o,selector:r}of e)t.length&&("css"!==n||"css"!==o||r.startsWith(":nth-match("))&&t.push(">>"),n=o,"css"===o?t.push(r):t.push(`${o}=${r}`);return t.join(" ")}function p(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n].score*(e.length-n);return t}function f(e,t,n,o,r){const i=o.map((e=>({tokens:e,score:p(e)})));i.sort(((e,t)=>e.score-t.score));let s=null;for(const{tokens:o}of i){const i=e.parseSelector(u(o)),c=e.querySelectorAll(i,t),a=c.indexOf(n);if(0===a)return o;if(!r||s||-1===a||c.length>5)continue;const l=o.map((e=>"text"!==e.engine?e:e.selector.startsWith("/")&&e.selector.endsWith("/")?{engine:"css",selector:`:text-matches("${e.selector.substring(1,e.selector.length-1)}")`,score:e.score}:{engine:"css",selector:`:text("${e.selector}")`,score:e.score}));s=[{engine:"css",selector:`:nth-match(${u(l)}, ${a+1})`,score:p(l)+1e3}]}return s}}},t={};function n(o){var r=t[o];if(void 0!==r)return r.exports;var i=t[o]={exports:{}};return e[o](i,i.exports,n),i.exports}var o={};(()=>{var e=o;e.default=void 0;var t=n(854);function r(e){return(e.altKey?1:0)|(e.ctrlKey?2:0)|(e.metaKey?4:0)|(e.shiftKey?8:0)}function i(e){switch(e.which){case 1:return"left";case 2:return"middle";case 3:return"right"}return"left"}function s(e){if("CANVAS"===e.target.nodeName)return{x:e.offsetX,y:e.offsetY}}function c(e){e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation()}function a(e){if(!e||"INPUT"!==e.nodeName)return null;const t=e;return"checkbox"===t.type?t:null}function l(e,t,n,o){return e.addEventListener(t,n,o),()=>{e.removeEventListener(t,n,o)}}var h=class{constructor(e,t){this._injectedScript=void 0,this._performingAction=!1,this._outerGlassPaneElement=void 0,this._glassPaneShadow=void 0,this._innerGlassPaneElement=void 0,this._highlightElements=[],this._tooltipElement=void 0,this._listeners=[],this._hoveredModel=null,this._hoveredElement=null,this._activeModel=null,this._expectProgrammaticKeyUp=!1,this._pollRecorderModeTimer=void 0,this._mode="none",this._actionPointElement=void 0,this._actionPoint=void 0,this._actionSelector=void 0,this._params=void 0,this._params=t,this._injectedScript=e,this._outerGlassPaneElement=document.createElement("x-pw-glass"),this._outerGlassPaneElement.style.position="fixed",this._outerGlassPaneElement.style.top="0",this._outerGlassPaneElement.style.right="0",this._outerGlassPaneElement.style.bottom="0",this._outerGlassPaneElement.style.left="0",this._outerGlassPaneElement.style.zIndex="2147483647",this._outerGlassPaneElement.style.pointerEvents="none",this._outerGlassPaneElement.style.display="flex",this._tooltipElement=document.createElement("x-pw-tooltip"),this._actionPointElement=document.createElement("x-pw-action-point"),this._actionPointElement.setAttribute("hidden","true"),this._innerGlassPaneElement=document.createElement("x-pw-glass-inner"),this._innerGlassPaneElement.style.flex="auto",this._innerGlassPaneElement.appendChild(this._tooltipElement),this._glassPaneShadow=this._outerGlassPaneElement.attachShadow({mode:this._params.isUnderTest?"open":"closed"}),this._glassPaneShadow.appendChild(this._innerGlassPaneElement),this._glassPaneShadow.appendChild(this._actionPointElement);const n=document.createElement("style");n.textContent="\\n        x-pw-tooltip {\\n          align-items: center;\\n          backdrop-filter: blur(5px);\\n          background-color: rgba(0, 0, 0, 0.7);\\n          border-radius: 2px;\\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\\n          color: rgb(204, 204, 204);\\n          display: none;\\n          font-family: \'Dank Mono\', \'Operator Mono\', Inconsolata, \'Fira Mono\',\\n                       \'SF Mono\', Monaco, \'Droid Sans Mono\', \'Source Code Pro\', monospace;\\n          font-size: 12.8px;\\n          font-weight: normal;\\n          left: 0;\\n          line-height: 1.5;\\n          max-width: 600px;\\n          padding: 3.2px 5.12px 3.2px;\\n          position: absolute;\\n          top: 0;\\n        }\\n        x-pw-action-point {\\n          position: absolute;\\n          width: 20px;\\n          height: 20px;\\n          background: red;\\n          border-radius: 10px;\\n          pointer-events: none;\\n          margin: -10px 0 0 -10px;\\n          z-index: 2;\\n        }\\n        *[hidden] {\\n          display: none !important;\\n        }\\n    ",this._glassPaneShadow.appendChild(n),this._refreshListenersIfNeeded(),e.onGlobalListenersRemoved.add((()=>this._refreshListenersIfNeeded())),globalThis._playwrightRefreshOverlay=()=>{this._pollRecorderMode().catch((e=>console.log(e)))},globalThis._playwrightRefreshOverlay(),t.isUnderTest&&console.error("Recorder script ready for test")}_refreshListenersIfNeeded(){(this._outerGlassPaneElement.parentElement!==document.documentElement||this._outerGlassPaneElement.nextElementSibling)&&(function(e){for(const t of e)t();e.splice(0,e.length)}(this._listeners),this._listeners=[l(document,"click",(e=>this._onClick(e)),!0),l(document,"auxclick",(e=>this._onClick(e)),!0),l(document,"input",(e=>this._onInput(e)),!0),l(document,"keydown",(e=>this._onKeyDown(e)),!0),l(document,"keyup",(e=>this._onKeyUp(e)),!0),l(document,"mousedown",(e=>this._onMouseDown(e)),!0),l(document,"mouseup",(e=>this._onMouseUp(e)),!0),l(document,"mousemove",(e=>this._onMouseMove(e)),!0),l(document,"mouseleave",(e=>this._onMouseLeave(e)),!0),l(document,"focus",(()=>this._onFocus()),!0),l(document,"scroll",(()=>{this._hoveredModel=null,this._actionPointElement.hidden=!0,this._updateHighlight()}),!0)],document.documentElement.appendChild(this._outerGlassPaneElement))}async _pollRecorderMode(){var e;this._pollRecorderModeTimer&&clearTimeout(this._pollRecorderModeTimer);const n=await globalThis._playwrightRecorderState().catch((e=>null));if(!n)return void(this._pollRecorderModeTimer=setTimeout((()=>this._pollRecorderMode()),1e3));const{mode:o,actionPoint:r,actionSelector:i}=n;o!==this._mode&&(this._mode=o,this._clearHighlight()),r&&this._actionPoint&&r.x===this._actionPoint.x&&r.y===this._actionPoint.y||(r||this._actionPoint)&&(r?(this._actionPointElement.style.top=r.y+"px",this._actionPointElement.style.left=r.x+"px",this._actionPointElement.hidden=!1):this._actionPointElement.hidden=!0,this._actionPoint=r),!this._actionSelector||null!==(e=this._hoveredModel)&&void 0!==e&&e.elements.length||(this._actionSelector=void 0),i!==this._actionSelector&&(this._hoveredModel=i?(0,t.querySelector)(this._injectedScript,i,document):null,this._updateHighlight(),this._actionSelector=i),this._pollRecorderModeTimer=setTimeout((()=>this._pollRecorderMode()),1e3)}_clearHighlight(){this._hoveredModel=null,this._activeModel=null,this._updateHighlight()}_actionInProgress(e){return!!this._performingAction||(c(e),!1)}_consumedDueToNoModel(e,t){return!t&&(c(e),!0)}_consumedDueWrongTarget(e){return!(this._activeModel&&this._activeModel.elements[0]===this._deepEventTarget(e)||(c(e),0))}_onClick(e){if("inspecting"===this._mode&&globalThis._playwrightRecorderSetSelector(this._hoveredModel?this._hoveredModel.selector:""),this._shouldIgnoreMouseEvent(e))return;if(this._actionInProgress(e))return;if(this._consumedDueToNoModel(e,this._hoveredModel))return;const t=a(this._deepEventTarget(e));t?this._performAction({name:t.checked?"check":"uncheck",selector:this._hoveredModel.selector,signals:[]}):this._performAction({name:"click",selector:this._hoveredModel.selector,position:s(e),signals:[],button:i(e),modifiers:r(e),clickCount:e.detail})}_shouldIgnoreMouseEvent(e){const t=this._deepEventTarget(e);if("none"===this._mode)return!0;if("inspecting"===this._mode)return c(e),!0;const n=t.nodeName;return"SELECT"===n||!("INPUT"!==n||!["date"].includes(t.type))}_onMouseDown(e){this._shouldIgnoreMouseEvent(e)||(this._performingAction||c(e),this._activeModel=this._hoveredModel)}_onMouseUp(e){this._shouldIgnoreMouseEvent(e)||this._performingAction||c(e)}_onMouseMove(e){if("none"===this._mode)return;const t=this._deepEventTarget(e);this._hoveredElement!==t&&(this._hoveredElement=t,this._updateModelForHoveredElement())}_onMouseLeave(e){this._deepEventTarget(e).nodeType===Node.DOCUMENT_NODE&&(this._hoveredElement=null,this._updateModelForHoveredElement())}_onFocus(){const e=this._deepActiveElement(document),n=e?(0,t.generateSelector)(this._injectedScript,e):null;this._activeModel=n&&n.selector?n:null,this._params.isUnderTest&&console.error("Highlight updated for test: "+(n?n.selector:null))}_updateModelForHoveredElement(){if(!this._hoveredElement)return this._hoveredModel=null,void this._updateHighlight();const e=this._hoveredElement,{selector:n,elements:o}=(0,t.generateSelector)(this._injectedScript,e);this._hoveredModel&&this._hoveredModel.selector===n||this._hoveredElement!==e||(this._hoveredModel=n?{selector:n,elements:o}:null,this._updateHighlight(),this._params.isUnderTest&&console.error("Highlight updated for test: "+n))}_updateHighlight(){const e=this._hoveredModel?this._hoveredModel.elements:[];this._tooltipElement.textContent=this._hoveredModel?this._hoveredModel.selector:"",this._tooltipElement.style.top="0",this._tooltipElement.style.left="0",this._tooltipElement.style.display="flex";const t=e.map((e=>e.getBoundingClientRect())),n=this._tooltipElement.offsetWidth,o=this._tooltipElement.offsetHeight,r=this._innerGlassPaneElement.offsetWidth,i=this._innerGlassPaneElement.offsetHeight;if(t.length){const e=t[0];let s=e.left;s+n>r-5&&(s=r-n-5);let c=e.bottom+5;c+o>i-5&&(c=e.top>o+5?e.top-o-5:i-5-o),this._tooltipElement.style.top=c+"px",this._tooltipElement.style.left=s+"px"}else this._tooltipElement.style.display="none";const s=this._highlightElements;this._highlightElements=[];for(const e of t){const t=s.length?s.shift():this._createHighlightElement(),n="recording"===this._mode?"#dc6f6f7f":"#6fa8dc7f";t.style.backgroundColor=this._highlightElements.length?"#f6b26b7f":n,t.style.left=e.x+"px",t.style.top=e.y+"px",t.style.width=e.width+"px",t.style.height=e.height+"px",t.style.display="block",this._highlightElements.push(t)}for(const e of s)e.style.display="none",this._highlightElements.push(e)}_createHighlightElement(){const e=document.createElement("x-pw-highlight");return e.style.position="absolute",e.style.top="0",e.style.left="0",e.style.width="0",e.style.height="0",e.style.boxSizing="border-box",this._glassPaneShadow.appendChild(e),e}_onInput(e){if("recording"!==this._mode)return!0;const t=this._deepEventTarget(e);if(["INPUT","TEXTAREA"].includes(t.nodeName)){const n=t,o=(n.type||"").toLowerCase();if("checkbox"===o)return;if("file"===o)return void globalThis._playwrightRecorderRecordAction({name:"setInputFiles",selector:this._activeModel.selector,signals:[],files:[...n.files||[]].map((e=>e.name))});if(this._consumedDueWrongTarget(e))return;globalThis._playwrightRecorderRecordAction({name:"fill",selector:this._activeModel.selector,signals:[],text:n.value})}if("SELECT"===t.nodeName){const n=t;if(this._actionInProgress(e))return;this._performAction({name:"select",selector:this._hoveredModel.selector,options:[...n.selectedOptions].map((e=>e.value)),signals:[]})}}_shouldGenerateKeyPressFor(e){if(["Backspace","Delete","AltGraph"].includes(e.key))return!1;if("@"===e.key&&"KeyL"===e.code)return!1;if(navigator.platform.includes("Mac")){if("v"===e.key&&e.metaKey)return!1}else{if("v"===e.key&&e.ctrlKey)return!1;if("Insert"===e.key&&e.shiftKey)return!1}if(["Shift","Control","Meta","Alt"].includes(e.key))return!1;const t=e.ctrlKey||e.altKey||e.metaKey;return!(1===e.key.length&&!t&&!a(this._deepEventTarget(e)))}_onKeyDown(e){if("inspecting"!==this._mode){if("recording"!==this._mode)return!0;if(this._shouldGenerateKeyPressFor(e))if(this._actionInProgress(e))this._expectProgrammaticKeyUp=!0;else if(!this._consumedDueWrongTarget(e)){if(" "===e.key){const t=a(this._deepEventTarget(e));if(t)return void this._performAction({name:t.checked?"uncheck":"check",selector:this._activeModel.selector,signals:[]})}this._performAction({name:"press",selector:this._activeModel.selector,signals:[],key:e.key,modifiers:r(e)})}}else c(e)}_onKeyUp(e){this._shouldGenerateKeyPressFor(e)&&(this._expectProgrammaticKeyUp?this._expectProgrammaticKeyUp=!1:c(e))}async _performAction(e){this._performingAction=!0,await globalThis._playwrightRecorderPerformAction(e).catch((()=>{})),this._performingAction=!1,this._updateModelForHoveredElement(),this._onFocus(),this._params.isUnderTest&&console.error("Action performed for test: "+JSON.stringify({hovered:this._hoveredModel?this._hoveredModel.selector:null,active:this._activeModel?this._activeModel.selector:null}))}_deepEventTarget(e){return e.composedPath()[0]}_deepActiveElement(e){let t=e.activeElement;for(;t&&t.shadowRoot&&t.shadowRoot.activeElement;)t=t.shadowRoot.activeElement;return t}};e.default=h})(),pwExport=o.default})();';
    exports.source = source;
  }
});

// node_modules/playwright-core/lib/generated/consoleApiSource.js
var require_consoleApiSource = __commonJS({
  "node_modules/playwright-core/lib/generated/consoleApiSource.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.source = void 0;
    var source = 'var pwExport;(()=>{"use strict";var e={317:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCSS=function(e,t){let r;try{r=n.tokenize(e),r[r.length-1]instanceof n.EOFToken||r.push(new n.EOFToken)}catch(t){const r=t.message+` while parsing selector "${e}"`,n=(t.stack||"").indexOf(t.message);throw-1!==n&&(t.stack=t.stack.substring(0,n)+r+t.stack.substring(n+t.message.length)),t.message=r,t}const o=r.find((e=>e instanceof n.AtKeywordToken||e instanceof n.BadStringToken||e instanceof n.BadURLToken||e instanceof n.ColumnToken||e instanceof n.CDOToken||e instanceof n.CDCToken||e instanceof n.SemicolonToken||e instanceof n.OpenCurlyToken||e instanceof n.CloseCurlyToken||e instanceof n.URLToken||e instanceof n.PercentageToken));if(o)throw new Error(`Unsupported token "${o.toSource()}" while parsing selector "${e}"`);let i=0;const s=new Set;function c(){return new Error(`Unexpected token "${r[i].toSource()}" while parsing selector "${e}"`)}function a(){for(;r[i]instanceof n.WhitespaceToken;)i++}function u(e=i){return r[e]instanceof n.IdentToken}function p(e=i){return r[e]instanceof n.CommaToken}function l(e=i){return r[e]instanceof n.CloseParenToken}function h(e=i){return r[e]instanceof n.DelimToken&&"*"===r[e].value}function f(e=i){return r[e]instanceof n.EOFToken}function y(e=i){return r[e]instanceof n.DelimToken&&[">","+","~"].includes(r[e].value)}function g(e=i){return p(e)||l(e)||f(e)||y(e)||r[e]instanceof n.WhitespaceToken}function m(){const e=[d()];for(;a(),p();)i++,e.push(d());return e}function d(){return a(),function(e=i){return r[e]instanceof n.NumberToken}()||function(e=i){return r[e]instanceof n.StringToken}()?r[i++].value:function(){const e={simples:[]};for(a(),y()?e.simples.push({selector:{functions:[{name:"scope",args:[]}]},combinator:""}):e.simples.push({selector:w(),combinator:""});;){if(a(),y())e.simples[e.simples.length-1].combinator=r[i++].value,a();else if(g())break;e.simples.push({combinator:"",selector:w()})}return e}()}function w(){let e="";const o=[];for(;!g();)if(u()||h())e+=r[i++].toSource();else if(r[i]instanceof n.HashToken)e+=r[i++].toSource();else if(r[i]instanceof n.DelimToken&&"."===r[i].value){if(i++,!u())throw c();e+="."+r[i++].toSource()}else if(r[i]instanceof n.ColonToken)if(i++,u())if(t.has(r[i].value.toLowerCase())){const e=r[i++].value.toLowerCase();o.push({name:e,args:[]}),s.add(e)}else e+=":"+r[i++].toSource();else{if(!(r[i]instanceof n.FunctionToken))throw c();{const n=r[i++].value.toLowerCase();if(t.has(n)?(o.push({name:n,args:m()}),s.add(n)):e+=`:${n}(${S()})`,a(),!l())throw c();i++}}else{if(!(r[i]instanceof n.OpenSquareToken))throw c();for(e+="[",i++;!(r[i]instanceof n.CloseSquareToken||f());)e+=r[i++].toSource();if(!(r[i]instanceof n.CloseSquareToken))throw c();e+="]",i++}if(!e&&!o.length)throw c();return{css:e||void 0,functions:o}}function S(){let e="";for(;!l()&&!f();)e+=r[i++].toSource();return e}const v=m();if(!f())throw new Error(`Error while parsing selector "${e}"`);if(v.some((e=>"object"!=typeof e||!("simples"in e))))throw new Error(`Error while parsing selector "${e}"`);return{selector:v,names:Array.from(s)}},t.serializeSelector=function e(t){return t.map((t=>"string"==typeof t?`"${t}"`:"number"==typeof t?String(t):t.simples.map((({selector:t,combinator:r})=>{let n=t.css||"";return n+=t.functions.map((t=>`:${t.name}(${e(t.args)})`)).join(""),r&&(n+=" "+r),n})).join(" "))).join(", ")};var n=function(e,t){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=o(t);if(r&&r.has(e))return r.get(e);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var c=i?Object.getOwnPropertyDescriptor(e,s):null;c&&(c.get||c.set)?Object.defineProperty(n,s,c):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}(r(503));function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(o=function(e){return e?r:t})(e)}},503:(e,t)=>{var r,n;r=function(e){var t=function(e,t,r){return e>=t&&e<=r};function r(e){return t(e,48,57)}function n(e){return r(e)||t(e,65,70)||t(e,97,102)}function o(e){return function(e){return t(e,65,90)}(e)||function(e){return t(e,97,122)}(e)}function i(e){return o(e)||function(e){return e>=128}(e)||95==e}function s(e){return i(e)||r(e)||45==e}function c(e){return t(e,0,8)||11==e||t(e,14,31)||127==e}function a(e){return 10==e}function u(e){return a(e)||9==e||32==e}var p=function(e){this.message=e};function l(e){if(e<=65535)return String.fromCharCode(e);e-=Math.pow(2,16);var t=Math.floor(e/Math.pow(2,10))+55296,r=e%Math.pow(2,10)+56320;return String.fromCharCode(t)+String.fromCharCode(r)}function h(){throw"Abstract Base Class"}function f(){return this}function y(){return this}function g(){return this}function m(){return this}function d(){return this}function w(){return this}function S(){return this}function v(){return this}function _(){throw"Abstract Base Class"}function T(){return this.value="{",this.mirror="}",this}function b(){return this.value="}",this.mirror="{",this}function E(){return this.value="[",this.mirror="]",this}function k(){return this.value="]",this.mirror="[",this}function C(){return this.value="(",this.mirror=")",this}function O(){return this.value=")",this.mirror="(",this}function M(){return this}function x(){return this}function N(){return this}function A(){return this}function j(){return this}function $(){return this}function q(){return this}function P(e){return this.value=l(e),this}function L(){throw"Abstract Base Class"}function R(e){this.value=e}function D(e){this.value=e,this.mirror=")"}function I(e){this.value=e}function U(e){this.value=e,this.type="unrestricted"}function B(e){this.value=e}function F(e){this.value=e}function Q(){this.value=null,this.type="integer",this.repr=""}function J(){this.value=null,this.repr=""}function W(){this.value=null,this.type="integer",this.repr="",this.unit=""}function z(e){for(var r="",n=(e=""+e).charCodeAt(0),o=0;o<e.length;o++){var i=e.charCodeAt(o);if(0==i)throw new p("Invalid character: the input contains U+0000.");t(i,1,31)||127==i||0==o&&t(i,48,57)||1==o&&t(i,48,57)&&45==n?r+="\\\\"+i.toString(16)+" ":i>=128||45==i||95==i||t(i,48,57)||t(i,65,90)||t(i,97,122)?r+=e[o]:r+="\\\\"+e[o]}return r}function G(e){e=""+e;for(var r="",n=0;n<e.length;n++){var o=e.charCodeAt(n);if(0==o)throw new p("Invalid character: the input contains U+0000.");t(o,1,31)||127==o?r+="\\\\"+o.toString(16)+" ":r+=34==o||92==o?"\\\\"+e[n]:e[n]}return r}(p.prototype=new Error).name="InvalidCharacterError",h.prototype.toJSON=function(){return{token:this.tokenType}},h.prototype.toString=function(){return this.tokenType},h.prototype.toSource=function(){return""+this},f.prototype=Object.create(h.prototype),f.prototype.tokenType="BADSTRING",y.prototype=Object.create(h.prototype),y.prototype.tokenType="BADURL",g.prototype=Object.create(h.prototype),g.prototype.tokenType="WHITESPACE",g.prototype.toString=function(){return"WS"},g.prototype.toSource=function(){return" "},m.prototype=Object.create(h.prototype),m.prototype.tokenType="CDO",m.prototype.toSource=function(){return"\\x3c!--"},d.prototype=Object.create(h.prototype),d.prototype.tokenType="CDC",d.prototype.toSource=function(){return"--\\x3e"},w.prototype=Object.create(h.prototype),w.prototype.tokenType=":",S.prototype=Object.create(h.prototype),S.prototype.tokenType=";",v.prototype=Object.create(h.prototype),v.prototype.tokenType=",",_.prototype=Object.create(h.prototype),T.prototype=Object.create(_.prototype),T.prototype.tokenType="{",b.prototype=Object.create(_.prototype),b.prototype.tokenType="}",E.prototype=Object.create(_.prototype),E.prototype.tokenType="[",k.prototype=Object.create(_.prototype),k.prototype.tokenType="]",C.prototype=Object.create(_.prototype),C.prototype.tokenType="(",O.prototype=Object.create(_.prototype),O.prototype.tokenType=")",M.prototype=Object.create(h.prototype),M.prototype.tokenType="~=",x.prototype=Object.create(h.prototype),x.prototype.tokenType="|=",N.prototype=Object.create(h.prototype),N.prototype.tokenType="^=",A.prototype=Object.create(h.prototype),A.prototype.tokenType="$=",j.prototype=Object.create(h.prototype),j.prototype.tokenType="*=",$.prototype=Object.create(h.prototype),$.prototype.tokenType="||",q.prototype=Object.create(h.prototype),q.prototype.tokenType="EOF",q.prototype.toSource=function(){return""},P.prototype=Object.create(h.prototype),P.prototype.tokenType="DELIM",P.prototype.toString=function(){return"DELIM("+this.value+")"},P.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},P.prototype.toSource=function(){return"\\\\"==this.value?"\\\\\\n":this.value},L.prototype=Object.create(h.prototype),L.prototype.ASCIIMatch=function(e){return this.value.toLowerCase()==e.toLowerCase()},L.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},R.prototype=Object.create(L.prototype),R.prototype.tokenType="IDENT",R.prototype.toString=function(){return"IDENT("+this.value+")"},R.prototype.toSource=function(){return z(this.value)},D.prototype=Object.create(L.prototype),D.prototype.tokenType="FUNCTION",D.prototype.toString=function(){return"FUNCTION("+this.value+")"},D.prototype.toSource=function(){return z(this.value)+"("},I.prototype=Object.create(L.prototype),I.prototype.tokenType="AT-KEYWORD",I.prototype.toString=function(){return"AT("+this.value+")"},I.prototype.toSource=function(){return"@"+z(this.value)},U.prototype=Object.create(L.prototype),U.prototype.tokenType="HASH",U.prototype.toString=function(){return"HASH("+this.value+")"},U.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e},U.prototype.toSource=function(){return"id"==this.type?"#"+z(this.value):"#"+function(e){for(var r="",n=((e=""+e).charCodeAt(0),0);n<e.length;n++){var o=e.charCodeAt(n);if(0==o)throw new p("Invalid character: the input contains U+0000.");o>=128||45==o||95==o||t(o,48,57)||t(o,65,90)||t(o,97,122)?r+=e[n]:r+="\\\\"+o.toString(16)+" "}return r}(this.value)},B.prototype=Object.create(L.prototype),B.prototype.tokenType="STRING",B.prototype.toString=function(){return\'"\'+G(this.value)+\'"\'},F.prototype=Object.create(L.prototype),F.prototype.tokenType="URL",F.prototype.toString=function(){return"URL("+this.value+")"},F.prototype.toSource=function(){return\'url("\'+G(this.value)+\'")\'},Q.prototype=Object.create(h.prototype),Q.prototype.tokenType="NUMBER",Q.prototype.toString=function(){return"integer"==this.type?"INT("+this.value+")":"NUMBER("+this.value+")"},Q.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e},Q.prototype.toSource=function(){return this.repr},J.prototype=Object.create(h.prototype),J.prototype.tokenType="PERCENTAGE",J.prototype.toString=function(){return"PERCENTAGE("+this.value+")"},J.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.repr=this.repr,e},J.prototype.toSource=function(){return this.repr+"%"},W.prototype=Object.create(h.prototype),W.prototype.tokenType="DIMENSION",W.prototype.toString=function(){return"DIM("+this.value+","+this.unit+")"},W.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e.unit=this.unit,e},W.prototype.toSource=function(){var e=this.repr,r=z(this.unit);return"e"!=r[0].toLowerCase()||"-"!=r[1]&&!t(r.charCodeAt(1),48,57)||(r="\\\\65 "+r.slice(1,r.length)),e+r},e.tokenize=function(e){e=function(e){for(var r=[],n=0;n<e.length;n++){var o=e.charCodeAt(n);if(13==o&&10==e.charCodeAt(n+1)&&(o=10,n++),13!=o&&12!=o||(o=10),0==o&&(o=65533),t(o,55296,56319)&&t(e.charCodeAt(n+1),56320,57343)){var i=o-55296,s=e.charCodeAt(n+1)-56320;o=Math.pow(2,16)+i*Math.pow(2,10)+s,n++}r.push(o)}return r}(e);for(var o,p=-1,h=[],_=0,L=0,z=0,G={line:_,column:L},H=function(t){return t>=e.length?-1:e[t]},V=function(e){if(void 0===e&&(e=1),e>3)throw"Spec Error: no more than three codepoints of lookahead.";return H(p+e)},K=function(e){return void 0===e&&(e=1),a(o=H(p+=e))?(_+=1,z=L,L=0):L+=e,!0},X=function(){return p-=1,a(o)?(_-=1,L=z):L-=1,G.line=_,G.column=L,!0},Z=function(e){return void 0===e&&(e=o),-1==e},Y=function(){return console.log("Parse error at index "+p+", processing codepoint 0x"+o.toString(16)+"."),!0},ee=function(){if(te(),K(),u(o)){for(;u(V());)K();return new g}if(34==o)return oe();if(35==o){if(s(V())||ce(V(1),V(2))){var e=new U;return ue(V(1),V(2),V(3))&&(e.type="id"),e.value=he(),e}return new P(o)}return 36==o?61==V()?(K(),new A):new P(o):39==o?oe():40==o?new C:41==o?new O:42==o?61==V()?(K(),new j):new P(o):43==o?le()?(X(),re()):new P(o):44==o?new v:45==o?le()?(X(),re()):45==V(1)&&62==V(2)?(K(2),new d):pe()?(X(),ne()):new P(o):46==o?le()?(X(),re()):new P(o):58==o?new w:59==o?new S:60==o?33==V(1)&&45==V(2)&&45==V(3)?(K(3),new m):new P(o):64==o?ue(V(1),V(2),V(3))?new I(he()):new P(o):91==o?new E:92==o?ae()?(X(),ne()):(Y(),new P(o)):93==o?new k:94==o?61==V()?(K(),new N):new P(o):123==o?new T:124==o?61==V()?(K(),new x):124==V()?(K(),new $):new P(o):125==o?new b:126==o?61==V()?(K(),new M):new P(o):r(o)?(X(),re()):i(o)?(X(),ne()):Z()?new q:new P(o)},te=function(){for(;47==V(1)&&42==V(2);)for(K(2);;){if(K(),42==o&&47==V()){K();break}if(Z())return void Y()}},re=function(){var e,t=fe();return ue(V(1),V(2),V(3))?((e=new W).value=t.value,e.repr=t.repr,e.type=t.type,e.unit=he(),e):37==V()?(K(),(e=new J).value=t.value,e.repr=t.repr,e):((e=new Q).value=t.value,e.repr=t.repr,e.type=t.type,e)},ne=function(){var e=he();if("url"==e.toLowerCase()&&40==V()){for(K();u(V(1))&&u(V(2));)K();return 34==V()||39==V()?new D(e):!u(V())||34!=V(2)&&39!=V(2)?ie():new D(e)}return 40==V()?(K(),new D(e)):new R(e)},oe=function(e){void 0===e&&(e=o);for(var t="";K();){if(o==e||Z())return new B(t);if(a(o))return Y(),X(),new f;92==o?Z(V())||(a(V())?K():t+=l(se())):t+=l(o)}},ie=function(){for(var e=new F("");u(V());)K();if(Z(V()))return e;for(;K();){if(41==o||Z())return e;if(u(o)){for(;u(V());)K();return 41==V()||Z(V())?(K(),e):(ge(),new y)}if(34==o||39==o||40==o||c(o))return Y(),ge(),new y;if(92==o){if(!ae())return Y(),ge(),new y;e.value+=l(se())}else e.value+=l(o)}},se=function(){if(K(),n(o)){for(var e=[o],t=0;t<5&&n(V());t++)K(),e.push(o);u(V())&&K();var r=parseInt(e.map((function(e){return String.fromCharCode(e)})).join(""),16);return r>1114111&&(r=65533),r}return Z()?65533:o},ce=function(e,t){return 92==e&&!a(t)},ae=function(){return ce(o,V())},ue=function(e,t,r){return 45==e?i(t)||45==t||ce(t,r):!!i(e)||92==e&&ce(e,t)},pe=function(){return ue(o,V(1),V(2))},le=function(){return e=o,t=V(1),n=V(2),43==e||45==e?!!r(t)||!(46!=t||!r(n)):46==e?!!r(t):!!r(e);var e,t,n},he=function(){for(var e="";K();)if(s(o))e+=l(o);else{if(!ae())return X(),e;e+=l(se())}},fe=function(){var e=[],t="integer";for(43!=V()&&45!=V()||(K(),e+=l(o));r(V());)K(),e+=l(o);if(46==V(1)&&r(V(2)))for(K(),e+=l(o),K(),e+=l(o),t="number";r(V());)K(),e+=l(o);var n=V(1),i=V(2),s=V(3);if(69!=n&&101!=n||!r(i)){if((69==n||101==n)&&(43==i||45==i)&&r(s))for(K(),e+=l(o),K(),e+=l(o),K(),e+=l(o),t="number";r(V());)K(),e+=l(o)}else for(K(),e+=l(o),K(),e+=l(o),t="number";r(V());)K(),e+=l(o);return{type:t,value:ye(e),repr:e}},ye=function(e){return+e},ge=function(){for(;K();){if(41==o||Z())return;ae()&&se()}},me=0;!Z(V());)if(h.push(ee()),++me>2*e.length)return"I\'m infinite-looping!";return h},e.IdentToken=R,e.FunctionToken=D,e.AtKeywordToken=I,e.HashToken=U,e.StringToken=B,e.BadStringToken=f,e.URLToken=F,e.BadURLToken=y,e.DelimToken=P,e.NumberToken=Q,e.PercentageToken=J,e.DimensionToken=W,e.IncludeMatchToken=M,e.DashMatchToken=x,e.PrefixMatchToken=N,e.SuffixMatchToken=A,e.SubstringMatchToken=j,e.ColumnToken=$,e.WhitespaceToken=g,e.CDOToken=m,e.CDCToken=d,e.ColonToken=w,e.SemicolonToken=S,e.CommaToken=v,e.OpenParenToken=C,e.CloseParenToken=O,e.OpenSquareToken=E,e.CloseSquareToken=k,e.OpenCurlyToken=T,e.CloseCurlyToken=b,e.EOFToken=q,e.CSSParserToken=h,e.GroupingToken=_},void 0===(n=r.apply(t,[t]))||(e.exports=n)},461:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSelector=i,t.splitSelectorByFrame=function(e){const t=i(e),r=[];let n={parts:[]},o=0;for(let e=0;e<t.parts.length;++e){const i=t.parts[e];if("control"!==i.name||"enter-frame"!==i.body)t.capture===e&&(n.capture=e-o),n.parts.push(i);else{if(!n.parts.length)throw new Error("Selector cannot start with entering frame, select the iframe first");r.push(n),n={parts:[]},o=e+1}}if(!n.parts.length)throw new Error(`Selector cannot end with entering frame, while parsing selector ${e}`);if(r.push(n),"number"==typeof t.capture&&"number"!=typeof r[r.length-1].capture)throw new Error("Can not capture the selector before diving into the frame. Only use * after the last frame has been selected");return r},t.stringifySelector=function(e){return"string"==typeof e?e:e.parts.map(((t,r)=>{const n="css"===t.name?"":t.name+"=";return`${r===e.capture?"*":""}${n}${t.source}`})).join(" >> ")},t.customCSSNames=void 0;var n=r(317);const o=new Set(["not","is","where","has","scope","light","visible","text","text-matches","text-is","has-text","above","below","right-of","left-of","near","nth-match"]);function i(e){const t=function(e){let t,r=0,n=0;const o={parts:[]},i=()=>{const t=e.substring(n,r).trim(),i=t.indexOf("=");let s,c;-1!==i&&t.substring(0,i).trim().match(/^[a-zA-Z_0-9-+:*]+$/)?(s=t.substring(0,i).trim(),c=t.substring(i+1)):t.length>1&&\'"\'===t[0]&&\'"\'===t[t.length-1]||t.length>1&&"\'"===t[0]&&"\'"===t[t.length-1]?(s="text",c=t):/^\\(*\\/\\//.test(t)||t.startsWith("..")?(s="xpath",c=t):(s="css",c=t);let a=!1;if("*"===s[0]&&(a=!0,s=s.substring(1)),o.parts.push({name:s,body:c}),a){if(void 0!==o.capture)throw new Error("Only one of the selectors can capture using * modifier");o.capture=o.parts.length-1}};if(!e.includes(">>"))return r=e.length,i(),o;for(;r<e.length;){const o=e[r];"\\\\"===o&&r+1<e.length?r+=2:o===t?(t=void 0,r++):t||\'"\'!==o&&"\'"!==o&&"`"!==o?t||">"!==o||">"!==e[r+1]?r++:(i(),r+=2,n=r):(t=o,r++)}return i(),o}(e),r=t.parts.map((e=>"css"===e.name||"css:light"===e.name?("css:light"===e.name&&(e.body=":light("+e.body+")"),{name:"css",body:(0,n.parseCSS)(e.body,o).selector,source:e.body}):{...e,source:e.body}));return{capture:t.capture,parts:r}}t.customCSSNames=o},848:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createLaxTextMatcher=y,t.createStrictTextMatcher=g,t.createRegexTextMatcher=m,t.elementText=w,t.elementMatchesText=S,t.parentElementOrShadowHost=O,t.isVisible=N,t.SelectorEvaluatorImpl=void 0;var n=r(461);t.SelectorEvaluatorImpl=class{constructor(e){this._engines=new Map,this._cacheQueryCSS=new Map,this._cacheMatches=new Map,this._cacheQuery=new Map,this._cacheMatchesSimple=new Map,this._cacheMatchesParents=new Map,this._cacheCallMatches=new Map,this._cacheCallQuery=new Map,this._cacheQuerySimple=new Map,this._cacheText=new Map,this._scoreMap=void 0,this._retainCacheCounter=0;for(const[t,r]of e)this._engines.set(t,r);this._engines.set("not",c),this._engines.set("is",o),this._engines.set("where",o),this._engines.set("has",i),this._engines.set("scope",s),this._engines.set("light",a),this._engines.set("visible",u),this._engines.set("text",p),this._engines.set("text-is",l),this._engines.set("text-matches",h),this._engines.set("has-text",f),this._engines.set("right-of",k("right-of",v)),this._engines.set("left-of",k("left-of",_)),this._engines.set("above",k("above",T)),this._engines.set("below",k("below",b)),this._engines.set("near",k("near",E)),this._engines.set("nth-match",C);const t=[...this._engines.keys()];t.sort();const r=[...n.customCSSNames];if(r.sort(),t.join("|")!==r.join("|"))throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${t.join("|")} vs ${r.join("|")}`)}begin(){++this._retainCacheCounter}end(){--this._retainCacheCounter,this._retainCacheCounter||(this._cacheQueryCSS.clear(),this._cacheMatches.clear(),this._cacheQuery.clear(),this._cacheMatchesSimple.clear(),this._cacheMatchesParents.clear(),this._cacheCallMatches.clear(),this._cacheCallQuery.clear(),this._cacheQuerySimple.clear(),this._cacheText.clear())}_cached(e,t,r,n){e.has(t)||e.set(t,[]);const o=e.get(t),i=o.find((e=>r.every(((t,r)=>e.rest[r]===t))));if(i)return i.result;const s=n();return o.push({rest:r,result:s}),s}_checkSelector(e){if("object"!=typeof e||!e||!(Array.isArray(e)||"simples"in e&&e.simples.length))throw new Error(`Malformed selector "${e}"`);return e}matches(e,t,r){const n=this._checkSelector(t);this.begin();try{return this._cached(this._cacheMatches,e,[n,r.scope,r.pierceShadow],(()=>Array.isArray(n)?this._matchesEngine(o,e,n,r):!!this._matchesSimple(e,n.simples[n.simples.length-1].selector,r)&&this._matchesParents(e,n,n.simples.length-2,r)))}finally{this.end()}}query(e,t){const r=this._checkSelector(t);this.begin();try{return this._cached(this._cacheQuery,r,[e.scope,e.pierceShadow],(()=>{if(Array.isArray(r))return this._queryEngine(o,e,r);const t=this._scoreMap;this._scoreMap=new Map;let n=this._querySimple(e,r.simples[r.simples.length-1].selector);return n=n.filter((t=>this._matchesParents(t,r,r.simples.length-2,e))),this._scoreMap.size&&n.sort(((e,t)=>{const r=this._scoreMap.get(e),n=this._scoreMap.get(t);return r===n?0:void 0===r?1:void 0===n?-1:r-n})),this._scoreMap=t,n}))}finally{this.end()}}_markScore(e,t){this._scoreMap&&this._scoreMap.set(e,t)}_matchesSimple(e,t,r){return this._cached(this._cacheMatchesSimple,e,[t,r.scope,r.pierceShadow],(()=>{if(!t.functions.some((e=>"scope"===e.name||"is"===e.name))&&e===r.scope)return!1;if(t.css&&!this._matchesCSS(e,t.css))return!1;for(const n of t.functions)if(!this._matchesEngine(this._getEngine(n.name),e,n.args,r))return!1;return!0}))}_querySimple(e,t){return t.functions.length?this._cached(this._cacheQuerySimple,t,[e.scope,e.pierceShadow],(()=>{let r=t.css;const n=t.functions;let o;"*"===r&&n.length&&(r=void 0);let i=-1;void 0!==r?o=this._queryCSS(e,r):(i=n.findIndex((e=>void 0!==this._getEngine(e.name).query)),-1===i&&(i=0),o=this._queryEngine(this._getEngine(n[i].name),e,n[i].args));for(let t=0;t<n.length;t++){if(t===i)continue;const r=this._getEngine(n[t].name);void 0!==r.matches&&(o=o.filter((o=>this._matchesEngine(r,o,n[t].args,e))))}for(let t=0;t<n.length;t++){if(t===i)continue;const r=this._getEngine(n[t].name);void 0===r.matches&&(o=o.filter((o=>this._matchesEngine(r,o,n[t].args,e))))}return o})):this._queryCSS(e,t.css||"*")}_matchesParents(e,t,r,n){return r<0||this._cached(this._cacheMatchesParents,e,[t,r,n.scope,n.pierceShadow],(()=>{const{selector:o,combinator:i}=t.simples[r];if(">"===i){const i=M(e,n);return!(!i||!this._matchesSimple(i,o,n))&&this._matchesParents(i,t,r-1,n)}if("+"===i){const i=x(e,n);return!(!i||!this._matchesSimple(i,o,n))&&this._matchesParents(i,t,r-1,n)}if(""===i){let i=M(e,n);for(;i;){if(this._matchesSimple(i,o,n)){if(this._matchesParents(i,t,r-1,n))return!0;if(""===t.simples[r-1].combinator)break}i=M(i,n)}return!1}if("~"===i){let i=x(e,n);for(;i;){if(this._matchesSimple(i,o,n)){if(this._matchesParents(i,t,r-1,n))return!0;if("~"===t.simples[r-1].combinator)break}i=x(i,n)}return!1}if(">="===i){let i=e;for(;i;){if(this._matchesSimple(i,o,n)){if(this._matchesParents(i,t,r-1,n))return!0;if(""===t.simples[r-1].combinator)break}i=M(i,n)}return!1}throw new Error(`Unsupported combinator "${i}"`)}))}_matchesEngine(e,t,r,n){if(e.matches)return this._callMatches(e,t,r,n);if(e.query)return this._callQuery(e,r,n).includes(t);throw new Error(\'Selector engine should implement "matches" or "query"\')}_queryEngine(e,t,r){if(e.query)return this._callQuery(e,r,t);if(e.matches)return this._queryCSS(t,"*").filter((n=>this._callMatches(e,n,r,t)));throw new Error(\'Selector engine should implement "matches" or "query"\')}_callMatches(e,t,r,n){return this._cached(this._cacheCallMatches,t,[e,n.scope,n.pierceShadow,...r],(()=>e.matches(t,r,n,this)))}_callQuery(e,t,r){return this._cached(this._cacheCallQuery,e,[r.scope,r.pierceShadow,...t],(()=>e.query(r,t,this)))}_matchesCSS(e,t){return e.matches(t)}_queryCSS(e,t){return this._cached(this._cacheQueryCSS,t,[e.scope,e.pierceShadow],(()=>{let r=[];return function n(o){if(r=r.concat([...o.querySelectorAll(t)]),e.pierceShadow){o.shadowRoot&&n(o.shadowRoot);for(const e of o.querySelectorAll("*"))e.shadowRoot&&n(e.shadowRoot)}}(e.scope),r}))}_getEngine(e){const t=this._engines.get(e);if(!t)throw new Error(`Unknown selector engine "${e}"`);return t}};const o={matches(e,t,r,n){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');return t.some((t=>n.matches(e,t,r)))},query(e,t,r){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');let n=[];for(const o of t)n=n.concat(r.query(e,o));return 1===t.length?n:function(e){const t=new Map,r=[],n=[];function o(e){let n=t.get(e);if(n)return n;const i=O(e);return i?o(i).children.push(e):r.push(e),n={children:[],taken:!1},t.set(e,n),n}return e.forEach((e=>o(e).taken=!0)),r.forEach((function e(r){const o=t.get(r);if(o.taken&&n.push(r),o.children.length>1){const e=new Set(o.children);o.children=[];let t=r.firstElementChild;for(;t&&o.children.length<e.size;)e.has(t)&&o.children.push(t),t=t.nextElementSibling;for(t=r.shadowRoot?r.shadowRoot.firstElementChild:null;t&&o.children.length<e.size;)e.has(t)&&o.children.push(t),t=t.nextElementSibling}o.children.forEach(e)})),n}(n)}},i={matches(e,t,r,n){if(0===t.length)throw new Error(\'"has" engine expects non-empty selector list\');return n.query({...r,scope:e},t).length>0}},s={matches(e,t,r,n){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');return 9===r.scope.nodeType?e===r.scope.documentElement:e===r.scope},query(e,t,r){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');if(9===e.scope.nodeType){const t=e.scope.documentElement;return t?[t]:[]}return 1===e.scope.nodeType?[e.scope]:[]}},c={matches(e,t,r,n){if(0===t.length)throw new Error(\'"not" engine expects non-empty selector list\');return!n.matches(e,t,r)}},a={query:(e,t,r)=>r.query({...e,pierceShadow:!1},t),matches:(e,t,r,n)=>n.matches(e,t,{...r,pierceShadow:!1})},u={matches(e,t,r,n){if(t.length)throw new Error(\'"visible" engine expects no arguments\');return N(e)}},p={matches(e,t,r,n){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text" engine expects a single string\');return"self"===S(n,e,y(t[0]))}},l={matches(e,t,r,n){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text-is" engine expects a single string\');return"none"!==S(n,e,g(t[0]))}},h={matches(e,t,r,n){if(0===t.length||"string"!=typeof t[0]||t.length>2||2===t.length&&"string"!=typeof t[1])throw new Error(\'"text-matches" engine expects a regexp body and optional regexp flags\');return"self"===S(n,e,m(t[0],2===t.length?t[1]:void 0))}},f={matches(e,t,r,n){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"has-text" engine expects a single string\');return!d(e)&&y(t[0])(w(n,e))}};function y(e){return e=e.trim().replace(/\\s+/g," ").toLowerCase(),t=>t.full.trim().replace(/\\s+/g," ").toLowerCase().includes(e)}function g(e){return e=e.trim().replace(/\\s+/g," "),t=>!e&&!t.immediate.length||t.immediate.some((t=>t.trim().replace(/\\s+/g," ")===e))}function m(e,t){const r=new RegExp(e,t);return e=>r.test(e.full)}function d(e){return"SCRIPT"===e.nodeName||"STYLE"===e.nodeName||document.head&&document.head.contains(e)}function w(e,t){let r=e._cacheText.get(t);if(void 0===r){if(r={full:"",immediate:[]},!d(t)){let n="";if(t instanceof HTMLInputElement&&("submit"===t.type||"button"===t.type))r={full:t.value,immediate:[t.value]};else{for(let o=t.firstChild;o;o=o.nextSibling)o.nodeType===Node.TEXT_NODE?(r.full+=o.nodeValue||"",n+=o.nodeValue||""):(n&&r.immediate.push(n),n="",o.nodeType===Node.ELEMENT_NODE&&(r.full+=w(e,o).full));n&&r.immediate.push(n),t.shadowRoot&&(r.full+=w(e,t.shadowRoot).full)}}e._cacheText.set(t,r)}return r}function S(e,t,r){if(d(t))return"none";if(!r(w(e,t)))return"none";for(let n=t.firstChild;n;n=n.nextSibling)if(n.nodeType===Node.ELEMENT_NODE&&r(w(e,n)))return"selfAndChildren";return t.shadowRoot&&r(w(e,t.shadowRoot))?"selfAndChildren":"self"}function v(e,t,r){const n=e.left-t.right;if(!(n<0||void 0!==r&&n>r))return n+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function _(e,t,r){const n=t.left-e.right;if(!(n<0||void 0!==r&&n>r))return n+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function T(e,t,r){const n=t.top-e.bottom;if(!(n<0||void 0!==r&&n>r))return n+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function b(e,t,r){const n=e.top-t.bottom;if(!(n<0||void 0!==r&&n>r))return n+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function E(e,t,r){const n=void 0===r?50:r;let o=0;return e.left-t.right>=0&&(o+=e.left-t.right),t.left-e.right>=0&&(o+=t.left-e.right),t.top-e.bottom>=0&&(o+=t.top-e.bottom),e.top-t.bottom>=0&&(o+=e.top-t.bottom),o>n?void 0:o}function k(e,t){return{matches(r,n,o,i){const s=n.length&&"number"==typeof n[n.length-1]?n[n.length-1]:void 0,c=void 0===s?n:n.slice(0,n.length-1);if(n.length<1+(void 0===s?0:1))throw new Error(`"${e}" engine expects a selector list and optional maximum distance in pixels`);const a=r.getBoundingClientRect();let u;for(const e of i.query(o,c)){if(e===r)continue;const n=t(a,e.getBoundingClientRect(),s);void 0!==n&&(void 0===u||n<u)&&(u=n)}return void 0!==u&&(i._markScore(r,u),!0)}}}const C={query(e,t,r){let n=t[t.length-1];if(t.length<2)throw new Error(\'"nth-match" engine expects non-empty selector list and an index argument\');if("number"!=typeof n||n<1)throw new Error(\'"nth-match" engine expects a one-based index as the last argument\');const i=o.query(e,t.slice(0,t.length-1),r);return n--,n<i.length?[i[n]]:[]}};function O(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:void 0}function M(e,t){if(e!==t.scope)return t.pierceShadow?O(e):e.parentElement||void 0}function x(e,t){if(e!==t.scope)return e.previousElementSibling||void 0}function N(e){if(!e.ownerDocument||!e.ownerDocument.defaultView)return!0;const t=e.ownerDocument.defaultView.getComputedStyle(e);if(!t||"hidden"===t.visibility)return!1;const r=e.getBoundingClientRect();return r.width>0&&r.height>0}},854:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.querySelector=function(e,t,r){try{const n=e.parseSelector(t);return{selector:t,elements:e.querySelectorAll(n,r)}}catch(e){return{selector:t,elements:[]}}},t.generateSelector=function(e,t){e._evaluator.begin();try{const r=function(e,t){if(t.ownerDocument.documentElement===t)return[{engine:"css",selector:"html",score:1}];const r=(u,l)=>{const y=l?o:i;let g=y.get(u);return void 0===g&&(g=((o,i)=>{const u=o===t;let l=i?function(e,t,r){if("SELECT"===t.nodeName)return[];const o=(0,n.elementText)(e._evaluator,t).full.trim().replace(/\\s+/g," ").substring(0,80);if(!o)return[];const i=[];let s=o;if((o.includes(\'"\')||o.includes(">>")||"/"===o[0])&&(s=`/.*${function(e){return e.replace(/[.*+?^>${}()|[\\]\\\\]/g,"\\\\$&")}(o)}.*/`),i.push({engine:"text",selector:s,score:10}),r&&s===o){let e=t.nodeName.toLocaleLowerCase();t.hasAttribute("role")&&(e+=`[role=${p(t.getAttribute("role"))}]`),i.push({engine:"css",selector:`${e}:has-text("${o}")`,score:30})}return i}(e,o,o===t).map((e=>[e])):[];o!==t&&(l=s(l));const y=function(e,t){const r=[];for(const e of["data-testid","data-test-id","data-test"])t.hasAttribute(e)&&r.push({engine:"css",selector:`[${e}=${p(t.getAttribute(e))}]`,score:1});if("INPUT"===t.nodeName){const e=t;e.placeholder&&r.push({engine:"css",selector:`[placeholder=${p(e.placeholder)}]`,score:10})}t.hasAttribute("aria-label")&&r.push({engine:"css",selector:`[aria-label=${p(t.getAttribute("aria-label"))}]`,score:10}),t.getAttribute("alt")&&["APPLET","AREA","IMG","INPUT"].includes(t.nodeName)&&r.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[alt=${p(t.getAttribute("alt"))}]`,score:10}),t.hasAttribute("role")&&r.push({engine:"css",selector:`${t.nodeName.toLocaleLowerCase()}[role=${p(t.getAttribute("role"))}]`,score:50}),t.getAttribute("name")&&["BUTTON","FORM","FIELDSET","IFRAME","INPUT","KEYGEN","OBJECT","OUTPUT","SELECT","TEXTAREA","MAP","META","PARAM"].includes(t.nodeName)&&r.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[name=${p(t.getAttribute("name"))}]`,score:50}),["INPUT","TEXTAREA"].includes(t.nodeName)&&"hidden"!==t.getAttribute("type")&&t.getAttribute("type")&&r.push({engine:"css",selector:`${t.nodeName.toLowerCase()}[type=${p(t.getAttribute("type"))}]`,score:50}),["INPUT","TEXTAREA","SELECT"].includes(t.nodeName)&&r.push({engine:"css",selector:t.nodeName.toLowerCase(),score:50});const n=t.getAttribute("id");return n&&!function(e){let t,r=0;for(let n=0;n<e.length;++n){const o=e[n];let i;"-"!==o&&"_"!==o&&(i=o>="a"&&o<="z"?"lower":o>="A"&&o<="Z"?"upper":o>="0"&&o<="9"?"digit":"other","lower"!==i||"upper"!==t?(t&&t!==i&&++r,t=i):t=i)}return r>=e.length/4}(n)&&r.push({engine:"css",selector:a(n),score:100}),r.push({engine:"css",selector:t.nodeName.toLocaleLowerCase(),score:200}),r}(0,o).map((e=>[e]));let g=f(e,t.ownerDocument,o,[...l,...y],u);l=s(l);const m=t=>{const n=i&&!t.length,s=[...t,...y].filter((e=>!g||h(e)<h(g)));let a=s[0];if(a)for(let t=c(o);t;t=c(t)){const i=r(t,n);if(!i)continue;if(g&&h([...i,...a])>=h(g))continue;if(a=f(e,t,o,s,u),!a)return;const c=[...i,...a];(!g||h(c)<h(g))&&(g=c)}};return m(l),o===t&&l.length&&m([]),g})(u,l),y.set(u,g)),g};return r(t,!0)}(e,t=t.closest("button,select,input,[role=button],[role=checkbox],[role=radio]")||t),y=l(r||[u(e,t)]),g=e.parseSelector(y);return{selector:y,elements:e.querySelectorAll(g,t.ownerDocument)}}finally{o.clear(),i.clear(),e._evaluator.end()}};var n=r(848);const o=new Map,i=new Map;function s(e){return e.filter((e=>"/"!==e[0].selector[0]))}function c(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:null}function a(e){return/^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(e)?"#"+e:`[id="${e}"]`}function u(e,t){const r=1e7,n=t.ownerDocument,o=[];function i(r){const n=o.slice();r&&n.unshift(r);const i=n.join(" "),s=e.parseSelector(i);return e.querySelector(s,t.ownerDocument,!1)===t?i:void 0}for(let e=t;e&&e!==n;e=c(e)){const t=e.nodeName.toLowerCase();let n="";if(e.id){const t=a(e.id),o=i(t);if(o)return{engine:"css",selector:o,score:r};n=t}const s=e.parentNode,c=[...e.classList];for(let e=0;e<c.length;++e){const t="."+c.slice(0,e+1).join("."),o=i(t);if(o)return{engine:"css",selector:o,score:r};!n&&s&&1===s.querySelectorAll(t).length&&(n=t)}if(s){const o=[...s.children],c=0===o.filter((e=>e.nodeName.toLowerCase()===t)).indexOf(e)?t:`${t}:nth-child(${1+o.indexOf(e)})`,a=i(c);if(a)return{engine:"css",selector:a,score:r};n||(n=c)}else n||(n=t);o.unshift(n)}return{engine:"css",selector:i(),score:r}}function p(e){return`"${e.replace(/"/g,\'\\\\"\').replace(/\\n/g,"\\\\n")}"`}function l(e){const t=[];let r="";for(const{engine:n,selector:o}of e)t.length&&("css"!==r||"css"!==n||o.startsWith(":nth-match("))&&t.push(">>"),r=n,"css"===n?t.push(o):t.push(`${n}=${o}`);return t.join(" ")}function h(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r].score*(e.length-r);return t}function f(e,t,r,n,o){const i=n.map((e=>({tokens:e,score:h(e)})));i.sort(((e,t)=>e.score-t.score));let s=null;for(const{tokens:n}of i){const i=e.parseSelector(l(n)),c=e.querySelectorAll(i,t),a=c.indexOf(r);if(0===a)return n;if(!o||s||-1===a||c.length>5)continue;const u=n.map((e=>"text"!==e.engine?e:e.selector.startsWith("/")&&e.selector.endsWith("/")?{engine:"css",selector:`:text-matches("${e.selector.substring(1,e.selector.length-1)}")`,score:e.score}:{engine:"css",selector:`:text("${e.selector}")`,score:e.score}));s=[{engine:"css",selector:`:nth-match(${l(u)}, ${a+1})`,score:h(u)+1e3}]}return s}}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}var n={};(()=>{var e=n;e.default=void 0;var t=r(854);var o=class{constructor(e){this._injectedScript=void 0,this._injectedScript=e,window.playwright||(window.playwright={$:(e,t)=>this._querySelector(e,!!t),$$:e=>this._querySelectorAll(e),inspect:e=>this._inspect(e),selector:e=>this._selector(e),resume:()=>this._resume()})}_querySelector(e,t){if("string"!=typeof e)throw new Error("Usage: playwright.query(\'Playwright >> selector\').");const r=this._injectedScript.parseSelector(e);return this._injectedScript.querySelector(r,document,t)}_querySelectorAll(e){if("string"!=typeof e)throw new Error("Usage: playwright.$$(\'Playwright >> selector\').");const t=this._injectedScript.parseSelector(e);return this._injectedScript.querySelectorAll(t,document)}_inspect(e){if("string"!=typeof e)throw new Error("Usage: playwright.inspect(\'Playwright >> selector\').");window.inspect(this._querySelector(e,!1))}_selector(e){if(!(e instanceof Element))throw new Error("Usage: playwright.selector(element).");return(0,t.generateSelector)(this._injectedScript,e).selector}_resume(){window._playwrightResume().catch((()=>{}))}};e.default=o})(),pwExport=n.default})();';
    exports.source = source;
  }
});

// node_modules/playwright-core/lib/server/chromium/crApp.js
var require_crApp = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crApp.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.installAppIcon = installAppIcon;
    var _fs = _interopRequireDefault(__require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function installAppIcon(page) {
      const icon = await _fs.default.promises.readFile(__require.resolve("./appIcon.png"));
      const crPage = page._delegate;
      await crPage._mainFrameSession._client.send("Browser.setDockTile", {
        image: icon.toString("base64")
      });
    }
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module) {
    init_shims();
    var constants = __require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module.exports = patch;
    function patch(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (!fs2.lchmod) {
        fs2.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (!fs2.lchown) {
        fs2.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs2.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs2.rename);
      }
      fs2.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs2.read);
      fs2.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function(path, mode, callback) {
          fs3.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs3.fchmod(fd, mode, function(err2) {
              fs3.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs3.lchmodSync = function(path, mode) {
          var fd = fs3.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs3.lutimes = function(path, at, mt, cb) {
            fs3.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function(er2) {
                fs3.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function(path, at, mt) {
            var fd = fs3.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs3.lutimes = function(_a2, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs3.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options2, cb) {
          if (typeof options2 === "function") {
            cb = options2;
            options2 = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options2) {
          var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    init_shims();
    var Stream2 = __require("stream").Stream;
    module.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options2) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options2);
        Stream2.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options2 = options2 || {};
        var keys = Object.keys(options2);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options2[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options2) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options2);
        Stream2.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options2 = options2 || {};
        var keys = Object.keys(options2);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options2[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = clone2;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone2(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    init_shims();
    var fs2 = __require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone2 = require_clone();
    var util = __require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop3() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop3;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs2[gracefulQueue]);
          __require("assert").equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module.exports = patch(clone2(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch;
      fs3.createReadStream = createReadStream2;
      fs3.createWriteStream = createWriteStream;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile;
      function readFile(path, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = null;
        return go$readFile(path, options2, cb);
        function go$readFile(path2, options3, cb2, startTime) {
          return fs$readFile(path2, options3, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile;
      function writeFile(path, data, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = null;
        return go$writeFile(path, data, options2, cb);
        function go$writeFile(path2, data2, options3, cb2, startTime) {
          return fs$writeFile(path2, data2, options3, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile)
        fs3.appendFile = appendFile;
      function appendFile(path, data, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = null;
        return go$appendFile(path, data, options2, cb);
        function go$appendFile(path2, data2, options3, cb2, startTime) {
          return fs$appendFile(path2, data2, options3, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile)
        fs3.copyFile = copyFile;
      function copyFile(src2, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src2, dest, flags, cb);
        function go$copyFile(src3, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src3, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir;
      function readdir(path, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = null;
        return go$readdir(path, options2, cb);
        function go$readdir(path2, options3, cb2, startTime) {
          return fs$readdir(path2, options3, function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readdir, [path2, options3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          });
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs3);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs3, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs3, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs3, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options2) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options2) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream2(path, options2) {
        return new fs3.ReadStream(path, options2);
      }
      function createWriteStream(path, options2) {
        return new fs3.WriteStream(path, options2);
      }
      var fs$open = fs3.open;
      fs3.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
        if (fs2[gracefulQueue][i].length > 2) {
          fs2[gracefulQueue][i][3] = now;
          fs2[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0)
        return;
      var elem = fs2[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module) {
    init_shims();
    function RetryOperation(timeouts, options2) {
      if (typeof options2 === "boolean") {
        options2 = { forever: options2 };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options2 || {};
      this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error2 = this._errors[i];
        var message = error2.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error2;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    init_shims();
    var RetryOperation = require_retry_operation();
    exports.operation = function(options2) {
      var timeouts = exports.timeouts(options2);
      return new RetryOperation(timeouts, {
        forever: options2 && options2.forever,
        unref: options2 && options2.unref,
        maxRetryTime: options2 && options2.maxRetryTime
      });
    };
    exports.timeouts = function(options2) {
      if (options2 instanceof Array) {
        return [].concat(options2);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options2) {
        opts[key] = options2[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options2 && options2.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options2, methods) {
      if (options2 instanceof Array) {
        methods = options2;
        options2 = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options2);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options2;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module) {
    init_shims();
    module.exports = require_retry();
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports, module) {
    init_shims();
    module.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports, module) {
    init_shims();
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module.exports = function() {
      };
    } else {
      assert = __require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process2.platform);
      EE = __require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return;
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load2();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load2 = function load3() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module.exports.load = load2;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || 0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load2;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/proper-lockfile/lib/mtime-precision.js
var require_mtime_precision = __commonJS({
  "node_modules/proper-lockfile/lib/mtime-precision.js"(exports, module) {
    init_shims();
    "use strict";
    var cacheSymbol = Symbol();
    function probe(file, fs2, callback) {
      const cachedPrecision = fs2[cacheSymbol];
      if (cachedPrecision) {
        return fs2.stat(file, (err, stat) => {
          if (err) {
            return callback(err);
          }
          callback(null, stat.mtime, cachedPrecision);
        });
      }
      const mtime = new Date(Math.ceil(Date.now() / 1e3) * 1e3 + 5);
      fs2.utimes(file, mtime, mtime, (err) => {
        if (err) {
          return callback(err);
        }
        fs2.stat(file, (err2, stat) => {
          if (err2) {
            return callback(err2);
          }
          const precision = stat.mtime.getTime() % 1e3 === 0 ? "s" : "ms";
          Object.defineProperty(fs2, cacheSymbol, { value: precision });
          callback(null, stat.mtime, precision);
        });
      });
    }
    function getMtime(precision) {
      let now = Date.now();
      if (precision === "s") {
        now = Math.ceil(now / 1e3) * 1e3;
      }
      return new Date(now);
    }
    module.exports.probe = probe;
    module.exports.getMtime = getMtime;
  }
});

// node_modules/proper-lockfile/lib/lockfile.js
var require_lockfile = __commonJS({
  "node_modules/proper-lockfile/lib/lockfile.js"(exports, module) {
    init_shims();
    "use strict";
    var path = __require("path");
    var fs2 = require_graceful_fs();
    var retry = require_retry2();
    var onExit = require_signal_exit();
    var mtimePrecision = require_mtime_precision();
    var locks = {};
    function getLockFile(file, options2) {
      return options2.lockfilePath || `${file}.lock`;
    }
    function resolveCanonicalPath(file, options2, callback) {
      if (!options2.realpath) {
        return callback(null, path.resolve(file));
      }
      options2.fs.realpath(file, callback);
    }
    function acquireLock(file, options2, callback) {
      const lockfilePath = getLockFile(file, options2);
      options2.fs.mkdir(lockfilePath, (err) => {
        if (!err) {
          return mtimePrecision.probe(lockfilePath, options2.fs, (err2, mtime, mtimePrecision2) => {
            if (err2) {
              options2.fs.rmdir(lockfilePath, () => {
              });
              return callback(err2);
            }
            callback(null, mtime, mtimePrecision2);
          });
        }
        if (err.code !== "EEXIST") {
          return callback(err);
        }
        if (options2.stale <= 0) {
          return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
        }
        options2.fs.stat(lockfilePath, (err2, stat) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return acquireLock(file, __spreadProps(__spreadValues({}, options2), { stale: 0 }), callback);
            }
            return callback(err2);
          }
          if (!isLockStale(stat, options2)) {
            return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
          }
          removeLock(file, options2, (err3) => {
            if (err3) {
              return callback(err3);
            }
            acquireLock(file, __spreadProps(__spreadValues({}, options2), { stale: 0 }), callback);
          });
        });
      });
    }
    function isLockStale(stat, options2) {
      return stat.mtime.getTime() < Date.now() - options2.stale;
    }
    function removeLock(file, options2, callback) {
      options2.fs.rmdir(getLockFile(file, options2), (err) => {
        if (err && err.code !== "ENOENT") {
          return callback(err);
        }
        callback();
      });
    }
    function updateLock(file, options2) {
      const lock2 = locks[file];
      if (lock2.updateTimeout) {
        return;
      }
      lock2.updateDelay = lock2.updateDelay || options2.update;
      lock2.updateTimeout = setTimeout(() => {
        lock2.updateTimeout = null;
        options2.fs.stat(lock2.lockfilePath, (err, stat) => {
          const isOverThreshold = lock2.lastUpdate + options2.stale < Date.now();
          if (err) {
            if (err.code === "ENOENT" || isOverThreshold) {
              return setLockAsCompromised(file, lock2, Object.assign(err, { code: "ECOMPROMISED" }));
            }
            lock2.updateDelay = 1e3;
            return updateLock(file, options2);
          }
          const isMtimeOurs = lock2.mtime.getTime() === stat.mtime.getTime();
          if (!isMtimeOurs) {
            return setLockAsCompromised(file, lock2, Object.assign(new Error("Unable to update lock within the stale threshold"), { code: "ECOMPROMISED" }));
          }
          const mtime = mtimePrecision.getMtime(lock2.mtimePrecision);
          options2.fs.utimes(lock2.lockfilePath, mtime, mtime, (err2) => {
            const isOverThreshold2 = lock2.lastUpdate + options2.stale < Date.now();
            if (lock2.released) {
              return;
            }
            if (err2) {
              if (err2.code === "ENOENT" || isOverThreshold2) {
                return setLockAsCompromised(file, lock2, Object.assign(err2, { code: "ECOMPROMISED" }));
              }
              lock2.updateDelay = 1e3;
              return updateLock(file, options2);
            }
            lock2.mtime = mtime;
            lock2.lastUpdate = Date.now();
            lock2.updateDelay = null;
            updateLock(file, options2);
          });
        });
      }, lock2.updateDelay);
      if (lock2.updateTimeout.unref) {
        lock2.updateTimeout.unref();
      }
    }
    function setLockAsCompromised(file, lock2, err) {
      lock2.released = true;
      if (lock2.updateTimeout) {
        clearTimeout(lock2.updateTimeout);
      }
      if (locks[file] === lock2) {
        delete locks[file];
      }
      lock2.options.onCompromised(err);
    }
    function lock(file, options2, callback) {
      options2 = __spreadValues({
        stale: 1e4,
        update: null,
        realpath: true,
        retries: 0,
        fs: fs2,
        onCompromised: (err) => {
          throw err;
        }
      }, options2);
      options2.retries = options2.retries || 0;
      options2.retries = typeof options2.retries === "number" ? { retries: options2.retries } : options2.retries;
      options2.stale = Math.max(options2.stale || 0, 2e3);
      options2.update = options2.update == null ? options2.stale / 2 : options2.update || 0;
      options2.update = Math.max(Math.min(options2.update, options2.stale / 2), 1e3);
      resolveCanonicalPath(file, options2, (err, file2) => {
        if (err) {
          return callback(err);
        }
        const operation = retry.operation(options2.retries);
        operation.attempt(() => {
          acquireLock(file2, options2, (err2, mtime, mtimePrecision2) => {
            if (operation.retry(err2)) {
              return;
            }
            if (err2) {
              return callback(operation.mainError());
            }
            const lock2 = locks[file2] = {
              lockfilePath: getLockFile(file2, options2),
              mtime,
              mtimePrecision: mtimePrecision2,
              options: options2,
              lastUpdate: Date.now()
            };
            updateLock(file2, options2);
            callback(null, (releasedCallback) => {
              if (lock2.released) {
                return releasedCallback && releasedCallback(Object.assign(new Error("Lock is already released"), { code: "ERELEASED" }));
              }
              unlock(file2, __spreadProps(__spreadValues({}, options2), { realpath: false }), releasedCallback);
            });
          });
        });
      });
    }
    function unlock(file, options2, callback) {
      options2 = __spreadValues({
        fs: fs2,
        realpath: true
      }, options2);
      resolveCanonicalPath(file, options2, (err, file2) => {
        if (err) {
          return callback(err);
        }
        const lock2 = locks[file2];
        if (!lock2) {
          return callback(Object.assign(new Error("Lock is not acquired/owned by you"), { code: "ENOTACQUIRED" }));
        }
        lock2.updateTimeout && clearTimeout(lock2.updateTimeout);
        lock2.released = true;
        delete locks[file2];
        removeLock(file2, options2, callback);
      });
    }
    function check(file, options2, callback) {
      options2 = __spreadValues({
        stale: 1e4,
        realpath: true,
        fs: fs2
      }, options2);
      options2.stale = Math.max(options2.stale || 0, 2e3);
      resolveCanonicalPath(file, options2, (err, file2) => {
        if (err) {
          return callback(err);
        }
        options2.fs.stat(getLockFile(file2, options2), (err2, stat) => {
          if (err2) {
            return err2.code === "ENOENT" ? callback(null, false) : callback(err2);
          }
          return callback(null, !isLockStale(stat, options2));
        });
      });
    }
    function getLocks() {
      return locks;
    }
    onExit(() => {
      for (const file in locks) {
        const options2 = locks[file].options;
        try {
          options2.fs.rmdirSync(getLockFile(file, options2));
        } catch (e) {
        }
      }
    });
    module.exports.lock = lock;
    module.exports.unlock = unlock;
    module.exports.check = check;
    module.exports.getLocks = getLocks;
  }
});

// node_modules/proper-lockfile/lib/adapter.js
var require_adapter = __commonJS({
  "node_modules/proper-lockfile/lib/adapter.js"(exports, module) {
    init_shims();
    "use strict";
    var fs2 = require_graceful_fs();
    function createSyncFs(fs3) {
      const methods = ["mkdir", "realpath", "stat", "rmdir", "utimes"];
      const newFs = __spreadValues({}, fs3);
      methods.forEach((method) => {
        newFs[method] = (...args) => {
          const callback = args.pop();
          let ret;
          try {
            ret = fs3[`${method}Sync`](...args);
          } catch (err) {
            return callback(err);
          }
          callback(null, ret);
        };
      });
      return newFs;
    }
    function toPromise(method) {
      return (...args) => new Promise((resolve3, reject) => {
        args.push((err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve3(result);
          }
        });
        method(...args);
      });
    }
    function toSync(method) {
      return (...args) => {
        let err;
        let result;
        args.push((_err, _result) => {
          err = _err;
          result = _result;
        });
        method(...args);
        if (err) {
          throw err;
        }
        return result;
      };
    }
    function toSyncOptions(options2) {
      options2 = __spreadValues({}, options2);
      options2.fs = createSyncFs(options2.fs || fs2);
      if (typeof options2.retries === "number" && options2.retries > 0 || options2.retries && typeof options2.retries.retries === "number" && options2.retries.retries > 0) {
        throw Object.assign(new Error("Cannot use retries with the sync api"), { code: "ESYNC" });
      }
      return options2;
    }
    module.exports = {
      toPromise,
      toSync,
      toSyncOptions
    };
  }
});

// node_modules/proper-lockfile/index.js
var require_proper_lockfile = __commonJS({
  "node_modules/proper-lockfile/index.js"(exports, module) {
    init_shims();
    "use strict";
    var lockfile = require_lockfile();
    var { toPromise, toSync, toSyncOptions } = require_adapter();
    async function lock(file, options2) {
      const release = await toPromise(lockfile.lock)(file, options2);
      return toPromise(release);
    }
    function lockSync(file, options2) {
      const release = toSync(lockfile.lock)(file, toSyncOptions(options2));
      return toSync(release);
    }
    function unlock(file, options2) {
      return toPromise(lockfile.unlock)(file, options2);
    }
    function unlockSync(file, options2) {
      return toSync(lockfile.unlock)(file, toSyncOptions(options2));
    }
    function check(file, options2) {
      return toPromise(lockfile.check)(file, options2);
    }
    function checkSync(file, options2) {
      return toSync(lockfile.check)(file, toSyncOptions(options2));
    }
    module.exports = lock;
    module.exports.lock = lock;
    module.exports.unlock = unlock;
    module.exports.lockSync = lockSync;
    module.exports.unlockSync = unlockSync;
    module.exports.check = check;
    module.exports.checkSync = checkSync;
  }
});

// node_modules/playwright-core/lib/utils/nativeDeps.js
var require_nativeDeps = __commonJS({
  "node_modules/playwright-core/lib/utils/nativeDeps.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.deps = void 0;
    var deps = {
      "ubuntu18.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["fonts-liberation", "libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libegl1", "libgbm1", "libglib2.0-0", "libgtk-3-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libx11-xcb1", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libbrotli1", "libcairo2", "libegl1", "libenchant1c2a", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libicu60", "libjpeg-turbo8", "libnotify4", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libvpx5", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebp6", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libbrotlidec.so.1": "libbrotli1",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant.so.1": "libenchant1c2a",
          "libepoxy.so.0": "libepoxy0",
          "libevent-2.1.so.6": "libevent-2.1-6",
          "libevdev.so.2": "libevdev2",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
          "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicudata.so.60": "libicu60",
          "libicui18n.so.60": "libicu60",
          "libicuuc.so.60": "libicu60",
          "libjpeg.so.8": "libjpeg-turbo8",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libvpx.so.5": "libvpx5",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-dri3.so.0": "libxcb-dri3-0",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6",
          "libXtst.so.6": "libxtst6"
        }
      },
      "ubuntu20.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["fonts-liberation", "libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libegl1", "libgbm1", "libglib2.0-0", "libgtk-3-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libx11-xcb1", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libegl1", "libenchant1c2a", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libicu66", "libjpeg-turbo8", "libnotify4", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libsoup2.4-1", "libvpx6", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebp6", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant.so.1": "libenchant1c2a",
          "libevdev.so.2": "libevdev2",
          "libepoxy.so.0": "libepoxy0",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
          "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicui18n.so.66": "libicu66",
          "libicuuc.so.66": "libicu66",
          "libjpeg.so.8": "libjpeg-turbo8",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libvpx.so.6": "libvpx6",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-dri3.so.0": "libxcb-dri3-0",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6",
          "libXtst.so.6": "libxtst6",
          "libxshmfence.so.1": "libxshmfence1"
        }
      },
      "ubuntu21.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libgbm1", "libglib2.0-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxkbcommon0", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf-2.0-0", "libglib2.0-0", "libgtk-3-0", "libgtk2.0-0", "libharfbuzz0b", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libegl1", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf-2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer-plugins-bad1.0-0", "libgstreamer-plugins-base1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libjavascriptcoregtk-4.0-18", "libjpeg-turbo8", "liblcms2-2", "libnotify4", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libsoup2.4-1", "libvpx6", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebkit2gtk-4.0-37", "libwebp6", "libwebpdemux2", "libwoff1", "libwpe-1.0-1", "libwpebackend-fdo-1.0-1", "libwpewebkit-1.0-3", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libepoxy.so.0": "libepoxy0",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "libgstreamer-plugins-bad1.0-0",
          "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libjavascriptcoregtk-4.0.so.18": "libjavascriptcoregtk-4.0-18",
          "libjpeg.so.8": "libjpeg-turbo8",
          "liblcms2.so.2": "liblcms2-2",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libvpx.so.6": "libvpx6",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebkit2gtk-4.0.so.37": "libwebkit2gtk-4.0-37",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libwpe-1.0.so.1": "libwpe-1.0-1",
          "libWPEBackend-fdo-1.0.so.1": "libwpebackend-fdo-1.0-1",
          "libWPEWebKit-1.0.so.3": "libwpewebkit-1.0-3",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxshmfence.so.1": "libxshmfence1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6"
        }
      }
    };
    exports.deps = deps;
    deps["ubuntu20.04-arm64"] = {
      tools: [...deps["ubuntu20.04"].tools],
      chromium: [...deps["ubuntu20.04"].chromium],
      firefox: [...deps["ubuntu20.04"].firefox],
      webkit: [...deps["ubuntu20.04"].webkit, "libevent-2.1-7"],
      lib2package: __spreadProps(__spreadValues({}, deps["ubuntu20.04"].lib2package), {
        "libevent-2.1.so.7": "libevent-2.1.so.7"
      })
    };
  }
});

// node_modules/playwright-core/lib/utils/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/playwright-core/lib/utils/dependencies.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.installDependenciesWindows = installDependenciesWindows;
    exports.installDependenciesLinux = installDependenciesLinux;
    exports.validateDependenciesWindows = validateDependenciesWindows;
    exports.validateDependenciesLinux = validateDependenciesLinux;
    var _fs = _interopRequireDefault(__require("fs"));
    var _path = _interopRequireDefault(__require("path"));
    var os = _interopRequireWildcard(__require("os"));
    var _child_process = _interopRequireDefault(__require("child_process"));
    var utils = _interopRequireWildcard(require_utils());
    var _registry = require_registry();
    var _nativeDeps = require_nativeDeps();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var BIN_DIRECTORY = _path.default.join(__dirname, "..", "..", "bin");
    var checkExecutable = (filePath) => _fs.default.promises.access(filePath, _fs.default.constants.X_OK).then(() => true).catch((e) => false);
    function isSupportedWindowsVersion() {
      if (os.platform() !== "win32" || os.arch() !== "x64")
        return false;
      const [major, minor] = os.release().split(".").map((token) => parseInt(token, 10));
      return major > 6 || major === 6 && minor > 1;
    }
    async function installDependenciesWindows(targets) {
      if (targets.has("chromium")) {
        const {
          code
        } = await utils.spawnAsync("powershell.exe", ["-ExecutionPolicy", "Bypass", "-File", _path.default.join(BIN_DIRECTORY, "install_media_pack.ps1")], {
          cwd: BIN_DIRECTORY,
          stdio: "inherit"
        });
        if (code !== 0)
          throw new Error("Failed to install windows dependencies!");
      }
    }
    async function installDependenciesLinux(targets) {
      const libraries = [];
      for (const target of targets) {
        const info = _nativeDeps.deps[utils.hostPlatform];
        if (!info) {
          console.warn("Cannot install dependencies for this linux distribution!");
          return;
        }
        libraries.push(...info[target]);
      }
      const uniqueLibraries = Array.from(new Set(libraries));
      console.log("Installing Ubuntu dependencies...");
      const commands = [];
      commands.push("apt-get update");
      commands.push(["apt-get", "install", "-y", "--no-install-recommends", ...uniqueLibraries].join(" "));
      const [command, args] = await buildAptProcessArgs(commands);
      const child = _child_process.default.spawn(command, args, {
        stdio: "inherit"
      });
      await new Promise((resolve3, reject) => {
        child.on("exit", resolve3);
        child.on("error", reject);
      });
    }
    async function buildAptProcessArgs(commands) {
      const isRoot = process.getuid() === 0;
      if (isRoot)
        return ["sh", ["-c", `${commands.join("&& ")}`]];
      const sudoExists = await utils.spawnAsync("which", ["sudo"]);
      if (sudoExists.code === 0)
        return ["sudo", ["--", "sh", "-c", `${commands.join("&& ")}`]];
      return ["su", ["root", "-c", `${commands.join("&& ")}`]];
    }
    async function validateDependenciesWindows(windowsExeAndDllDirectories) {
      const directoryPaths = windowsExeAndDllDirectories;
      const lddPaths = [];
      for (const directoryPath of directoryPaths)
        lddPaths.push(...await executablesOrSharedLibraries(directoryPath));
      const allMissingDeps = await Promise.all(lddPaths.map((lddPath) => missingFileDependenciesWindows(lddPath)));
      const missingDeps = new Set();
      for (const deps of allMissingDeps) {
        for (const dep of deps)
          missingDeps.add(dep);
      }
      if (!missingDeps.size)
        return;
      let isCrtMissing = false;
      let isMediaFoundationMissing = false;
      for (const dep of missingDeps) {
        if (dep.startsWith("api-ms-win-crt") || dep === "vcruntime140.dll" || dep === "vcruntime140_1.dll" || dep === "msvcp140.dll")
          isCrtMissing = true;
        else if (dep === "mf.dll" || dep === "mfplat.dll" || dep === "msmpeg2vdec.dll" || dep === "evr.dll" || dep === "avrt.dll")
          isMediaFoundationMissing = true;
      }
      const details = [];
      if (isCrtMissing) {
        details.push(`Some of the Universal C Runtime files cannot be found on the system. You can fix`, `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`, `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`, ``);
      }
      if (isMediaFoundationMissing) {
        details.push(`Some of the Media Foundation files cannot be found on the system. If you are`, `on Windows Server try fixing this by running the following command in PowerShell`, `as Administrator:`, ``, `    Install-WindowsFeature Server-Media-Foundation`, ``, `For Windows N editions visit:`, `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`, ``);
      }
      details.push(`Full list of missing libraries:`, `    ${[...missingDeps].join("\n    ")}`, ``);
      const message = `Host system is missing dependencies!

${details.join("\n")}`;
      if (isSupportedWindowsVersion()) {
        throw new Error(message);
      } else {
        console.warn(`WARNING: running on unsupported windows version!`);
        console.warn(message);
      }
    }
    async function validateDependenciesLinux(sdkLanguage, linuxLddDirectories, dlOpenLibraries) {
      var _deps$utils$hostPlatf;
      const directoryPaths = linuxLddDirectories;
      const lddPaths = [];
      for (const directoryPath of directoryPaths)
        lddPaths.push(...await executablesOrSharedLibraries(directoryPath));
      const allMissingDeps = await Promise.all(lddPaths.map((lddPath) => missingFileDependencies(lddPath, directoryPaths)));
      const missingDeps = new Set();
      for (const deps of allMissingDeps) {
        for (const dep of deps)
          missingDeps.add(dep);
      }
      for (const dep of await missingDLOPENLibraries(dlOpenLibraries))
        missingDeps.add(dep);
      if (!missingDeps.size)
        return;
      const missingPackages = new Set();
      const libraryToPackageNameMapping = __spreadValues(__spreadValues({}, ((_deps$utils$hostPlatf = _nativeDeps.deps[utils.hostPlatform]) === null || _deps$utils$hostPlatf === void 0 ? void 0 : _deps$utils$hostPlatf.lib2package) || {}), MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU);
      for (const missingDep of missingDeps) {
        const packageName = libraryToPackageNameMapping[missingDep];
        if (packageName) {
          missingPackages.add(packageName);
          missingDeps.delete(missingDep);
        }
      }
      const maybeSudo = process.getuid() !== 0 && os.platform() !== "win32" ? "sudo " : "";
      if (missingPackages.size && !missingDeps.size) {
        throw new Error("\n" + utils.wrapInASCIIBox([`Host system is missing a few dependencies to run browsers.`, `Please install them with the following command:`, ``, `    ${maybeSudo}${(0, _registry.buildPlaywrightCLICommand)(sdkLanguage, "install-deps")}`, ``, `<3 Playwright Team`].join("\n"), 1));
      }
      let missingPackagesMessage = "";
      if (missingPackages.size) {
        missingPackagesMessage = [`  Install missing packages with:`, `      ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n          ")}`, ``, ``].join("\n");
      }
      let missingDependenciesMessage = "";
      if (missingDeps.size) {
        const header = missingPackages.size ? `Missing libraries we didn't find packages for:` : `Missing libraries are:`;
        missingDependenciesMessage = [`  ${header}`, `      ${[...missingDeps].join("\n      ")}`, ``].join("\n");
      }
      throw new Error("Host system is missing dependencies!\n\n" + missingPackagesMessage + missingDependenciesMessage);
    }
    function isSharedLib(basename) {
      switch (os.platform()) {
        case "linux":
          return basename.endsWith(".so") || basename.includes(".so.");
        case "win32":
          return basename.endsWith(".dll");
        default:
          return false;
      }
    }
    async function executablesOrSharedLibraries(directoryPath) {
      const allPaths = (await _fs.default.promises.readdir(directoryPath)).map((file) => _path.default.resolve(directoryPath, file));
      const allStats = await Promise.all(allPaths.map((aPath) => _fs.default.promises.stat(aPath)));
      const filePaths = allPaths.filter((aPath, index) => allStats[index].isFile());
      const executablersOrLibraries = (await Promise.all(filePaths.map(async (filePath) => {
        const basename = _path.default.basename(filePath).toLowerCase();
        if (isSharedLib(basename))
          return filePath;
        if (await checkExecutable(filePath))
          return filePath;
        return false;
      }))).filter(Boolean);
      return executablersOrLibraries;
    }
    async function missingFileDependenciesWindows(filePath) {
      const executable = _path.default.join(__dirname, "..", "..", "bin", "PrintDeps.exe");
      const dirname2 = _path.default.dirname(filePath);
      const {
        stdout,
        code
      } = await utils.spawnAsync(executable, [filePath], {
        cwd: dirname2,
        env: __spreadProps(__spreadValues({}, process.env), {
          LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname2}` : dirname2
        })
      });
      if (code !== 0)
        return [];
      const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim().toLowerCase());
      return missingDeps;
    }
    async function missingFileDependencies(filePath, extraLDPaths) {
      const dirname2 = _path.default.dirname(filePath);
      let LD_LIBRARY_PATH = extraLDPaths.join(":");
      if (process.env.LD_LIBRARY_PATH)
        LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
      const {
        stdout,
        code
      } = await utils.spawnAsync("ldd", [filePath], {
        cwd: dirname2,
        env: __spreadProps(__spreadValues({}, process.env), {
          LD_LIBRARY_PATH
        })
      });
      if (code !== 0)
        return [];
      const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim());
      return missingDeps;
    }
    async function missingDLOPENLibraries(libraries) {
      if (!libraries.length)
        return [];
      const {
        stdout,
        code,
        error: error2
      } = await utils.spawnAsync("/sbin/ldconfig", ["-p"], {});
      if (code !== 0 || error2)
        return [];
      const isLibraryAvailable = (library) => stdout.toLowerCase().includes(library.toLowerCase());
      return libraries.filter((library) => !isLibraryAvailable(library));
    }
    var MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
      "libx264.so": "gstreamer1.0-libav"
    };
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module) {
    init_shims();
    var once = require_once();
    var noop3 = function() {
    };
    var isRequest2 = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop3);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable2 = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable2 = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable2)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable2 && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest2(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable2 && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports, module) {
    init_shims();
    var once = require_once();
    var eos = require_end_of_stream();
    var fs2 = __require("fs");
    var noop3 = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs2)
        return false;
      return (stream instanceof (fs2.ReadStream || noop3) || stream instanceof (fs2.WriteStream || noop3)) && isFn(stream.close);
    };
    var isRequest2 = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop3);
        if (isRequest2(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop3) && streams.pop() || noop3;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error2;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error2)
            error2 = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error2);
        });
      });
      return streams.reduce(pipe);
    };
    module.exports = pump;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports, module) {
    init_shims();
    "use strict";
    var { PassThrough: PassThroughStream } = __require("stream");
    module.exports = (options2) => {
      options2 = __spreadValues({}, options2);
      const { array } = options2;
      let { encoding } = options2;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports, module) {
    init_shims();
    "use strict";
    var { constants: BufferConstants } = __require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options2) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options2 = __spreadValues({
        maxBuffer: Infinity
      }, options2);
      const { maxBuffer } = options2;
      let stream;
      await new Promise((resolve3, reject) => {
        const rejectPromise = (error2) => {
          if (error2 && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error2.bufferedData = stream.getBufferedValue();
          }
          reject(error2);
        };
        stream = pump(inputStream, bufferStream(options2), (error2) => {
          if (error2) {
            rejectPromise(error2);
            return;
          }
          resolve3();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream.getBufferedValue();
    }
    module.exports = getStream;
    module.exports.default = getStream;
    module.exports.buffer = (stream, options2) => getStream(stream, __spreadProps(__spreadValues({}, options2), { encoding: "buffer" }));
    module.exports.array = (stream, options2) => getStream(stream, __spreadProps(__spreadValues({}, options2), { array: true }));
    module.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports, module) {
    init_shims();
    module.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/fd-slicer/index.js"(exports) {
    init_shims();
    var fs2 = __require("fs");
    var util = __require("util");
    var stream = __require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough2 = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = __require("events").EventEmitter;
    exports.createFromBuffer = createFromBuffer;
    exports.createFromFd = createFromFd;
    exports.BufferSlicer = BufferSlicer;
    exports.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options2.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs2.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs2.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options2) {
      return new ReadStream(this, options2);
    };
    FdSlicer.prototype.createWriteStream = function(options2) {
      return new WriteStream(this, options2);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs2.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options2) {
      options2 = options2 || {};
      Readable.call(this, options2);
      this.context = context;
      this.context.ref();
      this.start = options2.start || 0;
      this.endOffset = options2.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs2.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options2) {
      options2 = options2 || {};
      Writable.call(this, options2);
      this.context = context;
      this.context.ref();
      this.start = options2.start || 0;
      this.endOffset = options2.end == null ? Infinity : +options2.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs2.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options2) {
      EventEmitter.call(this);
      options2 = options2 || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options2.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options2) {
      options2 = options2 || {};
      var readStream = new PassThrough2(options2);
      readStream.destroyed = false;
      readStream.start = options2.start || 0;
      readStream.endOffset = options2.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options2) {
      var bufferSlicer = this;
      options2 = options2 || {};
      var writeStream = new Writable(options2);
      writeStream.start = options2.start || 0;
      writeStream.endOffset = options2.end == null ? this.buffer.length : +options2.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options2) {
      return new BufferSlicer(buffer, options2);
    }
    function createFromFd(fd, options2) {
      return new FdSlicer(fd, options2);
    }
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports) {
    init_shims();
    var fs2 = __require("fs");
    var zlib2 = __require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = __require("util");
    var EventEmitter = __require("events").EventEmitter;
    var Transform = __require("stream").Transform;
    var PassThrough2 = __require("stream").PassThrough;
    var Writable = __require("stream").Writable;
    exports.open = open;
    exports.fromFd = fromFd;
    exports.fromBuffer = fromBuffer;
    exports.fromRandomAccessReader = fromRandomAccessReader;
    exports.dosDateTimeToDate = dosDateTimeToDate;
    exports.validateFileName = validateFileName;
    exports.ZipFile = ZipFile;
    exports.Entry = Entry;
    exports.RandomAccessReader = RandomAccessReader;
    function open(path, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null)
        options2 = {};
      if (options2.autoClose == null)
        options2.autoClose = true;
      if (options2.lazyEntries == null)
        options2.lazyEntries = false;
      if (options2.decodeStrings == null)
        options2.decodeStrings = true;
      if (options2.validateEntrySizes == null)
        options2.validateEntrySizes = true;
      if (options2.strictFileNames == null)
        options2.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs2.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options2, function(err2, zipfile) {
          if (err2)
            fs2.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null)
        options2 = {};
      if (options2.autoClose == null)
        options2.autoClose = false;
      if (options2.lazyEntries == null)
        options2.lazyEntries = false;
      if (options2.decodeStrings == null)
        options2.decodeStrings = true;
      if (options2.validateEntrySizes == null)
        options2.validateEntrySizes = true;
      if (options2.strictFileNames == null)
        options2.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs2.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options2, callback);
      });
    }
    function fromBuffer(buffer, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null)
        options2 = {};
      options2.autoClose = false;
      if (options2.lazyEntries == null)
        options2.lazyEntries = false;
      if (options2.decodeStrings == null)
        options2.decodeStrings = true;
      if (options2.validateEntrySizes == null)
        options2.validateEntrySizes = true;
      if (options2.strictFileNames == null)
        options2.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options2, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null)
        options2 = {};
      if (options2.autoClose == null)
        options2.autoClose = true;
      if (options2.lazyEntries == null)
        options2.lazyEntries = false;
      if (options2.decodeStrings == null)
        options2.decodeStrings = true;
      var decodeStrings = !!options2.decodeStrings;
      if (options2.validateEntrySizes == null)
        options2.validateEntrySizes = true;
      if (options2.strictFileNames == null)
        options2.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options2, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options2;
        options2 = {};
      } else {
        if (options2.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options2.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options2.decrypt);
          if (entry.isCompressed()) {
            if (options2.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options2.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options2.decompress === false || options2.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options2.decompress);
          }
        }
        if (options2.start != null || options2.end != null) {
          if (entry.isCompressed() && options2.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options2.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options2.start != null) {
          relativeStart = options2.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options2.end != null) {
          relativeEnd = options2.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options2.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options2.decompress != null ? options2.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib2.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options2) {
      var start = options2.start;
      var end = options2.end;
      if (start === end) {
        var emptyStream = new PassThrough2();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error2) {
        callback(error2);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough2);
    function RefUnrefFilter(context) {
      PassThrough2.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// node_modules/playwright-core/node_modules/extract-zip/index.js
var require_extract_zip = __commonJS({
  "node_modules/playwright-core/node_modules/extract-zip/index.js"(exports, module) {
    init_shims();
    var debug = require_src()("extract-zip");
    var { createWriteStream, promises: fs2 } = __require("fs");
    var getStream = require_get_stream();
    var path = __require("path");
    var { promisify } = __require("util");
    var stream = __require("stream");
    var yauzl = require_yauzl();
    var openZip = promisify(yauzl.open);
    var pipeline2 = promisify(stream.pipeline);
    var Extractor = class {
      constructor(zipPath, opts) {
        this.zipPath = zipPath;
        this.opts = opts;
      }
      async extract() {
        debug("opening", this.zipPath, "with opts", this.opts);
        this.zipfile = await openZip(this.zipPath, { lazyEntries: true });
        this.canceled = false;
        return new Promise((resolve3, reject) => {
          this.zipfile.on("error", (err) => {
            this.canceled = true;
            reject(err);
          });
          this.zipfile.readEntry();
          this.zipfile.on("close", () => {
            if (!this.canceled) {
              debug("zip extraction complete");
              resolve3();
            }
          });
          this.zipfile.on("entry", async (entry) => {
            if (this.canceled) {
              debug("skipping entry", entry.fileName, { cancelled: this.canceled });
              return;
            }
            debug("zipfile entry", entry.fileName);
            if (entry.fileName.startsWith("__MACOSX/")) {
              this.zipfile.readEntry();
              return;
            }
            const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));
            try {
              await fs2.mkdir(destDir, { recursive: true });
              const canonicalDestDir = await fs2.realpath(destDir);
              const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);
              if (relativeDestDir.split(path.sep).includes("..")) {
                throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
              }
              await this.extractEntry(entry);
              debug("finished processing", entry.fileName);
              this.zipfile.readEntry();
            } catch (err) {
              this.canceled = true;
              this.zipfile.close();
              reject(err);
            }
          });
        });
      }
      async extractEntry(entry) {
        if (this.canceled) {
          debug("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
          return;
        }
        if (this.opts.onEntry) {
          this.opts.onEntry(entry, this.zipfile);
        }
        const dest = path.join(this.opts.dir, entry.fileName);
        const mode = entry.externalFileAttributes >> 16 & 65535;
        const IFMT = 61440;
        const IFDIR = 16384;
        const IFLNK = 40960;
        const symlink = (mode & IFMT) === IFLNK;
        let isDir = (mode & IFMT) === IFDIR;
        if (!isDir && entry.fileName.endsWith("/")) {
          isDir = true;
        }
        const madeBy = entry.versionMadeBy >> 8;
        if (!isDir)
          isDir = madeBy === 0 && entry.externalFileAttributes === 16;
        debug("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink });
        const procMode = this.getExtractedMode(mode, isDir) & 511;
        const destDir = isDir ? dest : path.dirname(dest);
        const mkdirOptions = { recursive: true };
        if (isDir) {
          mkdirOptions.mode = procMode;
        }
        debug("mkdir", __spreadValues({ dir: destDir }, mkdirOptions));
        await fs2.mkdir(destDir, mkdirOptions);
        if (isDir)
          return;
        debug("opening read stream", dest);
        const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
        if (symlink) {
          const link = await getStream(readStream);
          debug("creating symlink", link, dest);
          await fs2.symlink(link, dest);
        } else {
          await pipeline2(readStream, createWriteStream(dest, { mode: procMode }));
        }
      }
      getExtractedMode(entryMode, isDir) {
        let mode = entryMode;
        if (mode === 0) {
          if (isDir) {
            if (this.opts.defaultDirMode) {
              mode = parseInt(this.opts.defaultDirMode, 10);
            }
            if (!mode) {
              mode = 493;
            }
          } else {
            if (this.opts.defaultFileMode) {
              mode = parseInt(this.opts.defaultFileMode, 10);
            }
            if (!mode) {
              mode = 420;
            }
          }
        }
        return mode;
      }
    };
    module.exports = async function(zipPath, opts) {
      debug("creating target directory", opts.dir);
      if (!path.isAbsolute(opts.dir)) {
        throw new Error("Target directory is expected to be absolute");
      }
      await fs2.mkdir(opts.dir, { recursive: true });
      opts.dir = await fs2.realpath(opts.dir);
      return new Extractor(zipPath, opts).extract();
    };
  }
});

// node_modules/playwright-core/lib/utils/browserFetcher.js
var require_browserFetcher = __commonJS({
  "node_modules/playwright-core/lib/utils/browserFetcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.downloadBrowserWithProgressBar = downloadBrowserWithProgressBar;
    exports.logPolitely = logPolitely;
    var _extractZip = _interopRequireDefault(require_extract_zip());
    var _fs = _interopRequireDefault(__require("fs"));
    var _os = _interopRequireDefault(__require("os"));
    var _path = _interopRequireDefault(__require("path"));
    var _utils = require_utils();
    var _debugLogger = require_debugLogger();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function downloadBrowserWithProgressBar(title, browserDirectory, executablePath, downloadURL, downloadFileName) {
      const progressBarName = `Playwright build of ${title}`;
      if (await (0, _utils.existsAsync)(browserDirectory)) {
        _debugLogger.debugLogger.log("install", `browser ${title} is already downloaded.`);
        return false;
      }
      const url = downloadURL;
      const zipPath = _path.default.join(_os.default.tmpdir(), downloadFileName);
      try {
        await (0, _utils.download)(url, zipPath, {
          progressBarName,
          log: _debugLogger.debugLogger.log.bind(_debugLogger.debugLogger, "install")
        });
        _debugLogger.debugLogger.log("install", `extracting archive`);
        _debugLogger.debugLogger.log("install", `-- zip: ${zipPath}`);
        _debugLogger.debugLogger.log("install", `-- location: ${browserDirectory}`);
        await (0, _extractZip.default)(zipPath, {
          dir: browserDirectory
        });
        _debugLogger.debugLogger.log("install", `fixing permissions at ${executablePath}`);
        await _fs.default.promises.chmod(executablePath, 493);
      } catch (e) {
        _debugLogger.debugLogger.log("install", `FAILED installation ${progressBarName} with error: ${e}`);
        process.exitCode = 1;
        throw e;
      } finally {
        if (await (0, _utils.existsAsync)(zipPath))
          await _fs.default.promises.unlink(zipPath);
      }
      logPolitely(`${progressBarName} downloaded to ${browserDirectory}`);
      return true;
    }
    function logPolitely(toBeLogged) {
      const logLevel = process.env.npm_config_loglevel;
      const logLevelDisplay = ["silent", "error", "warn"].indexOf(logLevel || "") > -1;
      if (!logLevelDisplay)
        console.log(toBeLogged);
    }
  }
});

// node_modules/playwright-core/browsers.json
var require_browsers = __commonJS({
  "node_modules/playwright-core/browsers.json"(exports, module) {
    module.exports = {
      comment: "Do not edit this file, use utils/roll_browser.js",
      browsers: [
        {
          name: "chromium",
          revision: "939194",
          installByDefault: true
        },
        {
          name: "chromium-with-symbols",
          revision: "939194",
          installByDefault: false
        },
        {
          name: "firefox",
          revision: "1304",
          installByDefault: true
        },
        {
          name: "firefox-beta",
          revision: "1303",
          installByDefault: false
        },
        {
          name: "webkit",
          revision: "1578",
          installByDefault: true,
          revisionOverrides: {
            "mac10.14": "1446"
          }
        },
        {
          name: "ffmpeg",
          revision: "1006",
          installByDefault: true
        }
      ]
    };
  }
});

// node_modules/playwright-core/lib/utils/registry.js
var require_registry = __commonJS({
  "node_modules/playwright-core/lib/utils/registry.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildPlaywrightCLICommand = buildPlaywrightCLICommand;
    exports.installDefaultBrowsersForNpmInstall = installDefaultBrowsersForNpmInstall;
    exports.installBrowsersForNpmInstall = installBrowsersForNpmInstall;
    exports.findChromiumChannel = findChromiumChannel;
    exports.registry = exports.Registry = exports.registryDirectory = void 0;
    var os = _interopRequireWildcard(__require("os"));
    var _path = _interopRequireDefault(__require("path"));
    var util = _interopRequireWildcard(__require("util"));
    var fs2 = _interopRequireWildcard(__require("fs"));
    var _properLockfile = _interopRequireDefault(require_proper_lockfile());
    var _ubuntuVersion = require_ubuntuVersion();
    var _utils = require_utils();
    var _dependencies = require_dependencies();
    var _browserFetcher = require_browserFetcher();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var PACKAGE_PATH = _path.default.join(__dirname, "..", "..");
    var BIN_PATH = _path.default.join(__dirname, "..", "..", "bin");
    var EXECUTABLE_PATHS = {
      "chromium": {
        "ubuntu18.04": ["chrome-linux", "chrome"],
        "ubuntu20.04": ["chrome-linux", "chrome"],
        "ubuntu18.04-arm64": ["chrome-linux", "chrome"],
        "ubuntu20.04-arm64": ["chrome-linux", "chrome"],
        "mac10.13": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "mac10.14": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "mac10.15": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "mac11": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "mac11-arm64": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "win64": ["chrome-win", "chrome.exe"]
      },
      "firefox": {
        "ubuntu18.04": ["firefox", "firefox"],
        "ubuntu20.04": ["firefox", "firefox"],
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": ["firefox", "firefox"],
        "mac10.13": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac10.14": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac10.15": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac11": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac11-arm64": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "win64": ["firefox", "firefox.exe"]
      },
      "webkit": {
        "ubuntu18.04": ["pw_run.sh"],
        "ubuntu20.04": ["pw_run.sh"],
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": ["pw_run.sh"],
        "mac10.13": void 0,
        "mac10.14": ["pw_run.sh"],
        "mac10.15": ["pw_run.sh"],
        "mac11": ["pw_run.sh"],
        "mac11-arm64": ["pw_run.sh"],
        "win64": ["Playwright.exe"]
      },
      "ffmpeg": {
        "ubuntu18.04": ["ffmpeg-linux"],
        "ubuntu20.04": ["ffmpeg-linux"],
        "ubuntu18.04-arm64": ["ffmpeg-linux-arm64"],
        "ubuntu20.04-arm64": ["ffmpeg-linux-arm64"],
        "mac10.13": ["ffmpeg-mac"],
        "mac10.14": ["ffmpeg-mac"],
        "mac10.15": ["ffmpeg-mac"],
        "mac11": ["ffmpeg-mac"],
        "mac11-arm64": ["ffmpeg-mac"],
        "win64": ["ffmpeg-win64.exe"]
      }
    };
    var DOWNLOAD_URLS = {
      "chromium": {
        "ubuntu18.04": "%s/builds/chromium/%s/chromium-linux.zip",
        "ubuntu20.04": "%s/builds/chromium/%s/chromium-linux.zip",
        "ubuntu18.04-arm64": "%s/builds/chromium/%s/chromium-linux-arm64.zip",
        "ubuntu20.04-arm64": "%s/builds/chromium/%s/chromium-linux-arm64.zip",
        "mac10.13": "%s/builds/chromium/%s/chromium-mac.zip",
        "mac10.14": "%s/builds/chromium/%s/chromium-mac.zip",
        "mac10.15": "%s/builds/chromium/%s/chromium-mac.zip",
        "mac11": "%s/builds/chromium/%s/chromium-mac.zip",
        "mac11-arm64": "%s/builds/chromium/%s/chromium-mac-arm64.zip",
        "win64": "%s/builds/chromium/%s/chromium-win64.zip"
      },
      "chromium-with-symbols": {
        "ubuntu18.04": "%s/builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu20.04": "%s/builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu18.04-arm64": "%s/builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "ubuntu20.04-arm64": "%s/builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "mac10.13": "%s/builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac10.14": "%s/builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac10.15": "%s/builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac11": "%s/builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac11-arm64": "%s/builds/chromium/%s/chromium-with-symbols-mac-arm64.zip",
        "win64": "%s/builds/chromium/%s/chromium-with-symbols-win64.zip"
      },
      "firefox": {
        "ubuntu18.04": "%s/builds/firefox/%s/firefox-ubuntu-18.04.zip",
        "ubuntu20.04": "%s/builds/firefox/%s/firefox-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": "%s/builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip",
        "mac10.13": "%s/builds/firefox/%s/firefox-mac-11.zip",
        "mac10.14": "%s/builds/firefox/%s/firefox-mac-11.zip",
        "mac10.15": "%s/builds/firefox/%s/firefox-mac-11.zip",
        "mac11": "%s/builds/firefox/%s/firefox-mac-11.zip",
        "mac11-arm64": "%s/builds/firefox/%s/firefox-mac-11-arm64.zip",
        "win64": "%s/builds/firefox/%s/firefox-win64.zip"
      },
      "firefox-beta": {
        "ubuntu18.04": "%s/builds/firefox-beta/%s/firefox-beta-ubuntu-18.04.zip",
        "ubuntu20.04": "%s/builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": void 0,
        "mac10.13": "%s/builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac10.14": "%s/builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac10.15": "%s/builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac11": "%s/builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac11-arm64": "%s/builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip",
        "win64": "%s/builds/firefox-beta/%s/firefox-beta-win64.zip"
      },
      "webkit": {
        "ubuntu18.04": "%s/builds/webkit/%s/webkit-ubuntu-18.04.zip",
        "ubuntu20.04": "%s/builds/webkit/%s/webkit-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": "%s/builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip",
        "mac10.13": void 0,
        "mac10.14": "%s/builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip",
        "mac10.15": "%s/builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11": "%s/builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11-arm64": "%s/builds/webkit/%s/webkit-mac-11-arm64.zip",
        "win64": "%s/builds/webkit/%s/webkit-win64.zip"
      },
      "ffmpeg": {
        "ubuntu18.04": "%s/builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu20.04": "%s/builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu18.04-arm64": "%s/builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "ubuntu20.04-arm64": "%s/builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "mac10.13": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.14": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.15": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11-arm64": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "win64": "%s/builds/ffmpeg/%s/ffmpeg-win64.zip"
      }
    };
    var registryDirectory = (() => {
      let result;
      const envDefined = (0, _utils.getFromENV)("PLAYWRIGHT_BROWSERS_PATH");
      if (envDefined === "0") {
        result = _path.default.join(__dirname, "..", "..", ".local-browsers");
      } else if (envDefined) {
        result = envDefined;
      } else {
        let cacheDirectory;
        if (process.platform === "linux")
          cacheDirectory = process.env.XDG_CACHE_HOME || _path.default.join(os.homedir(), ".cache");
        else if (process.platform === "darwin")
          cacheDirectory = _path.default.join(os.homedir(), "Library", "Caches");
        else if (process.platform === "win32")
          cacheDirectory = process.env.LOCALAPPDATA || _path.default.join(os.homedir(), "AppData", "Local");
        else
          throw new Error("Unsupported platform: " + process.platform);
        result = _path.default.join(cacheDirectory, "ms-playwright");
      }
      if (!_path.default.isAbsolute(result)) {
        result = _path.default.resolve((0, _utils.getFromENV)("INIT_CWD") || process.cwd(), result);
      }
      return result;
    })();
    exports.registryDirectory = registryDirectory;
    function isBrowserDirectory(browserDirectory) {
      const baseName = _path.default.basename(browserDirectory);
      for (const browserName of allDownloadable) {
        if (baseName.startsWith(browserName + "-"))
          return true;
      }
      return false;
    }
    function readDescriptors(browsersJSON) {
      return browsersJSON["browsers"].map((obj) => {
        const name = obj.name;
        const revisionOverride = (obj.revisionOverrides || {})[_utils.hostPlatform];
        const revision = revisionOverride || obj.revision;
        const browserDirectoryPrefix = revisionOverride ? `${name}_${_utils.hostPlatform}_special` : `${name}`;
        const descriptor = {
          name,
          revision,
          installByDefault: !!obj.installByDefault,
          dir: _path.default.join(registryDirectory, browserDirectoryPrefix.replace(/-/g, "_") + "-" + revision)
        };
        return descriptor;
      });
    }
    var allDownloadable = ["chromium", "firefox", "webkit", "ffmpeg", "firefox-beta", "chromium-with-symbols"];
    var Registry = class {
      constructor(browsersJSON) {
        this._executables = void 0;
        const descriptors = readDescriptors(browsersJSON);
        const findExecutablePath = (dir, name) => {
          const tokens = EXECUTABLE_PATHS[name][_utils.hostPlatform];
          return tokens ? _path.default.join(dir, ...tokens) : void 0;
        };
        const executablePathOrDie = (name, e, installByDefault, sdkLanguage) => {
          if (!e)
            throw new Error(`${name} is not supported on ${_utils.hostPlatform}`);
          const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install${installByDefault ? "" : " " + name}`);
          if (!(0, _utils.canAccessFile)(e)) {
            const prettyMessage = [`Looks like Playwright Test or Playwright was just installed or updated.`, `Please run the following command to download new browser${installByDefault ? "s" : ""}:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join("\n");
            throw new Error(`Executable doesn't exist at ${e}
${(0, _utils.wrapInASCIIBox)(prettyMessage, 1)}`);
          }
          return e;
        };
        this._executables = [];
        const chromium2 = descriptors.find((d) => d.name === "chromium");
        const chromiumExecutable = findExecutablePath(chromium2.dir, "chromium");
        this._executables.push({
          type: "browser",
          name: "chromium",
          browserName: "chromium",
          directory: chromium2.dir,
          executablePath: () => chromiumExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium", chromiumExecutable, chromium2.installByDefault, sdkLanguage),
          installType: chromium2.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromium2.dir, ["chrome-linux"], [], ["chrome-win"]),
          _install: () => this._downloadExecutable(chromium2, chromiumExecutable, DOWNLOAD_URLS["chromium"][_utils.hostPlatform], "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST"),
          _dependencyGroup: "chromium"
        });
        const chromiumWithSymbols = descriptors.find((d) => d.name === "chromium-with-symbols");
        const chromiumWithSymbolsExecutable = findExecutablePath(chromiumWithSymbols.dir, "chromium");
        this._executables.push({
          type: "tool",
          name: "chromium-with-symbols",
          browserName: "chromium",
          directory: chromiumWithSymbols.dir,
          executablePath: () => chromiumWithSymbolsExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium-with-symbols", chromiumWithSymbolsExecutable, chromiumWithSymbols.installByDefault, sdkLanguage),
          installType: chromiumWithSymbols.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromiumWithSymbols.dir, ["chrome-linux"], [], ["chrome-win"]),
          _install: () => this._downloadExecutable(chromiumWithSymbols, chromiumWithSymbolsExecutable, DOWNLOAD_URLS["chromium-with-symbols"][_utils.hostPlatform], "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST"),
          _dependencyGroup: "chromium"
        });
        this._executables.push(this._createChromiumChannel("chrome", {
          "linux": "/opt/google/chrome/chrome",
          "darwin": "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
          "win32": `\\Google\\Chrome\\Application\\chrome.exe`
        }, () => this._installChromiumChannel("chrome", {
          "linux": "reinstall_chrome_stable_linux.sh",
          "darwin": "reinstall_chrome_stable_mac.sh",
          "win32": "reinstall_chrome_stable_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("chrome-beta", {
          "linux": "/opt/google/chrome-beta/chrome",
          "darwin": "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
          "win32": `\\Google\\Chrome Beta\\Application\\chrome.exe`
        }, () => this._installChromiumChannel("chrome-beta", {
          "linux": "reinstall_chrome_beta_linux.sh",
          "darwin": "reinstall_chrome_beta_mac.sh",
          "win32": "reinstall_chrome_beta_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("chrome-dev", {
          "linux": "/opt/google/chrome-unstable/chrome",
          "darwin": "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev",
          "win32": `\\Google\\Chrome Dev\\Application\\chrome.exe`
        }));
        this._executables.push(this._createChromiumChannel("chrome-canary", {
          "linux": "",
          "darwin": "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
          "win32": `\\Google\\Chrome SxS\\Application\\chrome.exe`
        }));
        this._executables.push(this._createChromiumChannel("msedge", {
          "linux": "/opt/microsoft/msedge/msedge",
          "darwin": "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
          "win32": `\\Microsoft\\Edge\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge", {
          "linux": "reinstall_msedge_stable_linux.sh",
          "darwin": "reinstall_msedge_stable_mac.sh",
          "win32": "reinstall_msedge_stable_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-beta", {
          "linux": "/opt/microsoft/msedge-beta/msedge",
          "darwin": "/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta",
          "win32": `\\Microsoft\\Edge Beta\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge-beta", {
          "darwin": "reinstall_msedge_beta_mac.sh",
          "linux": "reinstall_msedge_beta_linux.sh",
          "win32": "reinstall_msedge_beta_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-dev", {
          "linux": "/opt/microsoft/msedge-dev/msedge",
          "darwin": "/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev",
          "win32": `\\Microsoft\\Edge Dev\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge-dev", {
          "darwin": "reinstall_msedge_dev_mac.sh",
          "linux": "reinstall_msedge_dev_linux.sh",
          "win32": "reinstall_msedge_dev_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-canary", {
          "linux": "",
          "darwin": "/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary",
          "win32": `\\Microsoft\\Edge SxS\\Application\\msedge.exe`
        }));
        const firefox2 = descriptors.find((d) => d.name === "firefox");
        const firefoxExecutable = findExecutablePath(firefox2.dir, "firefox");
        this._executables.push({
          type: "browser",
          name: "firefox",
          browserName: "firefox",
          directory: firefox2.dir,
          executablePath: () => firefoxExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("firefox", firefoxExecutable, firefox2.installByDefault, sdkLanguage),
          installType: firefox2.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "firefox", firefox2.dir, ["firefox"], [], ["firefox"]),
          _install: () => this._downloadExecutable(firefox2, firefoxExecutable, DOWNLOAD_URLS["firefox"][_utils.hostPlatform], "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST"),
          _dependencyGroup: "firefox"
        });
        const firefoxBeta = descriptors.find((d) => d.name === "firefox-beta");
        const firefoxBetaExecutable = findExecutablePath(firefoxBeta.dir, "firefox");
        this._executables.push({
          type: "tool",
          name: "firefox-beta",
          browserName: "firefox",
          directory: firefoxBeta.dir,
          executablePath: () => firefoxBetaExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("firefox-beta", firefoxBetaExecutable, firefoxBeta.installByDefault, sdkLanguage),
          installType: firefoxBeta.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "firefox", firefoxBeta.dir, ["firefox"], [], ["firefox"]),
          _install: () => this._downloadExecutable(firefoxBeta, firefoxBetaExecutable, DOWNLOAD_URLS["firefox-beta"][_utils.hostPlatform], "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST"),
          _dependencyGroup: "firefox"
        });
        const webkit2 = descriptors.find((d) => d.name === "webkit");
        const webkitExecutable = findExecutablePath(webkit2.dir, "webkit");
        const webkitLinuxLddDirectories = [_path.default.join("minibrowser-gtk"), _path.default.join("minibrowser-gtk", "bin"), _path.default.join("minibrowser-gtk", "lib"), _path.default.join("minibrowser-wpe"), _path.default.join("minibrowser-wpe", "bin"), _path.default.join("minibrowser-wpe", "lib")];
        this._executables.push({
          type: "browser",
          name: "webkit",
          browserName: "webkit",
          directory: webkit2.dir,
          executablePath: () => webkitExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("webkit", webkitExecutable, webkit2.installByDefault, sdkLanguage),
          installType: webkit2.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "webkit", webkit2.dir, webkitLinuxLddDirectories, ["libGLESv2.so.2", "libx264.so"], [""]),
          _install: () => this._downloadExecutable(webkit2, webkitExecutable, DOWNLOAD_URLS["webkit"][_utils.hostPlatform], "PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST"),
          _dependencyGroup: "webkit"
        });
        const ffmpeg = descriptors.find((d) => d.name === "ffmpeg");
        const ffmpegExecutable = findExecutablePath(ffmpeg.dir, "ffmpeg");
        this._executables.push({
          type: "tool",
          name: "ffmpeg",
          browserName: void 0,
          directory: ffmpeg.dir,
          executablePath: () => ffmpegExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("ffmpeg", ffmpegExecutable, ffmpeg.installByDefault, sdkLanguage),
          installType: ffmpeg.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: () => Promise.resolve(),
          _install: () => this._downloadExecutable(ffmpeg, ffmpegExecutable, DOWNLOAD_URLS["ffmpeg"][_utils.hostPlatform], "PLAYWRIGHT_FFMPEG_DOWNLOAD_HOST"),
          _dependencyGroup: "tools"
        });
      }
      _createChromiumChannel(name, lookAt, install) {
        const executablePath = (sdkLanguage, shouldThrow) => {
          const suffix = lookAt[process.platform];
          if (!suffix) {
            if (shouldThrow)
              throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);
            return void 0;
          }
          const prefixes = process.platform === "win32" ? [process.env.LOCALAPPDATA, process.env.PROGRAMFILES, process.env["PROGRAMFILES(X86)"]].filter(Boolean) : [""];
          for (const prefix of prefixes) {
            const executablePath2 = _path.default.join(prefix, suffix);
            if ((0, _utils.canAccessFile)(executablePath2))
              return executablePath2;
          }
          if (!shouldThrow)
            return void 0;
          const location2 = prefixes.length ? ` at ${_path.default.join(prefixes[0], suffix)}` : ``;
          const installation = install ? `
Run "${buildPlaywrightCLICommand(sdkLanguage, "install " + name)}"` : "";
          throw new Error(`Chromium distribution '${name}' is not found${location2}${installation}`);
        };
        return {
          type: "channel",
          name,
          browserName: "chromium",
          directory: void 0,
          executablePath: (sdkLanguage) => executablePath(sdkLanguage, false),
          executablePathOrDie: (sdkLanguage) => executablePath(sdkLanguage, true),
          installType: install ? "install-script" : "none",
          validateHostRequirements: () => Promise.resolve(),
          _install: install
        };
      }
      executables() {
        return this._executables;
      }
      findExecutable(name) {
        return this._executables.find((b) => b.name === name);
      }
      defaultExecutables() {
        return this._executables.filter((e) => e.installType === "download-by-default");
      }
      _addRequirementsAndDedupe(executables) {
        const set = new Set();
        for (const executable of executables) {
          set.add(executable);
          if (executable.browserName === "chromium")
            set.add(this.findExecutable("ffmpeg"));
        }
        return Array.from(set);
      }
      async _validateHostRequirements(sdkLanguage, browserName, browserDirectory, linuxLddDirectories, dlOpenLibraries, windowsExeAndDllDirectories) {
        if ((0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS")) {
          process.stdout.write("Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n");
          return;
        }
        const ubuntuVersion = await (0, _ubuntuVersion.getUbuntuVersion)();
        if (browserName === "firefox" && ubuntuVersion === "16.04")
          throw new Error(`Cannot launch Firefox on Ubuntu 16.04! Minimum required Ubuntu version for Firefox browser is 18.04`);
        if (os.platform() === "linux")
          return await (0, _dependencies.validateDependenciesLinux)(sdkLanguage, linuxLddDirectories.map((d) => _path.default.join(browserDirectory, d)), dlOpenLibraries);
        if (os.platform() === "win32" && os.arch() === "x64")
          return await (0, _dependencies.validateDependenciesWindows)(windowsExeAndDllDirectories.map((d) => _path.default.join(browserDirectory, d)));
      }
      async installDeps(executablesToInstallDeps) {
        const executables = this._addRequirementsAndDedupe(executablesToInstallDeps);
        const targets = new Set();
        for (const executable of executables) {
          if (executable._dependencyGroup)
            targets.add(executable._dependencyGroup);
        }
        targets.add("tools");
        if (os.platform() === "win32")
          return await (0, _dependencies.installDependenciesWindows)(targets);
        if (os.platform() === "linux")
          return await (0, _dependencies.installDependenciesLinux)(targets);
      }
      async install(executablesToInstall) {
        const executables = this._addRequirementsAndDedupe(executablesToInstall);
        await fs2.promises.mkdir(registryDirectory, {
          recursive: true
        });
        const lockfilePath = _path.default.join(registryDirectory, "__dirlock");
        const linksDir = _path.default.join(registryDirectory, ".links");
        let releaseLock;
        try {
          releaseLock = await _properLockfile.default.lock(registryDirectory, {
            retries: {
              retries: 20,
              factor: 1.27579
            },
            onCompromised: (err) => {
              throw new Error(`${err.message} Path: ${lockfilePath}`);
            },
            lockfilePath
          });
          await fs2.promises.mkdir(linksDir, {
            recursive: true
          });
          await fs2.promises.writeFile(_path.default.join(linksDir, (0, _utils.calculateSha1)(PACKAGE_PATH)), PACKAGE_PATH);
          await this._validateInstallationCache(linksDir);
          for (const executable of executables) {
            if (executable._install)
              await executable._install();
            else
              throw new Error(`ERROR: Playwright does not support installing ${executable.name}`);
          }
        } catch (e) {
          if (e.code === "ELOCKED") {
            const rmCommand = process.platform === "win32" ? "rm -R" : "rm -rf";
            throw new Error("\n" + (0, _utils.wrapInASCIIBox)([`An active lockfile is found at:`, ``, `  ${lockfilePath}`, ``, `Either:`, `- wait a few minutes if other Playwright is installing browsers in parallel`, `- remove lock manually with:`, ``, `    ${rmCommand} ${lockfilePath}`, ``, `<3 Playwright Team`].join("\n"), 1));
          } else {
            throw e;
          }
        } finally {
          if (releaseLock)
            await releaseLock();
        }
      }
      async _downloadExecutable(descriptor, executablePath, downloadURLTemplate, downloadHostEnv) {
        if (!downloadURLTemplate || !executablePath)
          throw new Error(`ERROR: Playwright does not support ${descriptor.name} on ${_utils.hostPlatform}`);
        const downloadHost = downloadHostEnv && (0, _utils.getFromENV)(downloadHostEnv) || (0, _utils.getFromENV)("PLAYWRIGHT_DOWNLOAD_HOST") || "https://playwright.azureedge.net";
        const downloadURL = util.format(downloadURLTemplate, downloadHost, descriptor.revision);
        const title = `${descriptor.name} v${descriptor.revision}`;
        const downloadFileName = `playwright-download-${descriptor.name}-${_utils.hostPlatform}-${descriptor.revision}.zip`;
        await (0, _browserFetcher.downloadBrowserWithProgressBar)(title, descriptor.dir, executablePath, downloadURL, downloadFileName).catch((e) => {
          throw new Error(`Failed to download ${title}, caused by
${e.stack}`);
        });
        await fs2.promises.writeFile(markerFilePath(descriptor.dir), "");
      }
      async _installMSEdgeChannel(channel, scripts) {
        const scriptArgs = [];
        if (process.platform !== "linux") {
          const products = JSON.parse(await (0, _utils.fetchData)({
            url: "https://edgeupdates.microsoft.com/api/products"
          }));
          const productName = {
            "msedge": "Stable",
            "msedge-beta": "Beta",
            "msedge-dev": "Dev"
          }[channel];
          const product = products.find((product2) => product2.Product === productName);
          const searchConfig = {
            darwin: {
              platform: "MacOS",
              arch: "universal",
              artifact: "pkg"
            },
            win32: {
              platform: "Windows",
              arch: "x64",
              artifact: "msi"
            }
          }[process.platform];
          const release = searchConfig ? product.Releases.find((release2) => release2.Platform === searchConfig.platform && release2.Architecture === searchConfig.arch) : null;
          const artifact = release ? release.Artifacts.find((artifact2) => artifact2.ArtifactName === searchConfig.artifact) : null;
          if (artifact)
            scriptArgs.push(artifact.Location);
          else
            throw new Error(`Cannot install ${channel} on ${process.platform}`);
        }
        await this._installChromiumChannel(channel, scripts, scriptArgs);
      }
      async _installChromiumChannel(channel, scripts, scriptArgs = []) {
        const scriptName = scripts[process.platform];
        if (!scriptName)
          throw new Error(`Cannot install ${channel} on ${process.platform}`);
        const isPowerShell = scriptName.endsWith(".ps1");
        const shell = isPowerShell ? "powershell.exe" : "bash";
        const args = [...isPowerShell ? ["-ExecutionPolicy", "Bypass", "-File"] : [], _path.default.join(BIN_PATH, scriptName), ...scriptArgs];
        const {
          code
        } = await (0, _utils.spawnAsync)(shell, args, {
          cwd: BIN_PATH,
          stdio: "inherit"
        });
        if (code !== 0)
          throw new Error(`Failed to install ${channel}`);
      }
      async _validateInstallationCache(linksDir) {
        const usedBrowserPaths = new Set();
        for (const fileName of await fs2.promises.readdir(linksDir)) {
          const linkPath = _path.default.join(linksDir, fileName);
          let linkTarget = "";
          try {
            linkTarget = (await fs2.promises.readFile(linkPath)).toString();
            const browsersJSON = __require(_path.default.join(linkTarget, "browsers.json"));
            const descriptors = readDescriptors(browsersJSON);
            for (const browserName of allDownloadable) {
              const descriptor = descriptors.find((d) => d.name === browserName);
              if (!descriptor)
                continue;
              const usedBrowserPath = descriptor.dir;
              const browserRevision = parseInt(descriptor.revision, 10);
              const shouldHaveMarkerFile = browserName === "chromium" && browserRevision >= 786218 || browserName === "firefox" && browserRevision >= 1128 || browserName === "webkit" && browserRevision >= 1307 || browserName !== "firefox" && browserName !== "chromium" && browserName !== "webkit";
              if (!shouldHaveMarkerFile || await (0, _utils.existsAsync)(markerFilePath(usedBrowserPath)))
                usedBrowserPaths.add(usedBrowserPath);
            }
          } catch (e) {
            await fs2.promises.unlink(linkPath).catch((e2) => {
            });
          }
        }
        if (!(0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_BROWSER_GC")) {
          let downloadedBrowsers = (await fs2.promises.readdir(registryDirectory)).map((file) => _path.default.join(registryDirectory, file));
          downloadedBrowsers = downloadedBrowsers.filter((file) => isBrowserDirectory(file));
          const directories = new Set(downloadedBrowsers);
          for (const browserDirectory of usedBrowserPaths)
            directories.delete(browserDirectory);
          for (const directory of directories)
            (0, _browserFetcher.logPolitely)("Removing unused browser at " + directory);
          await (0, _utils.removeFolders)([...directories]);
        }
      }
    };
    exports.Registry = Registry;
    function markerFilePath(browserDirectory) {
      return _path.default.join(browserDirectory, "INSTALLATION_COMPLETE");
    }
    function buildPlaywrightCLICommand(sdkLanguage, parameters) {
      switch (sdkLanguage) {
        case "python":
          return `playwright ${parameters}`;
        case "java":
          return `mvn exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="${parameters}"`;
        case "csharp":
          return `playwright ${parameters}`;
        default:
          return `npx playwright ${parameters}`;
      }
    }
    async function installDefaultBrowsersForNpmInstall() {
      const defaultBrowserNames = registry.defaultExecutables().map((e) => e.name);
      return installBrowsersForNpmInstall(defaultBrowserNames);
    }
    async function installBrowsersForNpmInstall(browsers) {
      if ((0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD")) {
        (0, _browserFetcher.logPolitely)("Skipping browsers download because `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` env variable is set");
        return false;
      }
      const executables = [];
      for (const browserName of browsers) {
        const executable = registry.findExecutable(browserName);
        if (!executable || executable.installType === "none")
          throw new Error(`Cannot install ${browserName}`);
        executables.push(executable);
      }
      await registry.install(executables);
    }
    function findChromiumChannel(sdkLanguage) {
      let channel = null;
      for (const name of ["chromium", "chrome", "msedge"]) {
        try {
          registry.findExecutable(name).executablePathOrDie(sdkLanguage);
          channel = name === "chromium" ? void 0 : name;
          break;
        } catch (e) {
        }
      }
      if (channel === null) {
        const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install chromium`);
        const prettyMessage = [`No chromium-based browser found on the system.`, `Please run the following command to download one:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join("\n");
        throw new Error("\n" + (0, _utils.wrapInASCIIBox)(prettyMessage, 1));
      }
      return channel;
    }
    var registry = new Registry(require_browsers());
    exports.registry = registry;
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/recorderApp.js
var require_recorderApp = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/recorderApp.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RecorderApp = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var _path = _interopRequireDefault(__require("path"));
    var _progress = require_progress2();
    var _events = __require("events");
    var _instrumentation = require_instrumentation();
    var _utils = require_utils();
    var mime = _interopRequireWildcard(require_mime());
    var _crApp = require_crApp();
    var _registry = require_registry();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var RecorderApp = class extends _events.EventEmitter {
      constructor(page, wsEndpoint) {
        super();
        this._page = void 0;
        this.wsEndpoint = void 0;
        this.setMaxListeners(0);
        this._page = page;
        this.wsEndpoint = wsEndpoint;
      }
      async close() {
        await this._page.context().close((0, _instrumentation.internalCallMetadata)());
      }
      async _init() {
        await (0, _crApp.installAppIcon)(this._page);
        await this._page._setServerRequestInterceptor(async (route) => {
          if (route.request().url().startsWith("https://playwright/")) {
            const uri = route.request().url().substring("https://playwright/".length);
            const file = __require.resolve("../../../webpack/recorder/" + uri);
            const buffer = await _fs.default.promises.readFile(file);
            await route.fulfill({
              status: 200,
              headers: [{
                name: "Content-Type",
                value: mime.getType(_path.default.extname(file)) || "application/octet-stream"
              }],
              body: buffer.toString("base64"),
              isBase64: true
            });
            return;
          }
          await route.continue();
        });
        await this._page.exposeBinding("dispatch", false, (_, data) => this.emit("event", data));
        this._page.once("close", () => {
          this.emit("close");
          this._page.context().close((0, _instrumentation.internalCallMetadata)()).catch((e) => console.error(e));
        });
        const mainFrame = this._page.mainFrame();
        await mainFrame.goto((0, _instrumentation.internalCallMetadata)(), "https://playwright/index.html");
      }
      static async open(sdkLanguage) {
        const recorderPlaywright = require_playwright().createPlaywright("javascript", true);
        const args = ["--app=data:text/html,", "--window-size=600,600", "--window-position=1280,10"];
        if (process.env.PWTEST_RECORDER_PORT)
          args.push(`--remote-debugging-port=${process.env.PWTEST_RECORDER_PORT}`);
        const context = await recorderPlaywright.chromium.launchPersistentContext((0, _instrumentation.internalCallMetadata)(), "", {
          channel: (0, _registry.findChromiumChannel)(sdkLanguage),
          args,
          noDefaultViewport: true,
          headless: !!process.env.PWTEST_CLI_HEADLESS || (0, _utils.isUnderTest)() && !process.env.HEADFUL,
          useWebSocket: !!process.env.PWTEST_RECORDER_PORT
        });
        const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), context._browser);
        await controller.run(async (progress) => {
          await context._browser._defaultContext._loadDefaultContextAsIs(progress);
        });
        const [page] = context.pages();
        const result = new RecorderApp(page, context._browser.options.wsEndpoint);
        await result._init();
        return result;
      }
      async setMode(mode) {
        await this._page.mainFrame().evaluateExpression(((mode2) => {
          window.playwrightSetMode(mode2);
        }).toString(), true, mode, "main").catch(() => {
        });
      }
      async setFile(file) {
        await this._page.mainFrame().evaluateExpression(((file2) => {
          window.playwrightSetFile(file2);
        }).toString(), true, file, "main").catch(() => {
        });
      }
      async setPaused(paused) {
        await this._page.mainFrame().evaluateExpression(((paused2) => {
          window.playwrightSetPaused(paused2);
        }).toString(), true, paused, "main").catch(() => {
        });
      }
      async setSources(sources) {
        await this._page.mainFrame().evaluateExpression(((sources2) => {
          window.playwrightSetSources(sources2);
        }).toString(), true, sources, "main").catch(() => {
        });
        {
          if (process.env.PWTEST_CLI_EXIT && sources.length) {
            process.stdout.write("\n-------------8<-------------\n");
            process.stdout.write(sources[0].text);
            process.stdout.write("\n-------------8<-------------\n");
          }
        }
      }
      async setSelector(selector, focus) {
        await this._page.mainFrame().evaluateExpression(((arg) => {
          window.playwrightSetSelector(arg.selector, arg.focus);
        }).toString(), true, {
          selector,
          focus
        }, "main").catch(() => {
        });
      }
      async updateCallLogs(callLogs) {
        await this._page.mainFrame().evaluateExpression(((callLogs2) => {
          window.playwrightUpdateLogs(callLogs2);
        }).toString(), true, callLogs, "main").catch(() => {
        });
      }
      async bringToFront() {
        await this._page.bringToFront();
      }
    };
    exports.RecorderApp = RecorderApp;
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/recorderUtils.js
var require_recorderUtils = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/recorderUtils.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.metadataToCallLog = metadataToCallLog;
    function metadataToCallLog(metadata, status) {
      var _metadata$params, _metadata$params2;
      let title = metadata.apiName || metadata.method;
      if (metadata.method === "waitForEventInfo")
        title += `(${metadata.params.info.event})`;
      title = title.replace("object.expect", "expect");
      if (metadata.error)
        status = "error";
      const params = {
        url: (_metadata$params = metadata.params) === null || _metadata$params === void 0 ? void 0 : _metadata$params.url,
        selector: (_metadata$params2 = metadata.params) === null || _metadata$params2 === void 0 ? void 0 : _metadata$params2.selector
      };
      let duration = metadata.endTime ? metadata.endTime - metadata.startTime : void 0;
      if (typeof duration === "number" && metadata.pauseStartTime && metadata.pauseEndTime) {
        duration -= metadata.pauseEndTime - metadata.pauseStartTime;
        duration = Math.max(duration, 0);
      }
      const callLog = {
        id: metadata.id,
        messages: metadata.log,
        title,
        status,
        error: metadata.error,
        params,
        duration
      };
      return callLog;
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorderSupplement.js
var require_recorderSupplement = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorderSupplement.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RecorderSupplement = void 0;
    var fs2 = _interopRequireWildcard(__require("fs"));
    var _codeGenerator = require_codeGenerator();
    var _utils = require_utils3();
    var _page = require_page();
    var _frames = require_frames();
    var _browserContext = require_browserContext();
    var _java = require_java();
    var _javascript = require_javascript2();
    var _csharp = require_csharp();
    var _python = require_python();
    var recorderSource = _interopRequireWildcard(require_recorderSource());
    var consoleApiSource = _interopRequireWildcard(require_consoleApiSource());
    var _recorderApp = require_recorderApp();
    var _utils2 = require_utils();
    var _recorderUtils = require_recorderUtils();
    var _debugger = require_debugger();
    var _events = __require("events");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var symbol = Symbol("RecorderSupplement");
    var RecorderSupplement = class {
      static showInspector(context) {
        RecorderSupplement.show(context, {}).catch(() => {
        });
      }
      static show(context, params = {}) {
        let recorderPromise = context[symbol];
        if (!recorderPromise) {
          const recorder = new RecorderSupplement(context, params);
          recorderPromise = recorder.install().then(() => recorder);
          context[symbol] = recorderPromise;
        }
        return recorderPromise;
      }
      constructor(context, params) {
        this._context = void 0;
        this._mode = void 0;
        this._highlightedSelector = "";
        this._recorderApp = null;
        this._currentCallsMetadata = new Map();
        this._recorderSources = [];
        this._userSources = new Map();
        this._allMetadatas = new Map();
        this._debugger = void 0;
        this._contextRecorder = void 0;
        this._mode = params.startRecording ? "recording" : "none";
        this._contextRecorder = new ContextRecorder(context, params);
        this._context = context;
        this._debugger = _debugger.Debugger.lookup(context);
        context.instrumentation.addListener(this);
      }
      async install() {
        const recorderApp = await _recorderApp.RecorderApp.open(this._context._browser.options.sdkLanguage);
        this._recorderApp = recorderApp;
        recorderApp.once("close", () => {
          this._debugger.resume(false);
          this._recorderApp = null;
        });
        recorderApp.on("event", (data) => {
          if (data.event === "setMode") {
            this._setMode(data.params.mode);
            this._refreshOverlay();
            return;
          }
          if (data.event === "selectorUpdated") {
            this._highlightedSelector = data.params.selector;
            this._refreshOverlay();
            return;
          }
          if (data.event === "step") {
            this._debugger.resume(true);
            return;
          }
          if (data.event === "resume") {
            this._debugger.resume(false);
            return;
          }
          if (data.event === "pause") {
            this._debugger.pauseOnNextStatement();
            return;
          }
          if (data.event === "clear") {
            this._contextRecorder.clearScript();
            return;
          }
        });
        await Promise.all([recorderApp.setMode(this._mode), recorderApp.setPaused(this._debugger.isPaused()), this._pushAllSources()]);
        this._context.once(_browserContext.BrowserContext.Events.Close, () => {
          this._contextRecorder.dispose();
          recorderApp.close().catch(() => {
          });
        });
        this._contextRecorder.on(ContextRecorder.Events.Change, (data) => {
          var _this$_recorderApp;
          this._recorderSources = data.sources;
          this._pushAllSources();
          (_this$_recorderApp = this._recorderApp) === null || _this$_recorderApp === void 0 ? void 0 : _this$_recorderApp.setFile(data.primaryFileName);
        });
        await this._context.exposeBinding("_playwrightRecorderState", false, (source) => {
          let actionSelector = this._highlightedSelector;
          let actionPoint;
          for (const [metadata, sdkObject] of this._currentCallsMetadata) {
            if (source.page === sdkObject.attribution.page) {
              actionPoint = metadata.point || actionPoint;
              actionSelector = actionSelector || metadata.params.selector;
            }
          }
          const uiState = {
            mode: this._mode,
            actionPoint,
            actionSelector
          };
          return uiState;
        });
        await this._context.exposeBinding("_playwrightRecorderSetSelector", false, async (_, selector) => {
          var _this$_recorderApp2, _this$_recorderApp3;
          this._setMode("none");
          await ((_this$_recorderApp2 = this._recorderApp) === null || _this$_recorderApp2 === void 0 ? void 0 : _this$_recorderApp2.setSelector(selector, true));
          await ((_this$_recorderApp3 = this._recorderApp) === null || _this$_recorderApp3 === void 0 ? void 0 : _this$_recorderApp3.bringToFront());
        });
        await this._context.exposeBinding("_playwrightResume", false, () => {
          this._debugger.resume(false);
        });
        await this._context.extendInjectedScript(consoleApiSource.source);
        await this._contextRecorder.install();
        if (this._debugger.isPaused())
          this._pausedStateChanged();
        this._debugger.on(_debugger.Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());
        this._context.recorderAppForTest = recorderApp;
      }
      _pausedStateChanged() {
        var _this$_recorderApp4;
        for (const {
          metadata,
          sdkObject
        } of this._debugger.pausedDetails()) {
          if (!this._currentCallsMetadata.has(metadata))
            this.onBeforeCall(sdkObject, metadata);
        }
        (_this$_recorderApp4 = this._recorderApp) === null || _this$_recorderApp4 === void 0 ? void 0 : _this$_recorderApp4.setPaused(this._debugger.isPaused());
        this._updateUserSources();
        this.updateCallLog([...this._currentCallsMetadata.keys()]);
      }
      _setMode(mode) {
        var _this$_recorderApp5;
        this._mode = mode;
        (_this$_recorderApp5 = this._recorderApp) === null || _this$_recorderApp5 === void 0 ? void 0 : _this$_recorderApp5.setMode(this._mode);
        this._contextRecorder.setEnabled(this._mode === "recording");
        this._debugger.setMuted(this._mode === "recording");
        if (this._mode !== "none")
          this._context.pages()[0].bringToFront().catch(() => {
          });
      }
      _refreshOverlay() {
        for (const page of this._context.pages())
          page.mainFrame().evaluateExpression("window._playwrightRefreshOverlay()", false, void 0, "main").catch(() => {
          });
      }
      async onBeforeCall(sdkObject, metadata) {
        if (this._mode === "recording")
          return;
        this._currentCallsMetadata.set(metadata, sdkObject);
        this._allMetadatas.set(metadata.id, metadata);
        this._updateUserSources();
        this.updateCallLog([metadata]);
        if (metadata.params && metadata.params.selector) {
          var _this$_recorderApp6;
          this._highlightedSelector = metadata.params.selector;
          (_this$_recorderApp6 = this._recorderApp) === null || _this$_recorderApp6 === void 0 ? void 0 : _this$_recorderApp6.setSelector(this._highlightedSelector).catch(() => {
          });
        }
      }
      async onAfterCall(sdkObject, metadata) {
        if (this._mode === "recording")
          return;
        if (!metadata.error)
          this._currentCallsMetadata.delete(metadata);
        this._updateUserSources();
        this.updateCallLog([metadata]);
      }
      _updateUserSources() {
        var _this$_recorderApp7;
        for (const source of this._userSources.values()) {
          source.highlight = [];
          source.revealLine = void 0;
        }
        let fileToSelect = void 0;
        for (const metadata of this._currentCallsMetadata.keys()) {
          if (!metadata.stack || !metadata.stack[0])
            continue;
          const {
            file,
            line
          } = metadata.stack[0];
          let source = this._userSources.get(file);
          if (!source) {
            source = {
              file,
              text: this._readSource(file),
              highlight: [],
              language: languageForFile(file)
            };
            this._userSources.set(file, source);
          }
          if (line) {
            const paused = this._debugger.isPaused(metadata);
            source.highlight.push({
              line,
              type: metadata.error ? "error" : paused ? "paused" : "running"
            });
            source.revealLine = line;
            fileToSelect = source.file;
          }
        }
        this._pushAllSources();
        if (fileToSelect)
          (_this$_recorderApp7 = this._recorderApp) === null || _this$_recorderApp7 === void 0 ? void 0 : _this$_recorderApp7.setFile(fileToSelect);
      }
      _pushAllSources() {
        var _this$_recorderApp8;
        (_this$_recorderApp8 = this._recorderApp) === null || _this$_recorderApp8 === void 0 ? void 0 : _this$_recorderApp8.setSources([...this._recorderSources, ...this._userSources.values()]);
      }
      async onBeforeInputAction(sdkObject, metadata) {
      }
      async onCallLog(logName, message, sdkObject, metadata) {
        this.updateCallLog([metadata]);
      }
      updateCallLog(metadatas) {
        var _this$_recorderApp9;
        if (this._mode === "recording")
          return;
        const logs = [];
        for (const metadata of metadatas) {
          if (!metadata.method)
            continue;
          let status = "done";
          if (this._currentCallsMetadata.has(metadata))
            status = "in-progress";
          if (this._debugger.isPaused(metadata))
            status = "paused";
          logs.push((0, _recorderUtils.metadataToCallLog)(metadata, status));
        }
        (_this$_recorderApp9 = this._recorderApp) === null || _this$_recorderApp9 === void 0 ? void 0 : _this$_recorderApp9.updateCallLogs(logs);
      }
      _readSource(fileName) {
        try {
          return fs2.readFileSync(fileName, "utf-8");
        } catch (e) {
          return "// No source available";
        }
      }
    };
    exports.RecorderSupplement = RecorderSupplement;
    var ContextRecorder = class extends _events.EventEmitter {
      constructor(context, params) {
        super();
        this._generator = void 0;
        this._pageAliases = new Map();
        this._lastPopupOrdinal = 0;
        this._lastDialogOrdinal = 0;
        this._lastDownloadOrdinal = 0;
        this._timers = new Set();
        this._context = void 0;
        this._params = void 0;
        this._recorderSources = void 0;
        this._context = context;
        this._params = params;
        const language = params.language || context._browser.options.sdkLanguage;
        const languages = new Set([new _java.JavaLanguageGenerator(), new _javascript.JavaScriptLanguageGenerator(false), new _javascript.JavaScriptLanguageGenerator(true), new _python.PythonLanguageGenerator(false), new _python.PythonLanguageGenerator(true), new _csharp.CSharpLanguageGenerator()]);
        const primaryLanguage = [...languages].find((l) => l.id === language);
        if (!primaryLanguage)
          throw new Error(`
===============================
Unsupported language: '${language}'
===============================
`);
        languages.delete(primaryLanguage);
        const orderedLanguages = [primaryLanguage, ...languages];
        this._recorderSources = [];
        const generator = new _codeGenerator.CodeGenerator(context._browser.options.name, !!params.startRecording, params.launchOptions || {}, params.contextOptions || {}, params.device, params.saveStorage);
        let text = "";
        generator.on("change", () => {
          this._recorderSources = [];
          for (const languageGenerator of orderedLanguages) {
            const source = {
              file: languageGenerator.fileName,
              text: generator.generateText(languageGenerator),
              language: languageGenerator.highlighter,
              highlight: []
            };
            source.revealLine = source.text.split("\n").length - 1;
            this._recorderSources.push(source);
            if (languageGenerator === orderedLanguages[0])
              text = source.text;
          }
          this.emit(ContextRecorder.Events.Change, {
            sources: this._recorderSources,
            primaryFileName: primaryLanguage.fileName
          });
        });
        if (params.outputFile) {
          context.on(_browserContext.BrowserContext.Events.BeforeClose, () => {
            fs2.writeFileSync(params.outputFile, text);
            text = "";
          });
          process.on("exit", () => {
            if (text)
              fs2.writeFileSync(params.outputFile, text);
          });
        }
        this._generator = generator;
      }
      async install() {
        this._context.on(_browserContext.BrowserContext.Events.Page, (page) => this._onPage(page));
        for (const page of this._context.pages())
          this._onPage(page);
        await this._context.exposeBinding("_playwrightRecorderPerformAction", false, (source, action) => this._performAction(source.frame, action));
        await this._context.exposeBinding("_playwrightRecorderRecordAction", false, (source, action) => this._recordAction(source.frame, action));
        await this._context.extendInjectedScript(recorderSource.source, {
          isUnderTest: (0, _utils2.isUnderTest)()
        });
      }
      setEnabled(enabled) {
        this._generator.setEnabled(enabled);
      }
      dispose() {
        for (const timer of this._timers)
          clearTimeout(timer);
        this._timers.clear();
      }
      async _onPage(page) {
        const frame = page.mainFrame();
        page.on("close", () => {
          this._pageAliases.delete(page);
          this._generator.addAction(__spreadProps(__spreadValues({
            pageAlias
          }, (0, _utils.describeFrame)(page.mainFrame())), {
            committed: true,
            action: {
              name: "closePage",
              signals: []
            }
          }));
        });
        frame.on(_frames.Frame.Events.Navigation, () => this._onFrameNavigated(frame, page));
        page.on(_page.Page.Events.Download, () => this._onDownload(page));
        page.on(_page.Page.Events.Dialog, () => this._onDialog(page));
        const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : "";
        const pageAlias = "page" + suffix;
        this._pageAliases.set(page, pageAlias);
        if (page.opener()) {
          this._onPopup(page.opener(), page);
        } else {
          this._generator.addAction(__spreadProps(__spreadValues({
            pageAlias
          }, (0, _utils.describeFrame)(page.mainFrame())), {
            committed: true,
            action: {
              name: "openPage",
              url: page.mainFrame().url(),
              signals: []
            }
          }));
        }
      }
      clearScript() {
        this._generator.restart();
        if (!!this._params.startRecording) {
          for (const page of this._context.pages())
            this._onFrameNavigated(page.mainFrame(), page);
        }
      }
      async _performAction(frame, action) {
        this._generator.commitLastAction();
        const page = frame._page;
        const actionInContext = __spreadProps(__spreadValues({
          pageAlias: this._pageAliases.get(page)
        }, (0, _utils.describeFrame)(frame)), {
          action
        });
        const perform = async (action2, params, cb) => {
          const callMetadata = {
            id: `call@${(0, _utils2.createGuid)()}`,
            apiName: "frame." + action2,
            objectId: frame.guid,
            pageId: frame._page.guid,
            frameId: frame.guid,
            wallTime: Date.now(),
            startTime: (0, _utils2.monotonicTime)(),
            endTime: 0,
            type: "Frame",
            method: action2,
            params,
            log: [],
            snapshots: []
          };
          this._generator.willPerformAction(actionInContext);
          try {
            await frame.instrumentation.onBeforeCall(frame, callMetadata);
            await cb(callMetadata);
          } catch (e) {
            callMetadata.endTime = (0, _utils2.monotonicTime)();
            await frame.instrumentation.onAfterCall(frame, callMetadata);
            this._generator.performedActionFailed(actionInContext);
            return;
          }
          callMetadata.endTime = (0, _utils2.monotonicTime)();
          await frame.instrumentation.onAfterCall(frame, callMetadata);
          const timer = setTimeout(() => {
            actionInContext.committed = true;
            this._timers.delete(timer);
          }, 5e3);
          this._generator.didPerformAction(actionInContext);
          this._timers.add(timer);
        };
        const kActionTimeout = 5e3;
        if (action.name === "click") {
          const {
            options: options2
          } = (0, _utils.toClickOptions)(action);
          await perform("click", {
            selector: action.selector
          }, (callMetadata) => frame.click(callMetadata, action.selector, __spreadProps(__spreadValues({}, options2), {
            timeout: kActionTimeout
          })));
        }
        if (action.name === "press") {
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const shortcut = [...modifiers, action.key].join("+");
          await perform("press", {
            selector: action.selector,
            key: shortcut
          }, (callMetadata) => frame.press(callMetadata, action.selector, shortcut, {
            timeout: kActionTimeout
          }));
        }
        if (action.name === "check")
          await perform("check", {
            selector: action.selector
          }, (callMetadata) => frame.check(callMetadata, action.selector, {
            timeout: kActionTimeout
          }));
        if (action.name === "uncheck")
          await perform("uncheck", {
            selector: action.selector
          }, (callMetadata) => frame.uncheck(callMetadata, action.selector, {
            timeout: kActionTimeout
          }));
        if (action.name === "select") {
          const values = action.options.map((value) => ({
            value
          }));
          await perform("selectOption", {
            selector: action.selector,
            values
          }, (callMetadata) => frame.selectOption(callMetadata, action.selector, [], values, {
            timeout: kActionTimeout
          }));
        }
      }
      async _recordAction(frame, action) {
        this._generator.commitLastAction();
        this._generator.addAction(__spreadProps(__spreadValues({
          pageAlias: this._pageAliases.get(frame._page)
        }, (0, _utils.describeFrame)(frame)), {
          action
        }));
      }
      _onFrameNavigated(frame, page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, frame, {
          name: "navigation",
          url: frame.url()
        });
      }
      _onPopup(page, popup) {
        const pageAlias = this._pageAliases.get(page);
        const popupAlias = this._pageAliases.get(popup);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "popup",
          popupAlias
        });
      }
      _onDownload(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "download",
          downloadAlias: String(++this._lastDownloadOrdinal)
        });
      }
      _onDialog(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "dialog",
          dialogAlias: String(++this._lastDialogOrdinal)
        });
      }
    };
    ContextRecorder.Events = {
      Change: "change"
    };
    function languageForFile(file) {
      if (file.endsWith(".py"))
        return "python";
      if (file.endsWith(".java"))
        return "java";
      if (file.endsWith(".cs"))
        return "csharp";
      return "javascript";
    }
  }
});

// node_modules/playwright-core/lib/server/browserContext.js
var require_browserContext = __commonJS({
  "node_modules/playwright-core/lib/server/browserContext.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
    exports.validateBrowserContextOptions = validateBrowserContextOptions;
    exports.verifyGeolocation = verifyGeolocation;
    exports.normalizeProxySettings = normalizeProxySettings;
    exports.BrowserContext = void 0;
    var os = _interopRequireWildcard(__require("os"));
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _path = _interopRequireDefault(__require("path"));
    var _instrumentation = require_instrumentation();
    var _debugger = require_debugger();
    var _tracing = require_tracing();
    var _harRecorder = require_harRecorder();
    var _recorderSupplement = require_recorderSupplement();
    var consoleApiSource = _interopRequireWildcard(require_consoleApiSource());
    var _fetch = require_fetch();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContext = class extends _instrumentation.SdkObject {
      constructor(browser, options2, browserContextId) {
        super(browser, "browser-context");
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._pageBindings = new Map();
        this._options = void 0;
        this._requestInterceptor = void 0;
        this._isPersistentContext = void 0;
        this._closedStatus = "open";
        this._closePromise = void 0;
        this._closePromiseFulfill = void 0;
        this._permissions = new Map();
        this._downloads = new Set();
        this._browser = void 0;
        this._browserContextId = void 0;
        this._selectors = void 0;
        this._origins = new Set();
        this._harRecorder = void 0;
        this.tracing = void 0;
        this.fetchRequest = void 0;
        this.attribution.context = this;
        this._browser = browser;
        this._options = options2;
        this._browserContextId = browserContextId;
        this._isPersistentContext = !browserContextId;
        this._closePromise = new Promise((fulfill) => this._closePromiseFulfill = fulfill);
        this.instrumentation = (0, _instrumentation.createInstrumentation)();
        if (this._options.recordHar)
          this._harRecorder = new _harRecorder.HarRecorder(this, __spreadProps(__spreadValues({}, this._options.recordHar), {
            path: _path.default.join(this._browser.options.artifactsDir, `${(0, _utils.createGuid)()}.har`)
          }));
        this.tracing = new _tracing.Tracing(this);
        this.fetchRequest = new _fetch.BrowserContextAPIRequestContext(this);
      }
      isPersistentContext() {
        return this._isPersistentContext;
      }
      _setSelectors(selectors2) {
        this._selectors = selectors2;
      }
      selectors() {
        return this._selectors || this._browser.options.selectors;
      }
      async _initialize() {
        if (this.attribution.isInternal)
          return;
        const contextDebugger = new _debugger.Debugger(this);
        this.instrumentation.addListener(contextDebugger);
        if ((0, _utils.debugMode)() === "inspector")
          await _recorderSupplement.RecorderSupplement.show(this, {
            pauseOnNextStatement: true
          });
        if (contextDebugger.isPaused())
          _recorderSupplement.RecorderSupplement.showInspector(this);
        contextDebugger.on(_debugger.Debugger.Events.PausedStateChanged, () => {
          _recorderSupplement.RecorderSupplement.showInspector(this);
        });
        if ((0, _utils.debugMode)() === "console")
          await this.extendInjectedScript(consoleApiSource.source);
      }
      async _ensureVideosPath() {
        if (this._options.recordVideo)
          await (0, _utils.mkdirIfNeeded)(_path.default.join(this._options.recordVideo.dir, "dummy"));
      }
      _browserClosed() {
        for (const page of this.pages())
          page._didClose();
        this._didCloseInternal();
      }
      _didCloseInternal() {
        if (this._closedStatus === "closed") {
          return;
        }
        this._closedStatus = "closed";
        this._deleteAllDownloads();
        this._downloads.clear();
        if (this._isPersistentContext)
          this._onClosePersistent();
        this._closePromiseFulfill(new Error("Context closed"));
        this.emit(BrowserContext.Events.Close);
      }
      async cookies(urls = []) {
        if (urls && !Array.isArray(urls))
          urls = [urls];
        return await this._doCookies(urls);
      }
      setHTTPCredentials(httpCredentials) {
        return this._doSetHTTPCredentials(httpCredentials);
      }
      async exposeBinding(name, needsHandle, playwrightBinding) {
        if (this._pageBindings.has(name))
          throw new Error(`Function "${name}" has been already registered`);
        for (const page of this.pages()) {
          if (page.getBinding(name))
            throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        const binding = new _page.PageBinding(name, playwrightBinding, needsHandle);
        this._pageBindings.set(name, binding);
        await this._doExposeBinding(binding);
      }
      async grantPermissions(permissions, origin) {
        let resolvedOrigin = "*";
        if (origin) {
          const url = new URL(origin);
          resolvedOrigin = url.origin;
        }
        const existing = new Set(this._permissions.get(resolvedOrigin) || []);
        permissions.forEach((p) => existing.add(p));
        const list2 = [...existing.values()];
        this._permissions.set(resolvedOrigin, list2);
        await this._doGrantPermissions(resolvedOrigin, list2);
      }
      async clearPermissions() {
        this._permissions.clear();
        await this._doClearPermissions();
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async _loadDefaultContextAsIs(progress) {
        if (!this.pages().length) {
          const waitForEvent = _helper.helper.waitForEvent(progress, this, BrowserContext.Events.Page);
          progress.cleanupWhenAborted(() => waitForEvent.dispose);
          const page = await waitForEvent.promise;
          if (page._pageIsError)
            throw page._pageIsError;
        }
        const pages = this.pages();
        if (pages[0]._pageIsError)
          throw pages[0]._pageIsError;
        await pages[0].mainFrame()._waitForLoadState(progress, "load");
        return pages;
      }
      async _loadDefaultContext(progress) {
        const pages = await this._loadDefaultContextAsIs(progress);
        if (this._options.isMobile || this._options.locale) {
          const oldPage = pages[0];
          await this.newPage(progress.metadata);
          await oldPage.close(progress.metadata);
        }
      }
      _authenticateProxyViaHeader() {
        const proxy = this._options.proxy || this._browser.options.proxy || {
          username: void 0,
          password: void 0
        };
        const {
          username,
          password
        } = proxy;
        if (username) {
          this._options.httpCredentials = {
            username,
            password
          };
          const token = Buffer.from(`${username}:${password}`).toString("base64");
          this._options.extraHTTPHeaders = network.mergeHeaders([this._options.extraHTTPHeaders, network.singleHeader("Proxy-Authorization", `Basic ${token}`)]);
        }
      }
      _authenticateProxyViaCredentials() {
        const proxy = this._options.proxy || this._browser.options.proxy;
        if (!proxy)
          return;
        const {
          username,
          password
        } = proxy;
        if (username)
          this._options.httpCredentials = {
            username,
            password: password || ""
          };
      }
      async _setRequestInterceptor(handler) {
        this._requestInterceptor = handler;
        await this._doUpdateRequestInterception();
      }
      isClosingOrClosed() {
        return this._closedStatus !== "open";
      }
      async _deleteAllDownloads() {
        await Promise.all(Array.from(this._downloads).map((download) => download.artifact.deleteOnContextClose()));
      }
      async close(metadata) {
        if (this._closedStatus === "open") {
          var _this$_harRecorder;
          this.emit(BrowserContext.Events.BeforeClose);
          this._closedStatus = "closing";
          await ((_this$_harRecorder = this._harRecorder) === null || _this$_harRecorder === void 0 ? void 0 : _this$_harRecorder.flush());
          await this.tracing.dispose();
          const promises = [];
          for (const {
            context,
            artifact
          } of this._browser._idToVideo.values()) {
            if (context === this)
              promises.push(artifact.finishedPromise());
          }
          if (this._isPersistentContext) {
            await Promise.all(this.pages().map((page) => page.close(metadata)));
          } else {
            await this._doClose();
          }
          promises.push(this._deleteAllDownloads());
          await Promise.all(promises);
          if (this._isPersistentContext)
            await this._browser.close();
          this._didCloseInternal();
        }
        await this._closePromise;
      }
      async newPage(metadata) {
        const pageDelegate = await this.newPageDelegate();
        const pageOrError = await pageDelegate.pageOrError();
        if (pageOrError instanceof _page.Page) {
          if (pageOrError.isClosed())
            throw new Error("Page has been closed.");
          return pageOrError;
        }
        throw pageOrError;
      }
      addVisitedOrigin(origin) {
        this._origins.add(origin);
      }
      async storageState() {
        const result = {
          cookies: await this.cookies(),
          origins: []
        };
        if (this._origins.size) {
          const internalMetadata = (0, _instrumentation.internalCallMetadata)();
          const page = await this.newPage(internalMetadata);
          await page._setServerRequestInterceptor((handler) => {
            handler.fulfill({
              body: "<html></html>"
            }).catch(() => {
            });
          });
          for (const origin of this._origins) {
            const originStorage = {
              origin,
              localStorage: []
            };
            const frame = page.mainFrame();
            await frame.goto(internalMetadata, origin);
            const storage = await frame.evaluateExpression(`({
          localStorage: Object.keys(localStorage).map(name => ({ name, value: localStorage.getItem(name) })),
        })`, false, void 0, "utility");
            originStorage.localStorage = storage.localStorage;
            if (storage.localStorage.length)
              result.origins.push(originStorage);
          }
          await page.close(internalMetadata);
        }
        return result;
      }
      async setStorageState(metadata, state) {
        if (state.cookies)
          await this.addCookies(state.cookies);
        if (state.origins && state.origins.length) {
          const internalMetadata = (0, _instrumentation.internalCallMetadata)();
          const page = await this.newPage(internalMetadata);
          await page._setServerRequestInterceptor((handler) => {
            handler.fulfill({
              body: "<html></html>"
            }).catch(() => {
            });
          });
          for (const originState of state.origins) {
            const frame = page.mainFrame();
            await frame.goto(metadata, originState.origin);
            await frame.evaluateExpression(`
          originState => {
            for (const { name, value } of (originState.localStorage || []))
              localStorage.setItem(name, value);
          }`, true, originState, "utility");
          }
          await page.close(internalMetadata);
        }
      }
      async extendInjectedScript(source, arg) {
        const installInFrame = (frame) => frame.extendInjectedScript(source, arg).catch(() => {
        });
        const installInPage = (page) => {
          page.on(_page.Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
          return Promise.all(page.frames().map(installInFrame));
        };
        this.on(BrowserContext.Events.Page, installInPage);
        return Promise.all(this.pages().map(installInPage));
      }
    };
    exports.BrowserContext = BrowserContext;
    BrowserContext.Events = {
      Close: "close",
      Page: "page",
      Request: "request",
      Response: "response",
      RequestFailed: "requestfailed",
      RequestFinished: "requestfinished",
      BeforeClose: "beforeclose",
      VideoStarted: "videostarted"
    };
    function assertBrowserContextIsNotOwned(context) {
      for (const page of context.pages()) {
        if (page._ownedContext)
          throw new Error("Please use browser.newContext() for multi-page scripts that share the context.");
      }
    }
    function validateBrowserContextOptions(options2, browserOptions) {
      if (options2.noDefaultViewport && options2.deviceScaleFactor !== void 0)
        throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
      if (options2.noDefaultViewport && options2.isMobile !== void 0)
        throw new Error(`"isMobile" option is not supported with null "viewport"`);
      if (!options2.viewport && !options2.noDefaultViewport)
        options2.viewport = {
          width: 1280,
          height: 720
        };
      if (options2.recordVideo) {
        if (!options2.recordVideo.size) {
          if (options2.noDefaultViewport) {
            options2.recordVideo.size = {
              width: 800,
              height: 600
            };
          } else {
            const size = options2.viewport;
            const scale = Math.min(1, 800 / Math.max(size.width, size.height));
            options2.recordVideo.size = {
              width: Math.floor(size.width * scale),
              height: Math.floor(size.height * scale)
            };
          }
        }
        options2.recordVideo.size.width &= ~1;
        options2.recordVideo.size.height &= ~1;
      }
      if (options2.proxy) {
        if (!browserOptions.proxy && browserOptions.isChromium && os.platform() === "win32")
          throw new Error(`Browser needs to be launched with the global proxy. If all contexts override the proxy, global proxy will be never used and can be any string, for example "launch({ proxy: { server: 'http://per-context' } })"`);
        options2.proxy = normalizeProxySettings(options2.proxy);
      }
      if ((0, _utils.debugMode)() === "inspector")
        options2.bypassCSP = true;
      verifyGeolocation(options2.geolocation);
    }
    function verifyGeolocation(geolocation) {
      if (!geolocation)
        return;
      geolocation.accuracy = geolocation.accuracy || 0;
      const {
        longitude,
        latitude,
        accuracy
      } = geolocation;
      if (longitude < -180 || longitude > 180)
        throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
      if (latitude < -90 || latitude > 90)
        throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
      if (accuracy < 0)
        throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
    }
    function normalizeProxySettings(proxy) {
      let {
        server,
        bypass
      } = proxy;
      let url;
      try {
        url = new URL(server);
        if (!url.host || !url.protocol)
          url = new URL("http://" + server);
      } catch (e) {
        url = new URL("http://" + server);
      }
      if (url.protocol === "socks4:" && (proxy.username || proxy.password))
        throw new Error(`Socks4 proxy protocol does not support authentication`);
      if (url.protocol === "socks5:" && (proxy.username || proxy.password))
        throw new Error(`Browser does not support socks5 proxy authentication`);
      server = url.protocol + "//" + url.host;
      if (bypass)
        bypass = bypass.split(",").map((t) => t.trim()).join(",");
      return __spreadProps(__spreadValues({}, proxy), {
        server,
        bypass
      });
    }
  }
});

// node_modules/playwright-core/lib/server/download.js
var require_download = __commonJS({
  "node_modules/playwright-core/lib/server/download.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Download = void 0;
    var _path = _interopRequireDefault(__require("path"));
    var _page = require_page();
    var _utils = require_utils();
    var _artifact = require_artifact();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Download = class {
      constructor(page, downloadsPath, uuid, url, suggestedFilename) {
        this.artifact = void 0;
        this.url = void 0;
        this._page = void 0;
        this._suggestedFilename = void 0;
        const unaccessibleErrorMessage = !page._browserContext._options.acceptDownloads ? "Pass { acceptDownloads: true } when you are creating your browser context." : void 0;
        this.artifact = new _artifact.Artifact(page, _path.default.join(downloadsPath, uuid), unaccessibleErrorMessage, () => {
          return this._page._browserContext._doCancelDownload(uuid);
        });
        this._page = page;
        this.url = url;
        this._suggestedFilename = suggestedFilename;
        page._browserContext._downloads.add(this);
        if (suggestedFilename !== void 0)
          this._page.emit(_page.Page.Events.Download, this);
      }
      _filenameSuggested(suggestedFilename) {
        (0, _utils.assert)(this._suggestedFilename === void 0);
        this._suggestedFilename = suggestedFilename;
        this._page.emit(_page.Page.Events.Download, this);
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
    };
    exports.Download = Download;
  }
});

// node_modules/playwright-core/lib/server/browser.js
var require_browser2 = __commonJS({
  "node_modules/playwright-core/lib/server/browser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Browser = void 0;
    var _browserContext = require_browserContext();
    var _page = require_page();
    var _download = require_download();
    var _instrumentation = require_instrumentation();
    var _artifact = require_artifact();
    var Browser = class extends _instrumentation.SdkObject {
      constructor(options2) {
        super(options2.rootSdkObject, "browser");
        this.options = void 0;
        this._downloads = new Map();
        this._defaultContext = null;
        this._startedClosing = false;
        this._idToVideo = new Map();
        this.attribution.browser = this;
        this.options = options2;
      }
      _downloadCreated(page, uuid, url, suggestedFilename) {
        const download = new _download.Download(page, this.options.downloadsPath || "", uuid, url, suggestedFilename);
        this._downloads.set(uuid, download);
      }
      _downloadFilenameSuggested(uuid, suggestedFilename) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download._filenameSuggested(suggestedFilename);
      }
      _downloadFinished(uuid, error2) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download.artifact.reportFinished(error2);
        this._downloads.delete(uuid);
      }
      _videoStarted(context, videoId, path, pageOrError) {
        const artifact = new _artifact.Artifact(context, path);
        this._idToVideo.set(videoId, {
          context,
          artifact
        });
        context.emit(_browserContext.BrowserContext.Events.VideoStarted, artifact);
        pageOrError.then((page) => {
          if (page instanceof _page.Page) {
            page._video = artifact;
            page.emit(_page.Page.Events.Video, artifact);
          }
        });
      }
      _takeVideo(videoId) {
        const video = this._idToVideo.get(videoId);
        this._idToVideo.delete(videoId);
        return video === null || video === void 0 ? void 0 : video.artifact;
      }
      _didClose() {
        for (const context of this.contexts())
          context._browserClosed();
        if (this._defaultContext)
          this._defaultContext._browserClosed();
        this.emit(Browser.Events.Disconnected);
      }
      async close() {
        if (!this._startedClosing) {
          this._startedClosing = true;
          await this.options.browserProcess.close();
        }
        if (this.isConnected())
          await new Promise((x) => this.once(Browser.Events.Disconnected, x));
      }
      async killForTests() {
        await this.options.browserProcess.kill();
      }
    };
    exports.Browser = Browser;
    Browser.Events = {
      Disconnected: "disconnected"
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crConnection.js
var require_crConnection = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crConnection.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CRSession = exports.CRSessionEvents = exports.CRConnection = exports.kBrowserCloseMessageId = exports.ConnectionEvents = void 0;
    var _utils = require_utils();
    var _events = __require("events");
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _protocolError = require_protocolError();
    var ConnectionEvents = {
      Disconnected: Symbol("ConnectionEvents.Disconnected")
    };
    exports.ConnectionEvents = ConnectionEvents;
    var kBrowserCloseMessageId = -9999;
    exports.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var CRConnection = class extends _events.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = 0;
        this._transport = void 0;
        this._sessions = new Map();
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this.rootSession = void 0;
        this._closed = false;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this.rootSession = new CRSession(this, "", "browser", "");
        this._sessions.set("", this.rootSession);
      }
      static fromSession(session) {
        return session._connection;
      }
      session(sessionId) {
        return this._sessions.get(sessionId) || null;
      }
      _rawSend(sessionId, method, params) {
        const id = ++this._lastId;
        const message = {
          id,
          method,
          params
        };
        if (sessionId)
          message.sessionId = sessionId;
        this._protocolLogger("send", message);
        this._transport.send(message);
        return id;
      }
      async _onMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === kBrowserCloseMessageId)
          return;
        if (message.method === "Target.attachedToTarget") {
          const sessionId = message.params.sessionId;
          const rootSessionId = message.sessionId || "";
          const session2 = new CRSession(this, rootSessionId, message.params.targetInfo.type, sessionId);
          this._sessions.set(sessionId, session2);
        } else if (message.method === "Target.detachedFromTarget") {
          const session2 = this._sessions.get(message.params.sessionId);
          if (session2) {
            session2._onClosed(void 0);
            this._sessions.delete(message.params.sessionId);
          }
        }
        const session = this._sessions.get(message.sessionId || "");
        if (session)
          session._onMessage(message);
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const browserDisconnectedLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session._onClosed(browserDisconnectedLogs);
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      async createSession(targetInfo) {
        const {
          sessionId
        } = await this.rootSession.send("Target.attachToTarget", {
          targetId: targetInfo.targetId,
          flatten: true
        });
        return this._sessions.get(sessionId);
      }
      async createBrowserSession() {
        const {
          sessionId
        } = await this.rootSession.send("Target.attachToBrowserTarget");
        return this._sessions.get(sessionId);
      }
    };
    exports.CRConnection = CRConnection;
    var CRSessionEvents = {
      Disconnected: Symbol("Events.CDPSession.Disconnected")
    };
    exports.CRSessionEvents = CRSessionEvents;
    var CRSession = class extends _events.EventEmitter {
      constructor(connection, rootSessionId, targetType, sessionId) {
        super();
        this._connection = void 0;
        this._eventListener = void 0;
        this._callbacks = new Map();
        this._targetType = void 0;
        this._sessionId = void 0;
        this._rootSessionId = void 0;
        this._crashed = false;
        this._browserDisconnectedLogs = void 0;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.guid = void 0;
        this.guid = `cdp-session@${sessionId}`;
        this.setMaxListeners(0);
        this._connection = connection;
        this._rootSessionId = rootSessionId;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      _markAsCrashed() {
        this._crashed = true;
      }
      async send(method, params) {
        if (this._crashed)
          throw new _protocolError.ProtocolError(true, "Target crashed");
        if (this._browserDisconnectedLogs !== void 0)
          throw new _protocolError.ProtocolError(true, `Browser closed.` + this._browserDisconnectedLogs);
        if (!this._connection)
          throw new _protocolError.ProtocolError(true, `Target closed`);
        const id = this._connection._rawSend(this._sessionId, method, params);
        return new Promise((resolve3, reject) => {
          this._callbacks.set(id, {
            resolve: resolve3,
            reject,
            error: new _protocolError.ProtocolError(false),
            method
          });
        });
      }
      _sendMayFail(method, params) {
        return this.send(method, params).catch((error2) => _debugLogger.debugLogger.log("error", error2));
      }
      _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          (0, _utils.assert)(!object.id);
          Promise.resolve().then(() => {
            if (this._eventListener)
              this._eventListener(object.method, object.params);
            this.emit(object.method, object.params);
          });
        }
      }
      async detach() {
        if (!this._connection)
          throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
        const rootSession = this._connection.session(this._rootSessionId);
        if (!rootSession)
          throw new Error("Root session has been closed");
        await rootSession.send("Target.detachFromTarget", {
          sessionId: this._sessionId
        });
      }
      _onClosed(browserDisconnectedLogs) {
        this._browserDisconnectedLogs = browserDisconnectedLogs;
        const errorMessage = browserDisconnectedLogs !== void 0 ? "Browser closed." + browserDisconnectedLogs : "Target closed";
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, errorMessage));
        }
        this._callbacks.clear();
        this._connection = null;
        Promise.resolve().then(() => this.emit(CRSessionEvents.Disconnected));
      }
    };
    exports.CRSession = CRSession;
    function createProtocolError(error2, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return (0, _stackTrace.rewriteErrorMessage)(error2, message);
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js
var require_crProtocolHelper = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getExceptionMessage = getExceptionMessage;
    exports.releaseObject = releaseObject;
    exports.readProtocolStream = readProtocolStream;
    exports.toConsoleMessageLocation = toConsoleMessageLocation;
    exports.exceptionToError = exceptionToError;
    exports.toModifiersMask = toModifiersMask;
    var _fs = _interopRequireDefault(__require("fs"));
    var _utils = require_utils();
    var _stackTrace = require_stackTrace();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getExceptionMessage(exceptionDetails) {
      if (exceptionDetails.exception)
        return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
      let message = exceptionDetails.text;
      if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
          const location2 = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
          const functionName = callframe.functionName || "<anonymous>";
          message += `
    at ${functionName} (${location2})`;
        }
      }
      return message;
    }
    async function releaseObject(client, objectId) {
      await client.send("Runtime.releaseObject", {
        objectId
      }).catch((error2) => {
      });
    }
    async function readProtocolStream(client, handle, path) {
      let eof = false;
      let fd;
      if (path) {
        await (0, _utils.mkdirIfNeeded)(path);
        fd = await _fs.default.promises.open(path, "w");
      }
      const bufs = [];
      while (!eof) {
        const response = await client.send("IO.read", {
          handle
        });
        eof = response.eof;
        const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
        bufs.push(buf);
        if (fd)
          await fd.write(buf);
      }
      if (fd)
        await fd.close();
      await client.send("IO.close", {
        handle
      });
      return Buffer.concat(bufs);
    }
    function toConsoleMessageLocation(stackTrace) {
      return stackTrace && stackTrace.callFrames.length ? {
        url: stackTrace.callFrames[0].url,
        lineNumber: stackTrace.callFrames[0].lineNumber,
        columnNumber: stackTrace.callFrames[0].columnNumber
      } : {
        url: "",
        lineNumber: 0,
        columnNumber: 0
      };
    }
    function exceptionToError(exceptionDetails) {
      const messageWithStack = getExceptionMessage(exceptionDetails);
      const lines = messageWithStack.split("\n");
      const firstStackTraceLine = lines.findIndex((line) => line.startsWith("    at"));
      let messageWithName = "";
      let stack = "";
      if (firstStackTraceLine === -1) {
        messageWithName = messageWithStack;
      } else {
        messageWithName = lines.slice(0, firstStackTraceLine).join("\n");
        stack = messageWithStack;
      }
      const {
        name,
        message
      } = (0, _stackTrace.splitErrorMessage)(messageWithName);
      const err = new Error(message);
      err.stack = stack;
      err.name = name;
      return err;
    }
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Meta"))
        mask |= 4;
      if (modifiers.has("Shift"))
        mask |= 8;
      return mask;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crExecutionContext.js
var require_crExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crExecutionContext.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CRExecutionContext = void 0;
    var _crProtocolHelper = require_crProtocolHelper();
    var js = _interopRequireWildcard(require_javascript());
    var _stackTrace = require_stackTrace();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRExecutionContext = class {
      constructor(client, contextPayload) {
        this._client = void 0;
        this._contextId = void 0;
        this._client = client;
        this._contextId = contextPayload.id;
      }
      async rawEvaluateJSON(expression) {
        const {
          exceptionDetails,
          result: remoteObject
        } = await this._client.send("Runtime.evaluate", {
          expression,
          contextId: this._contextId,
          returnByValue: true
        }).catch(rewriteError);
        if (exceptionDetails)
          throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
        return remoteObject.value;
      }
      async rawEvaluateHandle(expression) {
        const {
          exceptionDetails,
          result: remoteObject
        } = await this._client.send("Runtime.evaluate", {
          expression,
          contextId: this._contextId
        }).catch(rewriteError);
        if (exceptionDetails)
          throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
        return remoteObject.objectId;
      }
      rawCallFunctionNoReply(func, ...args) {
        this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          arguments: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          executionContextId: this._contextId,
          userGesture: true
        }).catch(() => {
        });
      }
      async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        const {
          exceptionDetails,
          result: remoteObject
        } = await this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: expression,
          objectId: utilityScript._objectId,
          arguments: [{
            objectId: utilityScript._objectId
          }, ...values.map((value) => ({
            value
          })), ...objectIds.map((objectId) => ({
            objectId
          }))],
          returnByValue,
          awaitPromise: true,
          userGesture: true
        }).catch(rewriteError);
        if (exceptionDetails)
          throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
        return returnByValue ? (0, _utilityScriptSerializers.parseEvaluationResultValue)(remoteObject.value) : utilityScript._context.createHandle(remoteObject);
      }
      async getProperties(context, objectId) {
        const response = await this._client.send("Runtime.getProperties", {
          objectId,
          ownProperties: true
        });
        const result = new Map();
        for (const property of response.result) {
          if (!property.enumerable || !property.value)
            continue;
          result.set(property.name, context.createHandle(property.value));
        }
        return result;
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      async releaseHandle(objectId) {
        await (0, _crProtocolHelper.releaseObject)(this._client, objectId);
      }
    };
    exports.CRExecutionContext = CRExecutionContext;
    function rewriteError(error2) {
      if (error2.message.includes("Object reference chain is too long"))
        return {
          result: {
            type: "undefined"
          }
        };
      if (error2.message.includes("Object couldn't be returned by value"))
        return {
          result: {
            type: "undefined"
          }
        };
      if (error2 instanceof TypeError && error2.message.startsWith("Converting circular structure to JSON"))
        (0, _stackTrace.rewriteErrorMessage)(error2, error2.message + " Are you passing a nested JSHandle?");
      if (!js.isJavaScriptErrorInEvaluate(error2) && !(0, _protocolError.isSessionClosedError)(error2))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      throw error2;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if ("value" in object)
        return String(object.value);
      if (object.unserializableValue)
        return String(object.unserializableValue);
      if (object.description === "Object" && object.preview) {
        const tokens = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          tokens.push(`${name}: ${value}`);
        return `{${tokens.join(", ")}}`;
      }
      if (object.subtype === "array" && object.preview) {
        const result = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          result[+name] = value;
        return "[" + String(result) + "]";
      }
      return object.description;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crNetworkManager.js
var require_crNetworkManager = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crNetworkManager.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CRNetworkManager = void 0;
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network());
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRNetworkManager = class {
      constructor(client, page, parentManager) {
        this._client = void 0;
        this._page = void 0;
        this._parentManager = void 0;
        this._requestIdToRequest = new Map();
        this._requestIdToRequestWillBeSentEvent = new Map();
        this._credentials = null;
        this._attemptedAuthentications = new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._requestIdToRequestPausedEvent = new Map();
        this._eventListeners = void 0;
        this._responseExtraInfoTracker = new ResponseExtraInfoTracker();
        this._client = client;
        this._page = page;
        this._parentManager = parentManager;
        this._eventListeners = this.instrumentNetworkEvents(client);
      }
      instrumentNetworkEvents(session, workerFrame) {
        return [_eventsHelper.eventsHelper.addEventListener(session, "Fetch.requestPaused", this._onRequestPaused.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, "Fetch.authRequired", this._onAuthRequired.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSentExtraInfo", this._onRequestWillBeSentExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceivedExtraInfo", this._onResponseReceivedExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFinished", this._onLoadingFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFailed", this._onLoadingFailed.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];
      }
      async initialize() {
        await this._client.send("Network.enable");
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      async authenticate(credentials) {
        this._credentials = credentials;
        await this._updateProtocolRequestInterception();
      }
      async setOffline(offline) {
        await this._client.send("Network.emulateNetworkConditions", {
          offline,
          latency: 0,
          downloadThroughput: -1,
          uploadThroughput: -1
        });
      }
      async setRequestInterception(value) {
        this._userRequestInterceptionEnabled = value;
        await this._updateProtocolRequestInterception();
      }
      async _updateProtocolRequestInterception() {
        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
        if (enabled === this._protocolRequestInterceptionEnabled)
          return;
        this._protocolRequestInterceptionEnabled = enabled;
        if (enabled) {
          await Promise.all([this._client.send("Network.setCacheDisabled", {
            cacheDisabled: true
          }), this._client.send("Fetch.enable", {
            handleAuthRequests: true,
            patterns: [{
              urlPattern: "*",
              requestStage: "Request"
            }]
          })]);
        } else {
          await Promise.all([this._client.send("Network.setCacheDisabled", {
            cacheDisabled: false
          }), this._client.send("Fetch.disable")]);
        }
      }
      _onRequestWillBeSent(workerFrame, event) {
        this._responseExtraInfoTracker.requestWillBeSent(event);
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
          const requestId = event.requestId;
          const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
          if (requestPausedEvent) {
            this._onRequest(workerFrame, event, requestPausedEvent);
            this._requestIdToRequestPausedEvent.delete(requestId);
          } else {
            this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
          }
        } else {
          this._onRequest(workerFrame, event, null);
        }
      }
      _onRequestWillBeSentExtraInfo(event) {
        this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);
      }
      _onAuthRequired(event) {
        let response = "Default";
        if (this._attemptedAuthentications.has(event.requestId)) {
          response = "CancelAuth";
        } else if (this._credentials) {
          response = "ProvideCredentials";
          this._attemptedAuthentications.add(event.requestId);
        }
        const {
          username,
          password
        } = this._credentials || {
          username: void 0,
          password: void 0
        };
        this._client._sendMayFail("Fetch.continueWithAuth", {
          requestId: event.requestId,
          authChallengeResponse: {
            response,
            username,
            password
          }
        });
      }
      _onRequestPaused(workerFrame, event) {
        if (!event.responseStatusCode && !event.responseErrorReason) {
          const request = this._requestIdToRequest.get(event.networkId);
          if (request)
            this._responseExtraInfoTracker.requestPaused(request.request, event);
        }
        if (!event.networkId) {
          this._client._sendMayFail("Fetch.failRequest", {
            requestId: event.requestId,
            errorReason: "Aborted"
          });
          return;
        }
        if (event.request.url.startsWith("data:"))
          return;
        const requestId = event.networkId;
        const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
        if (requestWillBeSentEvent) {
          this._onRequest(workerFrame, requestWillBeSentEvent, event);
          this._requestIdToRequestWillBeSentEvent.delete(requestId);
        } else {
          this._requestIdToRequestPausedEvent.set(requestId, event);
        }
      }
      _onRequest(workerFrame, requestWillBeSentEvent, requestPausedEvent) {
        if (requestWillBeSentEvent.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (requestWillBeSentEvent.redirectResponse) {
          const request2 = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp);
            redirectedFrom = request2;
          }
        }
        let frame = requestWillBeSentEvent.frameId ? this._page._frameManager.frame(requestWillBeSentEvent.frameId) : workerFrame;
        if (!frame && requestPausedEvent && requestPausedEvent.frameId)
          frame = this._page._frameManager.frame(requestPausedEvent.frameId);
        if (!frame && requestWillBeSentEvent.frameId === this._page._delegate._targetId) {
          frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
        }
        if (requestPausedEvent && requestPausedEvent.request.method === "OPTIONS" && this._page._needsRequestInterception()) {
          const requestHeaders = requestPausedEvent.request.headers;
          const responseHeaders = [{
            name: "Access-Control-Allow-Origin",
            value: requestHeaders["Origin"] || "*"
          }, {
            name: "Access-Control-Allow-Methods",
            value: requestHeaders["Access-Control-Request-Method"] || "GET, POST, OPTIONS, DELETE"
          }, {
            name: "Access-Control-Allow-Credentials",
            value: "true"
          }];
          if (requestHeaders["Access-Control-Request-Headers"])
            responseHeaders.push({
              name: "Access-Control-Allow-Headers",
              value: requestHeaders["Access-Control-Request-Headers"]
            });
          this._client._sendMayFail("Fetch.fulfillRequest", {
            requestId: requestPausedEvent.requestId,
            responseCode: 204,
            responsePhrase: network.STATUS_TEXTS["204"],
            responseHeaders,
            body: ""
          });
          return;
        }
        if (!frame) {
          if (requestPausedEvent)
            this._client._sendMayFail("Fetch.continueRequest", {
              requestId: requestPausedEvent.requestId
            });
          return;
        }
        let route = null;
        if (requestPausedEvent) {
          if (redirectedFrom || !this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled)
            this._client._sendMayFail("Fetch.continueRequest", {
              requestId: requestPausedEvent.requestId
            });
          else
            route = new RouteImpl(this._client, requestPausedEvent.requestId);
        }
        const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === "Document";
        const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : void 0;
        const request = new InterceptableRequest({
          frame,
          documentId,
          route,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom
        });
        this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);
        this._page._frameManager.requestStarted(request.request, route || void 0);
      }
      _createResponse(request, responsePayload) {
        var _responsePayload$secu, _responsePayload$secu2, _responsePayload$secu3, _responsePayload$secu4, _responsePayload$secu5;
        const getResponseBody = async () => {
          const response2 = await this._client.send("Network.getResponseBody", {
            requestId: request._requestId
          });
          return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
        };
        const timingPayload = responsePayload.timing;
        let timing;
        if (timingPayload) {
          timing = {
            startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1e3,
            domainLookupStart: timingPayload.dnsStart,
            domainLookupEnd: timingPayload.dnsEnd,
            connectStart: timingPayload.connectStart,
            secureConnectionStart: timingPayload.sslStart,
            connectEnd: timingPayload.connectEnd,
            requestStart: timingPayload.sendStart,
            responseStart: timingPayload.receiveHeadersEnd
          };
        } else {
          timing = {
            startTime: request._wallTime * 1e3,
            domainLookupStart: -1,
            domainLookupEnd: -1,
            connectStart: -1,
            secureConnectionStart: -1,
            connectEnd: -1,
            requestStart: -1,
            responseStart: -1
          };
        }
        const response = new network.Response(request.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers), timing, getResponseBody, responsePayload.protocol);
        if (responsePayload !== null && responsePayload !== void 0 && responsePayload.remoteIPAddress && typeof (responsePayload === null || responsePayload === void 0 ? void 0 : responsePayload.remotePort) === "number") {
          response._serverAddrFinished({
            ipAddress: responsePayload.remoteIPAddress,
            port: responsePayload.remotePort
          });
        } else {
          response._serverAddrFinished();
        }
        response._securityDetailsFinished({
          protocol: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu = responsePayload.securityDetails) === null || _responsePayload$secu === void 0 ? void 0 : _responsePayload$secu.protocol,
          subjectName: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu2 = responsePayload.securityDetails) === null || _responsePayload$secu2 === void 0 ? void 0 : _responsePayload$secu2.subjectName,
          issuer: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu3 = responsePayload.securityDetails) === null || _responsePayload$secu3 === void 0 ? void 0 : _responsePayload$secu3.issuer,
          validFrom: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu4 = responsePayload.securityDetails) === null || _responsePayload$secu4 === void 0 ? void 0 : _responsePayload$secu4.validFrom,
          validTo: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu5 = responsePayload.securityDetails) === null || _responsePayload$secu5 === void 0 ? void 0 : _responsePayload$secu5.validTo
        });
        this._responseExtraInfoTracker.processResponse(request._requestId, response, request.wasFulfilled());
        return response;
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = this._createResponse(request, responsePayload);
        response._requestFinished((timestamp - request._timestamp) * 1e3);
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onResponseReceivedExtraInfo(event) {
        this._responseExtraInfoTracker.responseReceivedExtraInfo(event);
      }
      _onResponseReceived(event) {
        this._responseExtraInfoTracker.responseReceived(event);
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = this._createResponse(request, event.response);
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onLoadingFinished(event) {
        this._responseExtraInfoTracker.loadingFinished(event);
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          request.request.responseSize.transferSize = event.encodedDataLength;
          request.request.responseSize.encodedBodySize = event.encodedDataLength - request.request.responseSize.responseHeadersSize;
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onLoadingFailed(event) {
        this._responseExtraInfoTracker.loadingFailed(event);
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, !!event.canceled);
      }
      _maybeAdoptMainRequest(requestId) {
        if (!this._parentManager)
          return;
        const request = this._parentManager._requestIdToRequest.get(requestId);
        if (!request || request._documentId !== requestId)
          return;
        this._requestIdToRequest.set(requestId, request);
        this._parentManager._requestIdToRequest.delete(requestId);
        if (request._interceptionId && this._parentManager._attemptedAuthentications.has(request._interceptionId)) {
          this._parentManager._attemptedAuthentications.delete(request._interceptionId);
          this._attemptedAuthentications.add(request._interceptionId);
        }
        return request;
      }
    };
    exports.CRNetworkManager = CRNetworkManager;
    var InterceptableRequest = class {
      constructor(options2) {
        this.request = void 0;
        this._requestId = void 0;
        this._interceptionId = void 0;
        this._documentId = void 0;
        this._timestamp = void 0;
        this._wallTime = void 0;
        this._route = void 0;
        this._redirectedFrom = void 0;
        const {
          frame,
          documentId,
          route,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom
        } = options2;
        this._timestamp = requestWillBeSentEvent.timestamp;
        this._wallTime = requestWillBeSentEvent.wallTime;
        this._requestId = requestWillBeSentEvent.requestId;
        this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
        this._documentId = documentId;
        this._route = route;
        this._redirectedFrom = redirectedFrom;
        const {
          headers,
          method,
          url,
          postDataEntries = null
        } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
        const type = (requestWillBeSentEvent.type || "").toLowerCase();
        let postDataBuffer = null;
        if (postDataEntries && postDataEntries.length && postDataEntries[0].bytes)
          postDataBuffer = Buffer.from(postDataEntries[0].bytes, "base64");
        this.request = new network.Request(frame, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, url, type, method, postDataBuffer, (0, _utils.headersObjectToArray)(headers));
      }
      _routeForRedirectChain() {
        let request = this;
        while (request._redirectedFrom)
          request = request._redirectedFrom;
        return request._route;
      }
      wasFulfilled() {
        var _this$_routeForRedire;
        return ((_this$_routeForRedire = this._routeForRedirectChain()) === null || _this$_routeForRedire === void 0 ? void 0 : _this$_routeForRedire._wasFulfilled) || false;
      }
    };
    var RouteImpl = class {
      constructor(client, interceptionId) {
        this._client = void 0;
        this._interceptionId = void 0;
        this._wasFulfilled = false;
        this._client = client;
        this._interceptionId = interceptionId;
      }
      async continue(request, overrides) {
        await this._client._sendMayFail("Fetch.continueRequest", {
          requestId: this._interceptionId,
          url: overrides.url,
          headers: overrides.headers,
          method: overrides.method,
          postData: overrides.postData ? overrides.postData.toString("base64") : void 0
        });
      }
      async fulfill(response) {
        this._wasFulfilled = true;
        const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
        const responseHeaders = splitSetCookieHeader(response.headers);
        await this._client._sendMayFail("Fetch.fulfillRequest", {
          requestId: this._interceptionId,
          responseCode: response.status,
          responsePhrase: network.STATUS_TEXTS[String(response.status)],
          responseHeaders,
          body
        });
      }
      async abort(errorCode = "failed") {
        const errorReason = errorReasons[errorCode];
        (0, _utils.assert)(errorReason, "Unknown error code: " + errorCode);
        await this._client._sendMayFail("Fetch.failRequest", {
          requestId: this._interceptionId,
          errorReason
        });
      }
    };
    function splitSetCookieHeader(headers) {
      const index = headers.findIndex(({
        name
      }) => name.toLowerCase() === "set-cookie");
      if (index === -1)
        return headers;
      const header = headers[index];
      const values = header.value.split("\n");
      if (values.length === 1)
        return headers;
      const result = headers.slice();
      result.splice(index, 1, ...values.map((value) => ({
        name: header.name,
        value
      })));
      return result;
    }
    var errorReasons = {
      "aborted": "Aborted",
      "accessdenied": "AccessDenied",
      "addressunreachable": "AddressUnreachable",
      "blockedbyclient": "BlockedByClient",
      "blockedbyresponse": "BlockedByResponse",
      "connectionaborted": "ConnectionAborted",
      "connectionclosed": "ConnectionClosed",
      "connectionfailed": "ConnectionFailed",
      "connectionrefused": "ConnectionRefused",
      "connectionreset": "ConnectionReset",
      "internetdisconnected": "InternetDisconnected",
      "namenotresolved": "NameNotResolved",
      "timedout": "TimedOut",
      "failed": "Failed"
    };
    var ResponseExtraInfoTracker = class {
      constructor() {
        this._requests = new Map();
      }
      requestWillBeSent(event) {
        const info = this._requests.get(event.requestId);
        if (info && event.redirectResponse)
          this._innerResponseReceived(info, event.redirectResponse);
        else
          this._getOrCreateEntry(event.requestId);
      }
      requestWillBeSentExtraInfo(event) {
        const info = this._getOrCreateEntry(event.requestId);
        if (!info)
          return;
        info.requestWillBeSentExtraInfo.push(event);
        this._patchHeaders(info, info.requestWillBeSentExtraInfo.length - 1);
      }
      responseReceived(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        this._innerResponseReceived(info, event.response);
      }
      requestPaused(request, event) {
        request.setRawRequestHeaders((0, _utils.headersObjectToArray)(event.request.headers, "\n"));
      }
      _innerResponseReceived(info, response) {
        if (!response.connectionId) {
          info.sawResponseWithoutConnectionId = true;
        }
      }
      responseReceivedExtraInfo(event) {
        const info = this._getOrCreateEntry(event.requestId);
        info.responseReceivedExtraInfo.push(event);
        this._patchHeaders(info, info.responseReceivedExtraInfo.length - 1);
        this._checkFinished(info);
      }
      processResponse(requestId, response, wasFulfilled) {
        if (wasFulfilled) {
          this._stopTracking(requestId);
          return;
        }
        const info = this._requests.get(requestId);
        if (!info || info.sawResponseWithoutConnectionId)
          return;
        response.setWillReceiveExtraHeaders();
        info.responses.push(response);
        this._patchHeaders(info, info.responses.length - 1);
      }
      loadingFinished(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        info.loadingFinished = event;
        this._checkFinished(info);
      }
      loadingFailed(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        info.loadingFailed = event;
        this._checkFinished(info);
      }
      _getOrCreateEntry(requestId) {
        let info = this._requests.get(requestId);
        if (!info) {
          info = {
            requestId,
            requestWillBeSentExtraInfo: [],
            responseReceivedExtraInfo: [],
            responses: [],
            sawResponseWithoutConnectionId: false
          };
          this._requests.set(requestId, info);
        }
        return info;
      }
      _patchHeaders(info, index) {
        const response = info.responses[index];
        const requestExtraInfo = info.requestWillBeSentExtraInfo[index];
        if (response && requestExtraInfo)
          response.request().setRawRequestHeaders((0, _utils.headersObjectToArray)(requestExtraInfo.headers, "\n"));
        const responseExtraInfo = info.responseReceivedExtraInfo[index];
        if (response && responseExtraInfo) {
          var _responseExtraInfo$he;
          response.setRawResponseHeaders((0, _utils.headersObjectToArray)(responseExtraInfo.headers, "\n"));
          response.request().responseSize.responseHeadersSize = ((_responseExtraInfo$he = responseExtraInfo.headersText) === null || _responseExtraInfo$he === void 0 ? void 0 : _responseExtraInfo$he.length) || 0;
        }
      }
      _checkFinished(info) {
        if (!info.loadingFinished && !info.loadingFailed)
          return;
        if (info.responses.length <= info.responseReceivedExtraInfo.length) {
          this._stopTracking(info.requestId);
          return;
        }
      }
      _stopTracking(requestId) {
        this._requests.delete(requestId);
      }
    };
  }
});

// node_modules/playwright-core/lib/server/dialog.js
var require_dialog = __commonJS({
  "node_modules/playwright-core/lib/server/dialog.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Dialog = void 0;
    var _utils = require_utils();
    var _instrumentation = require_instrumentation();
    var Dialog = class extends _instrumentation.SdkObject {
      constructor(page, type, message, onHandle, defaultValue) {
        super(page, "dialog");
        this._page = void 0;
        this._type = void 0;
        this._message = void 0;
        this._onHandle = void 0;
        this._handled = false;
        this._defaultValue = void 0;
        this._page = page;
        this._type = type;
        this._message = message;
        this._onHandle = onHandle;
        this._defaultValue = defaultValue || "";
        this._page._frameManager.dialogDidOpen();
      }
      type() {
        return this._type;
      }
      message() {
        return this._message;
      }
      defaultValue() {
        return this._defaultValue;
      }
      async accept(promptText) {
        (0, _utils.assert)(!this._handled, "Cannot accept dialog which is already handled!");
        this._handled = true;
        this._page._frameManager.dialogWillClose();
        await this._onHandle(true, promptText);
      }
      async dismiss() {
        (0, _utils.assert)(!this._handled, "Cannot dismiss dialog which is already handled!");
        this._handled = true;
        this._page._frameManager.dialogWillClose();
        await this._onHandle(false);
      }
    };
    exports.Dialog = Dialog;
  }
});

// node_modules/playwright-core/lib/server/macEditingCommands.js
var require_macEditingCommands = __commonJS({
  "node_modules/playwright-core/lib/server/macEditingCommands.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.macEditingCommands = void 0;
    var macEditingCommands = {
      "Backspace": "deleteBackward:",
      "Enter": "insertNewline:",
      "NumpadEnter": "insertNewline:",
      "Escape": "cancelOperation:",
      "ArrowUp": "moveUp:",
      "ArrowDown": "moveDown:",
      "ArrowLeft": "moveLeft:",
      "ArrowRight": "moveRight:",
      "F5": "complete:",
      "Delete": "deleteForward:",
      "Home": "scrollToBeginningOfDocument:",
      "End": "scrollToEndOfDocument:",
      "PageUp": "scrollPageUp:",
      "PageDown": "scrollPageDown:",
      "Shift+Backspace": "deleteBackward:",
      "Shift+Enter": "insertNewline:",
      "Shift+NumpadEnter": "insertNewline:",
      "Shift+Escape": "cancelOperation:",
      "Shift+ArrowUp": "moveUpAndModifySelection:",
      "Shift+ArrowDown": "moveDownAndModifySelection:",
      "Shift+ArrowLeft": "moveLeftAndModifySelection:",
      "Shift+ArrowRight": "moveRightAndModifySelection:",
      "Shift+F5": "complete:",
      "Shift+Delete": "deleteForward:",
      "Shift+Home": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+End": "moveToEndOfDocumentAndModifySelection:",
      "Shift+PageUp": "pageUpAndModifySelection:",
      "Shift+PageDown": "pageDownAndModifySelection:",
      "Shift+Numpad5": "delete:",
      "Control+Tab": "selectNextKeyView:",
      "Control+Enter": "insertLineBreak:",
      "Control+NumpadEnter": "insertLineBreak:",
      "Control+Quote": "insertSingleQuoteIgnoringSubstitution:",
      "Control+KeyA": "moveToBeginningOfParagraph:",
      "Control+KeyB": "moveBackward:",
      "Control+KeyD": "deleteForward:",
      "Control+KeyE": "moveToEndOfParagraph:",
      "Control+KeyF": "moveForward:",
      "Control+KeyH": "deleteBackward:",
      "Control+KeyK": "deleteToEndOfParagraph:",
      "Control+KeyL": "centerSelectionInVisibleArea:",
      "Control+KeyN": "moveDown:",
      "Control+KeyO": ["insertNewlineIgnoringFieldEditor:", "moveBackward:"],
      "Control+KeyP": "moveUp:",
      "Control+KeyT": "transpose:",
      "Control+KeyV": "pageDown:",
      "Control+KeyY": "yank:",
      "Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Control+ArrowUp": "scrollPageUp:",
      "Control+ArrowDown": "scrollPageDown:",
      "Control+ArrowLeft": "moveToLeftEndOfLine:",
      "Control+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Control+Enter": "insertLineBreak:",
      "Shift+Control+NumpadEnter": "insertLineBreak:",
      "Shift+Control+Tab": "selectPreviousKeyView:",
      "Shift+Control+Quote": "insertDoubleQuoteIgnoringSubstitution:",
      "Shift+Control+KeyA": "moveToBeginningOfParagraphAndModifySelection:",
      "Shift+Control+KeyB": "moveBackwardAndModifySelection:",
      "Shift+Control+KeyE": "moveToEndOfParagraphAndModifySelection:",
      "Shift+Control+KeyF": "moveForwardAndModifySelection:",
      "Shift+Control+KeyN": "moveDownAndModifySelection:",
      "Shift+Control+KeyP": "moveUpAndModifySelection:",
      "Shift+Control+KeyV": "pageDownAndModifySelection:",
      "Shift+Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Shift+Control+ArrowUp": "scrollPageUp:",
      "Shift+Control+ArrowDown": "scrollPageDown:",
      "Shift+Control+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Control+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Alt+Backspace": "deleteWordBackward:",
      "Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Alt+Escape": "complete:",
      "Alt+ArrowUp": ["moveBackward:", "moveToBeginningOfParagraph:"],
      "Alt+ArrowDown": ["moveForward:", "moveToEndOfParagraph:"],
      "Alt+ArrowLeft": "moveWordLeft:",
      "Alt+ArrowRight": "moveWordRight:",
      "Alt+Delete": "deleteWordForward:",
      "Alt+PageUp": "pageUp:",
      "Alt+PageDown": "pageDown:",
      "Shift+Alt+Backspace": "deleteWordBackward:",
      "Shift+Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+Escape": "complete:",
      "Shift+Alt+ArrowUp": "moveParagraphBackwardAndModifySelection:",
      "Shift+Alt+ArrowDown": "moveParagraphForwardAndModifySelection:",
      "Shift+Alt+ArrowLeft": "moveWordLeftAndModifySelection:",
      "Shift+Alt+ArrowRight": "moveWordRightAndModifySelection:",
      "Shift+Alt+Delete": "deleteWordForward:",
      "Shift+Alt+PageUp": "pageUp:",
      "Shift+Alt+PageDown": "pageDown:",
      "Control+Alt+KeyB": "moveWordBackward:",
      "Control+Alt+KeyF": "moveWordForward:",
      "Control+Alt+Backspace": "deleteWordBackward:",
      "Shift+Control+Alt+KeyB": "moveWordBackwardAndModifySelection:",
      "Shift+Control+Alt+KeyF": "moveWordForwardAndModifySelection:",
      "Shift+Control+Alt+Backspace": "deleteWordBackward:",
      "Meta+NumpadSubtract": "cancel:",
      "Meta+Backspace": "deleteToBeginningOfLine:",
      "Meta+ArrowUp": "moveToBeginningOfDocument:",
      "Meta+ArrowDown": "moveToEndOfDocument:",
      "Meta+ArrowLeft": "moveToLeftEndOfLine:",
      "Meta+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Meta+NumpadSubtract": "cancel:",
      "Shift+Meta+Backspace": "deleteToBeginningOfLine:",
      "Shift+Meta+ArrowUp": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowDown": "moveToEndOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Meta+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Meta+KeyA": "selectAll:"
    };
    exports.macEditingCommands = macEditingCommands;
  }
});

// node_modules/playwright-core/lib/server/chromium/crInput.js
var require_crInput = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crInput.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;
    var input = _interopRequireWildcard(require_input());
    var _macEditingCommands = require_macEditingCommands();
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var RawKeyboardImpl = class {
      constructor(_client, _isMac, _dragManger) {
        this._client = _client;
        this._isMac = _isMac;
        this._dragManger = _dragManger;
      }
      _commandsForCode(code, modifiers) {
        if (!this._isMac)
          return [];
        const parts = [];
        for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
          if (modifiers.has(modifier))
            parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join("+");
        let commands = _macEditingCommands.macEditingCommands[shortcut] || [];
        if ((0, _utils.isString)(commands))
          commands = [commands];
        commands = commands.filter((x) => !x.startsWith("insert"));
        return commands.map((c) => c.substring(0, c.length - 1));
      }
      async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        if (code === "Escape" && await this._dragManger.cancelDrag())
          return;
        const commands = this._commandsForCode(code, modifiers);
        await this._client.send("Input.dispatchKeyEvent", {
          type: text ? "keyDown" : "rawKeyDown",
          modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
          windowsVirtualKeyCode: keyCodeWithoutLocation,
          code,
          commands,
          key,
          text,
          unmodifiedText: text,
          autoRepeat,
          location: location2,
          isKeypad: location2 === input.keypadLocation
        });
      }
      async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        await this._client.send("Input.dispatchKeyEvent", {
          type: "keyUp",
          modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
          key,
          windowsVirtualKeyCode: keyCodeWithoutLocation,
          code,
          location: location2
        });
      }
      async sendText(text) {
        await this._client.send("Input.insertText", {
          text
        });
      }
    };
    exports.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(page, client, dragManager) {
        this._client = void 0;
        this._page = void 0;
        this._dragManager = void 0;
        this._page = page;
        this._client = client;
        this._dragManager = dragManager;
      }
      async move(x, y, button, buttons, modifiers) {
        await this._dragManager.interceptDragCausedByMove(x, y, button, buttons, modifiers, async () => {
          await this._client.send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            button,
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
          });
        });
      }
      async down(x, y, button, buttons, modifiers, clickCount) {
        if (this._dragManager.isDragging())
          return;
        await this._client.send("Input.dispatchMouseEvent", {
          type: "mousePressed",
          button,
          x,
          y,
          modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
          clickCount
        });
      }
      async up(x, y, button, buttons, modifiers, clickCount) {
        if (this._dragManager.isDragging()) {
          await this._dragManager.drop(x, y, modifiers);
          return;
        }
        await this._client.send("Input.dispatchMouseEvent", {
          type: "mouseReleased",
          button,
          x,
          y,
          modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
          clickCount
        });
      }
      async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        await this._client.send("Input.dispatchMouseEvent", {
          type: "mouseWheel",
          x,
          y,
          modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
          deltaX,
          deltaY
        });
      }
    };
    exports.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      async tap(x, y, modifiers) {
        await Promise.all([this._client.send("Input.dispatchTouchEvent", {
          type: "touchStart",
          modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
          touchPoints: [{
            x,
            y
          }]
        }), this._client.send("Input.dispatchTouchEvent", {
          type: "touchEnd",
          modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
          touchPoints: []
        })]);
      }
    };
    exports.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/chromium/crAccessibility.js
var require_crAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crAccessibility.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getAccessibilityTree = getAccessibilityTree;
    async function getAccessibilityTree(client, needle) {
      const {
        nodes
      } = await client.send("Accessibility.getFullAXTree");
      const tree = CRAXNode.createTree(client, nodes);
      return {
        tree,
        needle: needle ? await tree._findElement(needle) : null
      };
    }
    var CRAXNode = class {
      constructor(client, payload) {
        this._payload = void 0;
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._hidden = false;
        this._name = void 0;
        this._role = void 0;
        this._cachedHasFocusableChild = void 0;
        this._client = void 0;
        this._client = client;
        this._payload = payload;
        this._name = this._payload.name ? this._payload.name.value : "";
        this._role = this._payload.role ? this._payload.role.value : "Unknown";
        for (const property of this._payload.properties || []) {
          if (property.name === "editable") {
            this._richlyEditable = property.value.value === "richtext";
            this._editable = true;
          }
          if (property.name === "focusable")
            this._focusable = property.value.value;
          if (property.name === "expanded")
            this._expanded = property.value.value;
          if (property.name === "hidden")
            this._hidden = property.value.value;
        }
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      async _findElement(element) {
        const objectId = element._objectId;
        const {
          node: {
            backendNodeId
          }
        } = await this._client.send("DOM.describeNode", {
          objectId
        });
        const needle = this.find((node) => node._payload.backendDOMNodeId === backendNodeId);
        return needle || null;
      }
      find(predicate) {
        if (predicate(this))
          return this;
        for (const child of this._children) {
          const result = child.find(predicate);
          if (result)
            return result;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "WebArea" && this._role !== "RootWebArea" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = this._role;
        if (role === "Ignored" || this._hidden)
          return false;
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name;
      }
      normalizedRole() {
        switch (this._role) {
          case "RootWebArea":
            return "WebArea";
          case "StaticText":
            return "text";
          default:
            return this._role;
        }
      }
      serialize() {
        const properties = new Map();
        for (const property of this._payload.properties || [])
          properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.description)
          properties.set("description", this._payload.description.value);
        const node = {
          role: this.normalizedRole(),
          name: this._payload.name ? this._payload.name.value || "" : ""
        };
        const userStringProperties = ["description", "keyshortcuts", "roledescription", "valuetext"];
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty))
            continue;
          node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._role === "WebArea" || this._role === "RootWebArea"))
            continue;
          const value = properties.get(booleanProperty);
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level", "valuemax", "valuemin"];
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty))
            continue;
          node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid", "orientation"];
        for (const tokenProperty of tokenProperties) {
          const value = properties.get(tokenProperty);
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        if (this._payload.value) {
          if (typeof this._payload.value.value === "string")
            axNode.valueString = this._payload.value.value;
          if (typeof this._payload.value.value === "number")
            axNode.valueNumber = this._payload.value.value;
        }
        if (properties.has("checked"))
          axNode.checked = properties.get("checked") === "true" ? "checked" : properties.get("checked") === "false" ? "unchecked" : "mixed";
        if (properties.has("pressed"))
          axNode.pressed = properties.get("pressed") === "true" ? "pressed" : properties.get("pressed") === "false" ? "released" : "mixed";
        return axNode;
      }
      static createTree(client, payloads) {
        const nodeById = new Map();
        for (const payload of payloads)
          nodeById.set(payload.nodeId, new CRAXNode(client, payload));
        for (const node of nodeById.values()) {
          for (const childId of node._payload.childIds || [])
            node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crCoverage.js
var require_crCoverage = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crCoverage.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CRCoverage = void 0;
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var CRCoverage = class {
      constructor(client) {
        this._jsCoverage = void 0;
        this._cssCoverage = void 0;
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
      }
      async startJSCoverage(options2) {
        return await this._jsCoverage.start(options2);
      }
      async stopJSCoverage() {
        return await this._jsCoverage.stop();
      }
      async startCSSCoverage(options2) {
        return await this._cssCoverage.start(options2);
      }
      async stopCSSCoverage() {
        return await this._cssCoverage.stop();
      }
    };
    exports.CRCoverage = CRCoverage;
    var JSCoverage = class {
      constructor(client) {
        this._client = void 0;
        this._enabled = void 0;
        this._scriptIds = void 0;
        this._scriptSources = void 0;
        this._eventListeners = void 0;
        this._resetOnNavigation = void 0;
        this._reportAnonymousScripts = false;
        this._client = client;
        this._enabled = false;
        this._scriptIds = new Set();
        this._scriptSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      async start(options2 = {}) {
        (0, _utils.assert)(!this._enabled, "JSCoverage is already enabled");
        const {
          resetOnNavigation = true,
          reportAnonymousScripts = false
        } = options2;
        this._resetOnNavigation = resetOnNavigation;
        this._reportAnonymousScripts = reportAnonymousScripts;
        this._enabled = true;
        this._scriptIds.clear();
        this._scriptSources.clear();
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Debugger.paused", this._onDebuggerPaused.bind(this))];
        await Promise.all([this._client.send("Profiler.enable"), this._client.send("Profiler.startPreciseCoverage", {
          callCount: true,
          detailed: true
        }), this._client.send("Debugger.enable"), this._client.send("Debugger.setSkipAllPauses", {
          skip: true
        })]);
      }
      _onDebuggerPaused() {
        this._client.send("Debugger.resume");
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._scriptIds.clear();
        this._scriptSources.clear();
      }
      async _onScriptParsed(event) {
        this._scriptIds.add(event.scriptId);
        if (!event.url && !this._reportAnonymousScripts)
          return;
        const response = await this._client._sendMayFail("Debugger.getScriptSource", {
          scriptId: event.scriptId
        });
        if (response)
          this._scriptSources.set(event.scriptId, response.scriptSource);
      }
      async stop() {
        (0, _utils.assert)(this._enabled, "JSCoverage is not enabled");
        this._enabled = false;
        const [profileResponse] = await Promise.all([this._client.send("Profiler.takePreciseCoverage"), this._client.send("Profiler.stopPreciseCoverage"), this._client.send("Profiler.disable"), this._client.send("Debugger.disable")]);
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        const coverage = [];
        for (const entry of profileResponse.result) {
          if (!this._scriptIds.has(entry.scriptId))
            continue;
          if (!entry.url && !this._reportAnonymousScripts)
            continue;
          const source = this._scriptSources.get(entry.scriptId);
          if (source)
            coverage.push(__spreadProps(__spreadValues({}, entry), {
              source
            }));
          else
            coverage.push(entry);
        }
        return coverage;
      }
    };
    var CSSCoverage = class {
      constructor(client) {
        this._client = void 0;
        this._enabled = void 0;
        this._stylesheetURLs = void 0;
        this._stylesheetSources = void 0;
        this._eventListeners = void 0;
        this._resetOnNavigation = void 0;
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = new Map();
        this._stylesheetSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      async start(options2 = {}) {
        (0, _utils.assert)(!this._enabled, "CSSCoverage is already enabled");
        const {
          resetOnNavigation = true
        } = options2;
        this._resetOnNavigation = resetOnNavigation;
        this._enabled = true;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))];
        await Promise.all([this._client.send("DOM.enable"), this._client.send("CSS.enable"), this._client.send("CSS.startRuleUsageTracking")]);
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
      }
      async _onStyleSheet(event) {
        const header = event.header;
        if (!header.sourceURL)
          return;
        const response = await this._client._sendMayFail("CSS.getStyleSheetText", {
          styleSheetId: header.styleSheetId
        });
        if (response) {
          this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
          this._stylesheetSources.set(header.styleSheetId, response.text);
        }
      }
      async stop() {
        (0, _utils.assert)(this._enabled, "CSSCoverage is not enabled");
        this._enabled = false;
        const ruleTrackingResponse = await this._client.send("CSS.stopRuleUsageTracking");
        await Promise.all([this._client.send("CSS.disable"), this._client.send("DOM.disable")]);
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
          let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
          if (!ranges) {
            ranges = [];
            styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
          }
          ranges.push({
            startOffset: entry.startOffset,
            endOffset: entry.endOffset,
            count: entry.used ? 1 : 0
          });
        }
        const coverage = [];
        for (const styleSheetId of this._stylesheetURLs.keys()) {
          const url = this._stylesheetURLs.get(styleSheetId);
          const text = this._stylesheetSources.get(styleSheetId);
          const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
          coverage.push({
            url,
            ranges,
            text
          });
        }
        return coverage;
      }
    };
    function convertToDisjointRanges(nestedRanges) {
      const points = [];
      for (const range of nestedRanges) {
        points.push({
          offset: range.startOffset,
          type: 0,
          range
        });
        points.push({
          offset: range.endOffset,
          type: 1,
          range
        });
      }
      points.sort((a, b) => {
        if (a.offset !== b.offset)
          return a.offset - b.offset;
        if (a.type !== b.type)
          return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0)
          return bLength - aLength;
        return aLength - bLength;
      });
      const hitCountStack = [];
      const results = [];
      let lastOffset = 0;
      for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
          const lastResult = results.length ? results[results.length - 1] : null;
          if (lastResult && lastResult.end === lastOffset)
            lastResult.end = point.offset;
          else
            results.push({
              start: lastOffset,
              end: point.offset
            });
        }
        lastOffset = point.offset;
        if (point.type === 0)
          hitCountStack.push(point.range.count);
        else
          hitCountStack.pop();
      }
      return results.filter((range) => range.end - range.start > 1);
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crPdf.js
var require_crPdf = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crPdf.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CRPDF = void 0;
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    var PagePaperFormats = {
      letter: {
        width: 8.5,
        height: 11
      },
      legal: {
        width: 8.5,
        height: 14
      },
      tabloid: {
        width: 11,
        height: 17
      },
      ledger: {
        width: 17,
        height: 11
      },
      a0: {
        width: 33.1,
        height: 46.8
      },
      a1: {
        width: 23.4,
        height: 33.1
      },
      a2: {
        width: 16.54,
        height: 23.4
      },
      a3: {
        width: 11.7,
        height: 16.54
      },
      a4: {
        width: 8.27,
        height: 11.7
      },
      a5: {
        width: 5.83,
        height: 8.27
      },
      a6: {
        width: 4.13,
        height: 5.83
      }
    };
    var unitToPixels = {
      "px": 1,
      "in": 96,
      "cm": 37.8,
      "mm": 3.78
    };
    function convertPrintParameterToInches(text) {
      if (text === void 0)
        return void 0;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unitToPixels.hasOwnProperty(unit)) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      (0, _utils.assert)(!isNaN(value), "Failed to parse parameter value: " + text);
      const pixels = value * unitToPixels[unit];
      return pixels / 96;
    }
    var CRPDF = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      async generate(options2 = {}) {
        const {
          scale = 1,
          displayHeaderFooter = false,
          headerTemplate = "",
          footerTemplate = "",
          printBackground = false,
          landscape = false,
          pageRanges = "",
          preferCSSPageSize = false,
          margin = {}
        } = options2;
        let paperWidth = 8.5;
        let paperHeight = 11;
        if (options2.format) {
          const format2 = PagePaperFormats[options2.format.toLowerCase()];
          (0, _utils.assert)(format2, "Unknown paper format: " + options2.format);
          paperWidth = format2.width;
          paperHeight = format2.height;
        } else {
          paperWidth = convertPrintParameterToInches(options2.width) || paperWidth;
          paperHeight = convertPrintParameterToInches(options2.height) || paperHeight;
        }
        const marginTop = convertPrintParameterToInches(margin.top) || 0;
        const marginLeft = convertPrintParameterToInches(margin.left) || 0;
        const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
        const marginRight = convertPrintParameterToInches(margin.right) || 0;
        const result = await this._client.send("Page.printToPDF", {
          transferMode: "ReturnAsStream",
          landscape,
          displayHeaderFooter,
          headerTemplate,
          footerTemplate,
          printBackground,
          scale,
          paperWidth,
          paperHeight,
          marginTop,
          marginBottom,
          marginLeft,
          marginRight,
          pageRanges,
          preferCSSPageSize
        });
        return await (0, _crProtocolHelper.readProtocolStream)(this._client, result.stream, null);
      }
    };
    exports.CRPDF = CRPDF;
  }
});

// node_modules/playwright-core/lib/utils/processLauncher.js
var require_processLauncher = __commonJS({
  "node_modules/playwright-core/lib/utils/processLauncher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.gracefullyCloseAll = gracefullyCloseAll;
    exports.launchProcess = launchProcess;
    exports.envArrayToObject = envArrayToObject;
    exports.gracefullyCloseSet = void 0;
    var childProcess = _interopRequireWildcard(__require("child_process"));
    var readline = _interopRequireWildcard(__require("readline"));
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var _rimraf = _interopRequireDefault(require_rimraf());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var gracefullyCloseSet = new Set();
    exports.gracefullyCloseSet = gracefullyCloseSet;
    async function gracefullyCloseAll() {
      await Promise.all(Array.from(gracefullyCloseSet).map((gracefullyClose) => gracefullyClose().catch((e) => {
      })));
    }
    var maxListeners = process.getMaxListeners();
    if (maxListeners !== 0)
      process.setMaxListeners(Math.max(maxListeners || 0, 100));
    async function launchProcess(options2) {
      const stdio = options2.stdio === "pipe" ? ["ignore", "pipe", "pipe", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
      options2.log(`<launching> ${options2.command} ${options2.args ? options2.args.join(" ") : ""}`);
      const spawnOptions = {
        detached: process.platform !== "win32",
        env: options2.env,
        cwd: options2.cwd,
        shell: options2.shell,
        stdio
      };
      const spawnedProcess = childProcess.spawn(options2.command, options2.args || [], spawnOptions);
      const cleanup = async () => {
        options2.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
        const errors2 = await (0, _utils.removeFolders)(options2.tempDirectories);
        for (let i = 0; i < options2.tempDirectories.length; ++i) {
          if (errors2[i])
            options2.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${options2.tempDirectories[i]}: ${errors2[i]}`);
        }
        options2.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
      };
      spawnedProcess.on("error", () => {
      });
      if (!spawnedProcess.pid) {
        let failed;
        const failedPromise = new Promise((f, r) => failed = f);
        spawnedProcess.once("error", (error2) => {
          failed(new Error("Failed to launch: " + error2));
        });
        return cleanup().then(() => failedPromise).then((e) => Promise.reject(e));
      }
      options2.log(`<launched> pid=${spawnedProcess.pid}`);
      const stdout = readline.createInterface({
        input: spawnedProcess.stdout
      });
      stdout.on("line", (data) => {
        options2.log(`[pid=${spawnedProcess.pid}][out] ` + data);
      });
      const stderr = readline.createInterface({
        input: spawnedProcess.stderr
      });
      stderr.on("line", (data) => {
        options2.log(`[pid=${spawnedProcess.pid}][err] ` + data);
      });
      let processClosed = false;
      let fulfillClose = () => {
      };
      const waitForClose = new Promise((f) => fulfillClose = f);
      let fulfillCleanup = () => {
      };
      const waitForCleanup = new Promise((f) => fulfillCleanup = f);
      spawnedProcess.once("exit", (exitCode, signal) => {
        options2.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);
        processClosed = true;
        _eventsHelper.eventsHelper.removeEventListeners(listeners);
        gracefullyCloseSet.delete(gracefullyClose);
        options2.onExit(exitCode, signal);
        fulfillClose();
        cleanup().then(fulfillCleanup);
      });
      const listeners = [_eventsHelper.eventsHelper.addEventListener(process, "exit", killProcessAndCleanup)];
      if (options2.handleSIGINT) {
        listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGINT", () => {
          gracefullyClose().then(() => {
            if ((0, _utils.isUnderTest)())
              setTimeout(() => process.exit(130), 0);
            else
              process.exit(130);
          });
        }));
      }
      if (options2.handleSIGTERM)
        listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGTERM", gracefullyClose));
      if (options2.handleSIGHUP)
        listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGHUP", gracefullyClose));
      gracefullyCloseSet.add(gracefullyClose);
      let gracefullyClosing = false;
      async function gracefullyClose() {
        gracefullyCloseSet.delete(gracefullyClose);
        if (gracefullyClosing) {
          options2.log(`[pid=${spawnedProcess.pid}] <forecefully close>`);
          killProcess();
          await waitForClose;
          return;
        }
        gracefullyClosing = true;
        options2.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
        await options2.attemptToGracefullyClose().catch(() => killProcess());
        await waitForCleanup;
        options2.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
      }
      function killProcess() {
        options2.log(`[pid=${spawnedProcess.pid}] <kill>`);
        _eventsHelper.eventsHelper.removeEventListeners(listeners);
        if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
          options2.log(`[pid=${spawnedProcess.pid}] <will force kill>`);
          try {
            if (process.platform === "win32") {
              const stdout2 = childProcess.execSync(`taskkill /pid ${spawnedProcess.pid} /T /F /FI "MEMUSAGE gt 0"`);
              options2.log(`[pid=${spawnedProcess.pid}] taskkill output: ${stdout2.toString()}`);
            } else {
              process.kill(-spawnedProcess.pid, "SIGKILL");
            }
          } catch (e) {
            options2.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);
          }
        } else {
          options2.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
        }
      }
      function killProcessAndCleanup() {
        killProcess();
        options2.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
        for (const dir of options2.tempDirectories) {
          try {
            _rimraf.default.sync(dir, {
              maxBusyTries: 10
            });
          } catch (e) {
            options2.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${dir}: ${e}`);
          }
        }
        options2.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
      }
      function killAndWait() {
        killProcess();
        return waitForCleanup;
      }
      return {
        launchedProcess: spawnedProcess,
        gracefullyClose,
        kill: killAndWait
      };
    }
    function envArrayToObject(env) {
      const result = {};
      for (const {
        name,
        value
      } of env)
        result[name] = value;
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/videoRecorder.js
var require_videoRecorder = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/videoRecorder.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VideoRecorder = void 0;
    var _utils = require_utils();
    var _page = require_page();
    var _processLauncher = require_processLauncher();
    var _progress = require_progress2();
    var _instrumentation = require_instrumentation();
    var fps = 25;
    var VideoRecorder = class {
      static async launch(page, ffmpegPath, options2) {
        if (!options2.outputFile.endsWith(".webm"))
          throw new Error("File must have .webm extension");
        const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), page);
        controller.setLogName("browser");
        return await controller.run(async (progress) => {
          const recorder = new VideoRecorder(page, ffmpegPath, progress);
          await recorder._launch(options2);
          return recorder;
        });
      }
      constructor(page, ffmpegPath, progress) {
        this._process = null;
        this._gracefullyClose = null;
        this._lastWritePromise = Promise.resolve();
        this._lastFrameTimestamp = 0;
        this._lastFrameBuffer = null;
        this._lastWriteTimestamp = 0;
        this._progress = void 0;
        this._frameQueue = [];
        this._isStopped = false;
        this._ffmpegPath = void 0;
        this._progress = progress;
        this._ffmpegPath = ffmpegPath;
        page.on(_page.Page.Events.ScreencastFrame, (frame) => this.writeFrame(frame.buffer, frame.timestamp));
      }
      async _launch(options2) {
        const w = options2.width;
        const h = options2.height;
        const args = `-loglevel error -f image2pipe -avioflags direct -fpsprobesize 0 -probesize 32 -analyzeduration 0 -c:v mjpeg -i - -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -speed 8 -b:v 1M -threads 1 -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(" ");
        args.push(options2.outputFile);
        const progress = this._progress;
        const {
          launchedProcess,
          gracefullyClose
        } = await (0, _processLauncher.launchProcess)({
          command: this._ffmpegPath,
          args,
          stdio: "stdin",
          log: (message) => progress.log(message),
          tempDirectories: [],
          attemptToGracefullyClose: async () => {
            progress.log("Closing stdin...");
            launchedProcess.stdin.end();
          },
          onExit: (exitCode, signal) => {
            progress.log(`ffmpeg onkill exitCode=${exitCode} signal=${signal}`);
          }
        });
        launchedProcess.stdin.on("finish", () => {
          progress.log("ffmpeg finished input.");
        });
        launchedProcess.stdin.on("error", () => {
          progress.log("ffmpeg error.");
        });
        this._process = launchedProcess;
        this._gracefullyClose = gracefullyClose;
      }
      writeFrame(frame, timestamp) {
        (0, _utils.assert)(this._process);
        if (this._isStopped)
          return;
        this._progress.log(`writing frame ` + timestamp);
        if (this._lastFrameBuffer) {
          const durationSec = timestamp - this._lastFrameTimestamp;
          const repeatCount = Math.max(1, Math.round(fps * durationSec));
          for (let i = 0; i < repeatCount; ++i)
            this._frameQueue.push(this._lastFrameBuffer);
          this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
        }
        this._lastFrameBuffer = frame;
        this._lastFrameTimestamp = timestamp;
        this._lastWriteTimestamp = (0, _utils.monotonicTime)();
      }
      async _sendFrames() {
        while (this._frameQueue.length)
          await this._sendFrame(this._frameQueue.shift());
      }
      async _sendFrame(frame) {
        return new Promise((f) => this._process.stdin.write(frame, f)).then((error2) => {
          if (error2)
            this._progress.log(`ffmpeg failed to write: ${error2}`);
        });
      }
      async stop() {
        if (this._isStopped)
          return;
        this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + ((0, _utils.monotonicTime)() - this._lastWriteTimestamp) / 1e3);
        this._isStopped = true;
        await this._lastWritePromise;
        await this._gracefullyClose();
      }
    };
    exports.VideoRecorder = VideoRecorder;
  }
});

// node_modules/playwright-core/lib/server/chromium/crDragDrop.js
var require_crDragDrop = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crDragDrop.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DragManager = void 0;
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    var DragManager = class {
      constructor(page) {
        this._crPage = void 0;
        this._dragState = null;
        this._lastPosition = {
          x: 0,
          y: 0
        };
        this._crPage = page;
      }
      async cancelDrag() {
        if (!this._dragState)
          return false;
        await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
          type: "dragCancel",
          x: this._lastPosition.x,
          y: this._lastPosition.y,
          data: {
            items: [],
            dragOperationsMask: 65535
          }
        });
        this._dragState = null;
        return true;
      }
      async interceptDragCausedByMove(x, y, button, buttons, modifiers, moveCallback) {
        this._lastPosition = {
          x,
          y
        };
        if (this._dragState) {
          await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
            type: "dragOver",
            x,
            y,
            data: this._dragState,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
          });
          return;
        }
        if (button !== "left")
          return moveCallback();
        const client = this._crPage._mainFrameSession._client;
        let onDragIntercepted;
        const dragInterceptedPromise = new Promise((x2) => onDragIntercepted = x2);
        await Promise.all(this._crPage._page.frames().map(async (frame) => {
          await frame.nonStallingEvaluateInExistingContext(function() {
            let didStartDrag = Promise.resolve(false);
            let dragEvent = null;
            const dragListener = (event) => dragEvent = event;
            const mouseListener = () => {
              didStartDrag = new Promise((callback) => {
                window.addEventListener("dragstart", dragListener, {
                  once: true,
                  capture: true
                });
                setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);
              });
            };
            window.addEventListener("mousemove", mouseListener, {
              once: true,
              capture: true
            });
            window.__cleanupDrag = async () => {
              const val = await didStartDrag;
              window.removeEventListener("mousemove", mouseListener, {
                capture: true
              });
              window.removeEventListener("dragstart", dragListener, {
                capture: true
              });
              return val;
            };
          }.toString(), true, "utility").catch(() => {
          });
        }));
        client.on("Input.dragIntercepted", onDragIntercepted);
        try {
          await client.send("Input.setInterceptDrags", {
            enabled: true
          });
        } catch {
          client.off("Input.dragIntercepted", onDragIntercepted);
          return moveCallback();
        }
        await moveCallback();
        const expectingDrag = (await Promise.all(this._crPage._page.frames().map(async (frame) => {
          return frame.nonStallingEvaluateInExistingContext("window.__cleanupDrag && window.__cleanupDrag()", false, "utility").catch(() => false);
        }))).some((x2) => x2);
        this._dragState = expectingDrag ? (await dragInterceptedPromise).data : null;
        client.off("Input.dragIntercepted", onDragIntercepted);
        await client.send("Input.setInterceptDrags", {
          enabled: false
        });
        if (this._dragState) {
          await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
            type: "dragEnter",
            x,
            y,
            data: this._dragState,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
          });
        }
      }
      isDragging() {
        return !!this._dragState;
      }
      async drop(x, y, modifiers) {
        (0, _utils.assert)(this._dragState, "missing drag state");
        await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
          type: "drop",
          x,
          y,
          data: this._dragState,
          modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
        });
        this._dragState = null;
      }
    };
    exports.DragManager = DragManager;
  }
});

// node_modules/playwright-core/lib/server/chromium/crPage.js
var require_crPage = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crPage.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CRPage = void 0;
    var dom = _interopRequireWildcard(require_dom());
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network());
    var _crConnection = require_crConnection();
    var _crExecutionContext = require_crExecutionContext();
    var _crNetworkManager = require_crNetworkManager();
    var _page = require_page();
    var _crProtocolHelper = require_crProtocolHelper();
    var dialog = _interopRequireWildcard(require_dialog());
    var _path = _interopRequireDefault(__require("path"));
    var _crInput = require_crInput();
    var _crAccessibility = require_crAccessibility();
    var _crCoverage = require_crCoverage();
    var _crPdf = require_crPdf();
    var _crBrowser = require_crBrowser();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var _videoRecorder = require_videoRecorder();
    var _crDragDrop = require_crDragDrop();
    var _registry = require_registry();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var CRPage = class {
      static mainFrameSession(page) {
        const crPage = page._delegate;
        return crPage._mainFrameSession;
      }
      constructor(client, targetId, browserContext, opener, hasUIWindow, isBackgroundPage) {
        this._mainFrameSession = void 0;
        this._sessions = new Map();
        this._page = void 0;
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._targetId = void 0;
        this._opener = void 0;
        this._pdf = void 0;
        this._coverage = void 0;
        this._browserContext = void 0;
        this._pagePromise = void 0;
        this._initializedPage = null;
        this._isBackgroundPage = void 0;
        this._nextWindowOpenPopupFeatures = [];
        this._targetId = targetId;
        this._opener = opener;
        this._isBackgroundPage = isBackgroundPage;
        const dragManager = new _crDragDrop.DragManager(this);
        this.rawKeyboard = new _crInput.RawKeyboardImpl(client, browserContext._browser._isMac, dragManager);
        this.rawMouse = new _crInput.RawMouseImpl(this, client, dragManager);
        this.rawTouchscreen = new _crInput.RawTouchscreenImpl(client);
        this._pdf = new _crPdf.CRPDF(client);
        this._coverage = new _crCoverage.CRCoverage(client);
        this._browserContext = browserContext;
        this._page = new _page.Page(this, browserContext);
        this._mainFrameSession = new FrameSession(this, client, targetId, null);
        this._sessions.set(targetId, this._mainFrameSession);
        client.once(_crConnection.CRSessionEvents.Disconnected, () => this._page._didDisconnect());
        if (opener && !browserContext._options.noDefaultViewport) {
          const features = opener._nextWindowOpenPopupFeatures.shift() || [];
          const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(features);
          if (viewportSize)
            this._page._state.emulatedSize = {
              viewport: viewportSize,
              screen: viewportSize
            };
        }
        this._pagePromise = this._mainFrameSession._initialize(hasUIWindow).then(async (r) => {
          await this._page.initOpener(this._opener);
          return r;
        }).catch(async (e) => {
          await this._page.initOpener(this._opener);
          throw e;
        }).then(() => {
          this._initializedPage = this._page;
          this._reportAsNew();
          return this._page;
        }).catch((e) => {
          this._reportAsNew(e);
          return e;
        });
      }
      _reportAsNew(error2) {
        if (this._isBackgroundPage) {
          if (!error2)
            this._browserContext.emit(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, this._page);
        } else {
          this._page.reportAsNew(error2);
        }
      }
      async _forAllFrameSessions(cb) {
        const frameSessions = Array.from(this._sessions.values());
        await Promise.all(frameSessions.map((frameSession) => {
          if (frameSession._isMainFrame())
            return cb(frameSession);
          return cb(frameSession).catch((e) => {
            if (e.message && (e.message.includes("Target closed.") || e.message.includes("Session closed.")))
              return;
            throw e;
          });
        }));
      }
      _sessionForFrame(frame) {
        while (!this._sessions.has(frame._id)) {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error(`Frame has been detached.`);
          frame = parent;
        }
        return this._sessions.get(frame._id);
      }
      _sessionForHandle(handle) {
        const frame = handle._context.frame;
        return this._sessionForFrame(frame);
      }
      willBeginDownload() {
        this._mainFrameSession._willBeginDownload();
      }
      async pageOrError() {
        return this._pagePromise;
      }
      didClose() {
        for (const session of this._sessions.values())
          session.dispose();
        this._page._didClose();
      }
      async navigateFrame(frame, url, referrer) {
        return this._sessionForFrame(frame)._navigate(frame, url, referrer);
      }
      async exposeBinding(binding) {
        await this._forAllFrameSessions((frame) => frame._initBinding(binding));
        await Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(binding.source, false, {}).catch((e) => {
        })));
      }
      async updateExtraHTTPHeaders() {
        await this._forAllFrameSessions((frame) => frame._updateExtraHTTPHeaders(false));
      }
      async updateGeolocation() {
        await this._forAllFrameSessions((frame) => frame._updateGeolocation(false));
      }
      async updateOffline() {
        await this._forAllFrameSessions((frame) => frame._updateOffline(false));
      }
      async updateHttpCredentials() {
        await this._forAllFrameSessions((frame) => frame._updateHttpCredentials(false));
      }
      async setEmulatedSize(emulatedSize) {
        (0, _utils.assert)(this._page._state.emulatedSize === emulatedSize);
        await this._mainFrameSession._updateViewport();
      }
      async bringToFront() {
        await this._mainFrameSession._client.send("Page.bringToFront");
      }
      async updateEmulateMedia() {
        await this._forAllFrameSessions((frame) => frame._updateEmulateMedia(false));
      }
      async updateRequestInterception() {
        await this._forAllFrameSessions((frame) => frame._updateRequestInterception());
      }
      async setFileChooserIntercepted(enabled) {
        await this._forAllFrameSessions((frame) => frame._setFileChooserIntercepted(enabled));
      }
      async reload() {
        await this._mainFrameSession._client.send("Page.reload");
      }
      async _go(delta) {
        const history = await this._mainFrameSession._client.send("Page.getNavigationHistory");
        const entry = history.entries[history.currentIndex + delta];
        if (!entry)
          return false;
        await this._mainFrameSession._client.send("Page.navigateToHistoryEntry", {
          entryId: entry.id
        });
        return true;
      }
      goBack() {
        return this._go(-1);
      }
      goForward() {
        return this._go(1);
      }
      async evaluateOnNewDocument(source, world = "main") {
        await this._forAllFrameSessions((frame) => frame._evaluateOnNewDocument(source, world));
      }
      async closePage(runBeforeUnload) {
        if (runBeforeUnload)
          await this._mainFrameSession._client.send("Page.close");
        else
          await this._browserContext._browser._closePage(this);
      }
      canScreenshotOutsideViewport() {
        return false;
      }
      async setBackgroundColor(color) {
        await this._mainFrameSession._client.send("Emulation.setDefaultBackgroundColorOverride", {
          color
        });
      }
      async takeScreenshot(progress, format2, documentRect, viewportRect, quality) {
        const {
          visualViewport
        } = await this._mainFrameSession._client.send("Page.getLayoutMetrics");
        if (!documentRect) {
          documentRect = __spreadValues({
            x: visualViewport.pageX + viewportRect.x,
            y: visualViewport.pageY + viewportRect.y
          }, _helper.helper.enclosingIntSize({
            width: viewportRect.width / visualViewport.scale,
            height: viewportRect.height / visualViewport.scale
          }));
        }
        const clip = __spreadProps(__spreadValues({}, documentRect), {
          scale: viewportRect ? visualViewport.scale : 1
        });
        progress.throwIfAborted();
        const result = await this._mainFrameSession._client.send("Page.captureScreenshot", {
          format: format2,
          quality,
          clip
        });
        return Buffer.from(result.data, "base64");
      }
      async resetViewport() {
        await this._mainFrameSession._client.send("Emulation.setDeviceMetricsOverride", {
          mobile: false,
          width: 0,
          height: 0,
          deviceScaleFactor: 0
        });
      }
      async getContentFrame(handle) {
        return this._sessionForHandle(handle)._getContentFrame(handle);
      }
      async getOwnerFrame(handle) {
        return this._sessionForHandle(handle)._getOwnerFrame(handle);
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      async getBoundingBox(handle) {
        return this._sessionForHandle(handle)._getBoundingBox(handle);
      }
      async scrollRectIntoViewIfNeeded(handle, rect) {
        return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
      }
      async setScreencastOptions(options2) {
        if (options2) {
          await this._mainFrameSession._startScreencast(this, {
            format: "jpeg",
            quality: options2.quality,
            maxWidth: options2.width,
            maxHeight: options2.height
          });
        } else {
          await this._mainFrameSession._stopScreencast(this);
        }
      }
      rafCountForStablePosition() {
        return 1;
      }
      async getContentQuads(handle) {
        return this._sessionForHandle(handle)._getContentQuads(handle);
      }
      async setInputFiles(handle, files) {
        await handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
      }
      async adoptElementHandle(handle, to) {
        return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
      }
      async getAccessibilityTree(needle) {
        return (0, _crAccessibility.getAccessibilityTree)(this._mainFrameSession._client, needle);
      }
      async inputActionEpilogue() {
        await this._mainFrameSession._client.send("Page.enable").catch((e) => {
        });
      }
      async pdf(options2) {
        return this._pdf.generate(options2);
      }
      coverage() {
        return this._coverage;
      }
      async getFrameElement(frame) {
        let parent = frame.parentFrame();
        if (!parent)
          throw new Error("Frame has been detached.");
        const parentSession = this._sessionForFrame(parent);
        const {
          backendNodeId
        } = await parentSession._client.send("DOM.getFrameOwner", {
          frameId: frame._id
        }).catch((e) => {
          if (e instanceof Error && e.message.includes("Frame with the given id was not found."))
            (0, _stackTrace.rewriteErrorMessage)(e, "Frame has been detached.");
          throw e;
        });
        parent = frame.parentFrame();
        if (!parent)
          throw new Error("Frame has been detached.");
        return parentSession._adoptBackendNodeId(backendNodeId, await parent._mainContext());
      }
    };
    exports.CRPage = CRPage;
    var FrameSession = class {
      constructor(crPage, client, targetId, parentSession) {
        this._client = void 0;
        this._crPage = void 0;
        this._page = void 0;
        this._networkManager = void 0;
        this._contextIdToContext = new Map();
        this._eventListeners = [];
        this._targetId = void 0;
        this._firstNonInitialNavigationCommittedPromise = void 0;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._windowId = void 0;
        this._swappedIn = false;
        this._videoRecorder = null;
        this._screencastId = null;
        this._screencastClients = new Set();
        this._client = client;
        this._crPage = crPage;
        this._page = crPage._page;
        this._targetId = targetId;
        this._networkManager = new _crNetworkManager.CRNetworkManager(client, this._page, parentSession ? parentSession._networkManager : null);
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        client.once(_crConnection.CRSessionEvents.Disconnected, () => {
          this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
        });
      }
      _isMainFrame() {
        return this._targetId === this._crPage._targetId;
      }
      _addRendererListeners() {
        this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, "Log.entryAdded", (event) => this._onLogEntryAdded(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId, event.reason)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameRequestedNavigation", (event) => this._onFrameRequestedNavigation(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.javascriptDialogOpening", (event) => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.bindingCalled", (event) => this._onBindingCalled(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared()), _eventsHelper.eventsHelper.addEventListener(this._client, "Target.attachedToTarget", (event) => this._onAttachedToTarget(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Target.detachedFromTarget", (event) => this._onDetachedFromTarget(event))]);
      }
      _addBrowserListeners() {
        this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, "Inspector.targetCrashed", (event) => this._onTargetCrashed()), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.screencastFrame", (event) => this._onScreencastFrame(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.windowOpen", (event) => this._onWindowOpen(event))]);
      }
      async _initialize(hasUIWindow) {
        if (hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {
          const {
            windowId
          } = await this._client.send("Browser.getWindowForTarget");
          this._windowId = windowId;
        }
        let screencastOptions;
        if (this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
          const screencastId = (0, _utils.createGuid)();
          const outputFile = _path.default.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + ".webm");
          screencastOptions = __spreadProps(__spreadValues({}, this._crPage._browserContext._options.recordVideo.size), {
            outputFile
          });
          await this._crPage._browserContext._ensureVideosPath();
          await this._createVideoRecorder(screencastId, screencastOptions);
          this._crPage.pageOrError().then((p) => {
            if (p instanceof Error)
              this._stopVideoRecording().catch(() => {
              });
          });
        }
        let lifecycleEventsEnabled;
        if (!this._isMainFrame())
          this._addRendererListeners();
        this._addBrowserListeners();
        const promises = [this._client.send("Page.enable"), this._client.send("Page.getFrameTree").then(({
          frameTree
        }) => {
          if (this._isMainFrame()) {
            this._handleFrameTree(frameTree);
            this._addRendererListeners();
          }
          const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];
          for (const frame of localFrames) {
            this._client._sendMayFail("Page.createIsolatedWorld", {
              frameId: frame._id,
              grantUniveralAccess: true,
              worldName: UTILITY_WORLD_NAME
            });
            for (const binding of this._crPage._browserContext._pageBindings.values())
              frame.evaluateExpression(binding.source, false, void 0).catch((e) => {
              });
            for (const source of this._crPage._browserContext._evaluateOnNewDocumentSources)
              frame.evaluateExpression(source, false, void 0, "main").catch((e) => {
              });
          }
          const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ":";
          if (isInitialEmptyPage) {
            lifecycleEventsEnabled.catch((e) => {
            }).then(() => {
              this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
            });
          } else {
            this._firstNonInitialNavigationCommittedFulfill();
            this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
          }
        }), this._client.send("Log.enable", {}), lifecycleEventsEnabled = this._client.send("Page.setLifecycleEventsEnabled", {
          enabled: true
        }), this._client.send("Runtime.enable", {}), this._client.send("Page.addScriptToEvaluateOnNewDocument", {
          source: "",
          worldName: UTILITY_WORLD_NAME
        }), this._networkManager.initialize(), this._client.send("Target.setAutoAttach", {
          autoAttach: true,
          waitForDebuggerOnStart: true,
          flatten: true
        })];
        if (this._isMainFrame())
          promises.push(this._client.send("Emulation.setFocusEmulationEnabled", {
            enabled: true
          }));
        const options2 = this._crPage._browserContext._options;
        if (options2.bypassCSP)
          promises.push(this._client.send("Page.setBypassCSP", {
            enabled: true
          }));
        if (options2.ignoreHTTPSErrors)
          promises.push(this._client.send("Security.setIgnoreCertificateErrors", {
            ignore: true
          }));
        if (this._isMainFrame())
          promises.push(this._updateViewport());
        if (options2.hasTouch)
          promises.push(this._client.send("Emulation.setTouchEmulationEnabled", {
            enabled: true
          }));
        if (options2.javaScriptEnabled === false)
          promises.push(this._client.send("Emulation.setScriptExecutionDisabled", {
            value: true
          }));
        if (options2.userAgent || options2.locale)
          promises.push(this._client.send("Emulation.setUserAgentOverride", {
            userAgent: options2.userAgent || "",
            acceptLanguage: options2.locale
          }));
        if (options2.locale)
          promises.push(emulateLocale(this._client, options2.locale));
        if (options2.timezoneId)
          promises.push(emulateTimezone(this._client, options2.timezoneId));
        promises.push(this._updateGeolocation(true));
        promises.push(this._updateExtraHTTPHeaders(true));
        promises.push(this._updateRequestInterception());
        promises.push(this._updateOffline(true));
        promises.push(this._updateHttpCredentials(true));
        promises.push(this._updateEmulateMedia(true));
        for (const binding of this._crPage._page.allBindings())
          promises.push(this._initBinding(binding));
        for (const source of this._crPage._browserContext._evaluateOnNewDocumentSources)
          promises.push(this._evaluateOnNewDocument(source, "main"));
        for (const source of this._crPage._page._evaluateOnNewDocumentSources)
          promises.push(this._evaluateOnNewDocument(source, "main"));
        if (screencastOptions)
          promises.push(this._startVideoRecording(screencastOptions));
        promises.push(this._client.send("Runtime.runIfWaitingForDebugger"));
        promises.push(this._firstNonInitialNavigationCommittedPromise);
        await Promise.all(promises);
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._crPage._sessions.delete(this._targetId);
      }
      async _navigate(frame, url, referrer) {
        const response = await this._client.send("Page.navigate", {
          url,
          referrer,
          frameId: frame._id
        });
        if (response.errorText)
          throw new Error(`${response.errorText} at ${url}`);
        return {
          newDocumentId: response.loaderId
        };
      }
      _onLifecycleEvent(event) {
        if (this._eventBelongsToStaleFrame(event.frameId))
          return;
        if (event.name === "load")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "load");
        else if (event.name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded");
      }
      _onFrameStoppedLoading(frameId) {
        if (this._eventBelongsToStaleFrame(frameId))
          return;
        this._page._frameManager.frameStoppedLoading(frameId);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _eventBelongsToStaleFrame(frameId) {
        const frame = this._page._frameManager.frame(frameId);
        if (!frame)
          return true;
        const session = this._crPage._sessionForFrame(frame);
        return session && session !== this && !session._swappedIn;
      }
      _onFrameAttached(frameId, parentFrameId) {
        const frameSession = this._crPage._sessions.get(frameId);
        if (frameSession && frameId !== this._targetId) {
          frameSession._swappedIn = true;
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {
          return;
        }
        this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        if (this._eventBelongsToStaleFrame(framePayload.id))
          return;
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ""), framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameRequestedNavigation(payload) {
        if (this._eventBelongsToStaleFrame(payload.frameId))
          return;
        if (payload.disposition === "currentTab")
          this._page._frameManager.frameRequestedNavigation(payload.frameId);
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        if (this._eventBelongsToStaleFrame(frameId))
          return;
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId, reason) {
        if (this._crPage._sessions.has(frameId)) {
          return;
        }
        if (reason === "swap") {
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        this._page._frameManager.frameDetached(frameId);
      }
      _onExecutionContextCreated(contextPayload) {
        const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
        if (!frame || this._eventBelongsToStaleFrame(frame._id))
          return;
        const delegate = new _crExecutionContext.CRExecutionContext(this._client, contextPayload);
        let worldName = null;
        if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
          worldName = "main";
        else if (contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(contextPayload.id, context);
      }
      _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _onExecutionContextsCleared() {
        for (const contextId of Array.from(this._contextIdToContext.keys()))
          this._onExecutionContextDestroyed(contextId);
      }
      _onAttachedToTarget(event) {
        const session = _crConnection.CRConnection.fromSession(this._client).session(event.sessionId);
        if (event.targetInfo.type === "iframe") {
          const targetId = event.targetInfo.targetId;
          const frame = this._page._frameManager.frame(targetId);
          if (!frame)
            return;
          this._page._frameManager.removeChildFramesRecursively(frame);
          const frameSession = new FrameSession(this._crPage, session, targetId, this);
          this._crPage._sessions.set(targetId, frameSession);
          frameSession._initialize(false).catch((e) => e);
          return;
        }
        if (event.targetInfo.type !== "worker") {
          session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
            this._client._sendMayFail("Target.detachFromTarget", {
              sessionId: event.sessionId
            });
          });
          return;
        }
        const url = event.targetInfo.url;
        const worker = new _page.Worker(this._page, url);
        this._page._addWorker(event.sessionId, worker);
        session.once("Runtime.executionContextCreated", async (event2) => {
          worker._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event2.context));
        });
        session._sendMayFail("Runtime.enable");
        session._sendMayFail("Network.enable");
        session._sendMayFail("Runtime.runIfWaitingForDebugger");
        session.on("Runtime.consoleAPICalled", (event2) => {
          const args = event2.args.map((o) => worker._existingExecutionContext.createHandle(o));
          this._page._addConsoleMessage(event2.type, args, (0, _crProtocolHelper.toConsoleMessageLocation)(event2.stackTrace));
        });
        session.on("Runtime.exceptionThrown", (exception) => this._page.emit(_page.Page.Events.PageError, (0, _crProtocolHelper.exceptionToError)(exception.exceptionDetails)));
        this._networkManager.instrumentNetworkEvents(session, this._page._frameManager.frame(this._targetId));
      }
      _onDetachedFromTarget(event) {
        this._page._removeWorker(event.sessionId);
        const childFrameSession = this._crPage._sessions.get(event.targetId);
        if (!childFrameSession)
          return;
        if (childFrameSession._swappedIn) {
          childFrameSession.dispose();
          return;
        }
        this._client.send("Page.enable").catch((e) => null).then(() => {
          if (!childFrameSession._swappedIn)
            this._page._frameManager.frameDetached(event.targetId);
          childFrameSession.dispose();
        });
      }
      _onWindowOpen(event) {
        this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
      }
      async _onConsoleAPI(event) {
        if (event.executionContextId === 0) {
          return;
        }
        const context = this._contextIdToContext.get(event.executionContextId);
        if (!context)
          return;
        const values = event.args.map((arg) => context.createHandle(arg));
        this._page._addConsoleMessage(event.type, values, (0, _crProtocolHelper.toConsoleMessageLocation)(event.stackTrace));
      }
      async _initBinding(binding) {
        await Promise.all([this._client.send("Runtime.addBinding", {
          name: binding.name
        }), this._client.send("Page.addScriptToEvaluateOnNewDocument", {
          source: binding.source
        })]);
      }
      async _onBindingCalled(event) {
        const pageOrError = await this._crPage.pageOrError();
        if (!(pageOrError instanceof Error)) {
          const context = this._contextIdToContext.get(event.executionContextId);
          if (context)
            await this._page._onBindingCalled(event.payload, context);
        }
      }
      _onDialog(event) {
        if (!this._page._frameManager.frame(this._targetId))
          return;
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {
          await this._client.send("Page.handleJavaScriptDialog", {
            accept,
            promptText
          });
        }, event.defaultPrompt));
      }
      _handleException(exceptionDetails) {
        this._page.firePageError((0, _crProtocolHelper.exceptionToError)(exceptionDetails));
      }
      async _onTargetCrashed() {
        this._client._markAsCrashed();
        this._page._didCrash();
      }
      _onLogEntryAdded(event) {
        const {
          level,
          text,
          args,
          source,
          url,
          lineNumber
        } = event.entry;
        if (args)
          args.map((arg) => (0, _crProtocolHelper.releaseObject)(this._client, arg.objectId));
        if (source !== "worker") {
          const location2 = {
            url: url || "",
            lineNumber: lineNumber || 0,
            columnNumber: 0
          };
          this._page._addConsoleMessage(level, [], location2, text);
        }
      }
      async _onFileChooserOpened(event) {
        const frame = this._page._frameManager.frame(event.frameId);
        if (!frame)
          return;
        let handle;
        try {
          const utilityContext = await frame._utilityContext();
          handle = await this._adoptBackendNodeId(event.backendNodeId, utilityContext);
        } catch (e) {
          return;
        }
        await this._page._onFileChooserOpened(handle);
      }
      _willBeginDownload() {
        const originPage = this._crPage._initializedPage;
        if (!originPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
        }
      }
      _onScreencastFrame(payload) {
        this._page.throttleScreencastFrameAck(() => {
          this._client.send("Page.screencastFrameAck", {
            sessionId: payload.sessionId
          }).catch(() => {
          });
        });
        const buffer = Buffer.from(payload.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          timestamp: payload.metadata.timestamp,
          width: payload.metadata.deviceWidth,
          height: payload.metadata.deviceHeight
        });
      }
      async _createVideoRecorder(screencastId, options2) {
        (0, _utils.assert)(!this._screencastId);
        const ffmpegPath = _registry.registry.findExecutable("ffmpeg").executablePathOrDie(this._page._browserContext._browser.options.sdkLanguage);
        this._videoRecorder = await _videoRecorder.VideoRecorder.launch(this._crPage._page, ffmpegPath, options2);
        this._screencastId = screencastId;
      }
      async _startVideoRecording(options2) {
        const screencastId = this._screencastId;
        (0, _utils.assert)(screencastId);
        this._page.once(_page.Page.Events.Close, () => this._stopVideoRecording().catch(() => {
        }));
        const gotFirstFrame = new Promise((f) => this._client.once("Page.screencastFrame", f));
        await this._startScreencast(this._videoRecorder, {
          format: "jpeg",
          quality: 90,
          maxWidth: options2.width,
          maxHeight: options2.height
        });
        gotFirstFrame.then(() => {
          this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options2.outputFile, this._crPage.pageOrError());
        });
      }
      async _stopVideoRecording() {
        if (!this._screencastId)
          return;
        const screencastId = this._screencastId;
        this._screencastId = null;
        const recorder = this._videoRecorder;
        this._videoRecorder = null;
        await this._stopScreencast(recorder);
        await recorder.stop().catch(() => {
        });
        const video = this._crPage._browserContext._browser._takeVideo(screencastId);
        video === null || video === void 0 ? void 0 : video.reportFinished();
      }
      async _startScreencast(client, options2 = {}) {
        this._screencastClients.add(client);
        if (this._screencastClients.size === 1)
          await this._client.send("Page.startScreencast", options2);
      }
      async _stopScreencast(client) {
        this._screencastClients.delete(client);
        if (!this._screencastClients.size)
          await this._client._sendMayFail("Page.stopScreencast");
      }
      async _updateExtraHTTPHeaders(initial) {
        const headers = network.mergeHeaders([this._crPage._browserContext._options.extraHTTPHeaders, this._page._state.extraHTTPHeaders]);
        if (!initial || headers.length)
          await this._client.send("Network.setExtraHTTPHeaders", {
            headers: (0, _utils.headersArrayToObject)(headers, false)
          });
      }
      async _updateGeolocation(initial) {
        const geolocation = this._crPage._browserContext._options.geolocation;
        if (!initial || geolocation)
          await this._client.send("Emulation.setGeolocationOverride", geolocation || {});
      }
      async _updateOffline(initial) {
        const offline = !!this._crPage._browserContext._options.offline;
        if (!initial || offline)
          await this._networkManager.setOffline(offline);
      }
      async _updateHttpCredentials(initial) {
        const credentials = this._crPage._browserContext._options.httpCredentials || null;
        if (!initial || credentials)
          await this._networkManager.authenticate(credentials);
      }
      async _updateViewport() {
        if (this._crPage._browserContext._browser.isClank())
          return;
        (0, _utils.assert)(this._isMainFrame());
        const options2 = this._crPage._browserContext._options;
        const emulatedSize = this._page._state.emulatedSize;
        if (emulatedSize === null)
          return;
        const viewportSize = emulatedSize.viewport;
        const screenSize = emulatedSize.screen;
        const isLandscape = viewportSize.width > viewportSize.height;
        const promises = [this._client.send("Emulation.setDeviceMetricsOverride", {
          mobile: !!options2.isMobile,
          width: viewportSize.width,
          height: viewportSize.height,
          screenWidth: screenSize.width,
          screenHeight: screenSize.height,
          deviceScaleFactor: options2.deviceScaleFactor || 1,
          screenOrientation: isLandscape ? {
            angle: 90,
            type: "landscapePrimary"
          } : {
            angle: 0,
            type: "portraitPrimary"
          }
        })];
        if (this._windowId) {
          let insets = {
            width: 0,
            height: 0
          };
          if (this._crPage._browserContext._browser.options.headful) {
            insets = {
              width: 24,
              height: 88
            };
            if (process.platform === "win32")
              insets = {
                width: 16,
                height: 88
              };
            else if (process.platform === "linux")
              insets = {
                width: 8,
                height: 85
              };
            else if (process.platform === "darwin")
              insets = {
                width: 2,
                height: 80
              };
            if (this._crPage._browserContext.isPersistentContext()) {
              insets.height += 46;
            }
          }
          promises.push(this.setWindowBounds({
            width: viewportSize.width + insets.width,
            height: viewportSize.height + insets.height
          }));
        }
        await Promise.all(promises);
      }
      async windowBounds() {
        const {
          bounds
        } = await this._client.send("Browser.getWindowBounds", {
          windowId: this._windowId
        });
        return bounds;
      }
      async setWindowBounds(bounds) {
        return await this._client.send("Browser.setWindowBounds", {
          windowId: this._windowId,
          bounds
        });
      }
      async _updateEmulateMedia(initial) {
        if (this._crPage._browserContext._browser.isClank())
          return;
        const colorScheme = this._page._state.colorScheme === null ? "" : this._page._state.colorScheme;
        const reducedMotion = this._page._state.reducedMotion === null ? "" : this._page._state.reducedMotion;
        const forcedColors = this._page._state.forcedColors === null ? "" : this._page._state.forcedColors;
        const features = [{
          name: "prefers-color-scheme",
          value: colorScheme
        }, {
          name: "prefers-reduced-motion",
          value: reducedMotion
        }, {
          name: "forced-colors",
          value: forcedColors
        }];
        await this._client.send("Emulation.setEmulatedMedia", {
          media: this._page._state.mediaType || "",
          features
        });
      }
      async _updateRequestInterception() {
        await this._networkManager.setRequestInterception(this._page._needsRequestInterception());
      }
      async _setFileChooserIntercepted(enabled) {
        await this._client.send("Page.setInterceptFileChooserDialog", {
          enabled
        }).catch((e) => {
        });
      }
      async _evaluateOnNewDocument(source, world) {
        const worldName = world === "utility" ? UTILITY_WORLD_NAME : void 0;
        await this._client.send("Page.addScriptToEvaluateOnNewDocument", {
          source,
          worldName
        });
      }
      async _getContentFrame(handle) {
        const nodeInfo = await this._client.send("DOM.describeNode", {
          objectId: handle._objectId
        });
        if (!nodeInfo || typeof nodeInfo.node.frameId !== "string")
          return null;
        return this._page._frameManager.frame(nodeInfo.node.frameId);
      }
      async _getOwnerFrame(handle) {
        const documentElement = await handle.evaluateHandle((node) => {
          const doc = node;
          if (doc.documentElement && doc.documentElement.ownerDocument === doc)
            return doc.documentElement;
          return node.ownerDocument ? node.ownerDocument.documentElement : null;
        });
        if (!documentElement)
          return null;
        if (!documentElement._objectId)
          return null;
        const nodeInfo = await this._client.send("DOM.describeNode", {
          objectId: documentElement._objectId
        });
        const frameId = nodeInfo && typeof nodeInfo.node.frameId === "string" ? nodeInfo.node.frameId : null;
        documentElement.dispose();
        return frameId;
      }
      async _getBoundingBox(handle) {
        const result = await this._client._sendMayFail("DOM.getBoxModel", {
          objectId: handle._objectId
        });
        if (!result)
          return null;
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        const position = await this._framePosition();
        if (!position)
          return null;
        return {
          x: x + position.x,
          y: y + position.y,
          width,
          height
        };
      }
      async _framePosition() {
        const frame = this._page._frameManager.frame(this._targetId);
        if (!frame)
          return null;
        if (frame === this._page.mainFrame())
          return {
            x: 0,
            y: 0
          };
        const element = await frame.frameElement();
        const box = await element.boundingBox();
        return box;
      }
      async _scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._client.send("DOM.scrollIntoViewIfNeeded", {
          objectId: handle._objectId,
          rect
        }).then(() => "done").catch((e) => {
          if (e instanceof Error && e.message.includes("Node does not have a layout object"))
            return "error:notvisible";
          if (e instanceof Error && e.message.includes("Node is detached from document"))
            return "error:notconnected";
          throw e;
        });
      }
      async _getContentQuads(handle) {
        const result = await this._client._sendMayFail("DOM.getContentQuads", {
          objectId: handle._objectId
        });
        if (!result)
          return null;
        const position = await this._framePosition();
        if (!position)
          return null;
        return result.quads.map((quad) => [{
          x: quad[0] + position.x,
          y: quad[1] + position.y
        }, {
          x: quad[2] + position.x,
          y: quad[3] + position.y
        }, {
          x: quad[4] + position.x,
          y: quad[5] + position.y
        }, {
          x: quad[6] + position.x,
          y: quad[7] + position.y
        }]);
      }
      async _adoptElementHandle(handle, to) {
        const nodeInfo = await this._client.send("DOM.describeNode", {
          objectId: handle._objectId
        });
        return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
      }
      async _adoptBackendNodeId(backendNodeId, to) {
        const result = await this._client._sendMayFail("DOM.resolveNode", {
          backendNodeId,
          executionContextId: to[contextDelegateSymbol]._contextId
        });
        if (!result || result.object.subtype === "null")
          throw new Error(dom.kUnableToAdoptErrorMessage);
        return to.createHandle(result.object).asElement();
      }
    };
    async function emulateLocale(session, locale) {
      try {
        await session.send("Emulation.setLocaleOverride", {
          locale
        });
      } catch (exception) {
        if (exception.message.includes("Another locale override is already in effect"))
          return;
        throw exception;
      }
    }
    async function emulateTimezone(session, timezoneId) {
      try {
        await session.send("Emulation.setTimezoneOverride", {
          timezoneId
        });
      } catch (exception) {
        if (exception.message.includes("Timezone override is already in effect"))
          return;
        if (exception.message.includes("Invalid timezone"))
          throw new Error(`Invalid timezone ID: ${timezoneId}`);
        throw exception;
      }
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/chromium/crBrowser.js
var require_crBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crBrowser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CRBrowserContext = exports.CRBrowser = void 0;
    var _browser = require_browser2();
    var _browserContext = require_browserContext();
    var _utils = require_utils();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _frames = require_frames();
    var _crConnection = require_crConnection();
    var _crPage = require_crPage();
    var _crProtocolHelper = require_crProtocolHelper();
    var _crExecutionContext = require_crExecutionContext();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRBrowser = class extends _browser.Browser {
      static async connect(transport, options2, devtools) {
        const connection = new _crConnection.CRConnection(transport, options2.protocolLogger, options2.browserLogsCollector);
        const browser = new CRBrowser(connection, options2);
        browser._devtools = devtools;
        const session = connection.rootSession;
        if (options2.__testHookOnConnectToBrowser)
          await options2.__testHookOnConnectToBrowser();
        const version = await session.send("Browser.getVersion");
        browser._isMac = version.userAgent.includes("Macintosh");
        browser._version = version.product.substring(version.product.indexOf("/") + 1);
        browser._userAgent = version.userAgent;
        if (!options2.persistent) {
          await session.send("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          });
          return browser;
        }
        browser._defaultContext = new CRBrowserContext(browser, void 0, options2.persistent);
        await Promise.all([session.send("Target.setAutoAttach", {
          autoAttach: true,
          waitForDebuggerOnStart: true,
          flatten: true
        }).then(async () => {
          await session.send("Target.getTargetInfo");
        }), browser._defaultContext._initialize()]);
        await browser._waitForAllPagesToBeInitialized();
        return browser;
      }
      constructor(connection, options2) {
        super(options2);
        this._connection = void 0;
        this._session = void 0;
        this._clientRootSessionPromise = null;
        this._contexts = new Map();
        this._crPages = new Map();
        this._backgroundPages = new Map();
        this._serviceWorkers = new Map();
        this._devtools = void 0;
        this._isMac = false;
        this._version = "";
        this._tracingRecording = false;
        this._tracingPath = "";
        this._tracingClient = void 0;
        this._userAgent = "";
        this._connection = connection;
        this._session = this._connection.rootSession;
        this._connection.on(_crConnection.ConnectionEvents.Disconnected, () => this._didClose());
        this._session.on("Target.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._session.on("Target.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._session.on("Browser.downloadWillBegin", this._onDownloadWillBegin.bind(this));
        this._session.on("Browser.downloadProgress", this._onDownloadProgress.bind(this));
      }
      async newContext(options2) {
        (0, _browserContext.validateBrowserContextOptions)(options2, this.options);
        const {
          browserContextId
        } = await this._session.send("Target.createBrowserContext", {
          disposeOnDetach: true,
          proxyServer: options2.proxy ? options2.proxy.server : void 0,
          proxyBypassList: options2.proxy ? options2.proxy.bypass : void 0
        });
        const context = new CRBrowserContext(this, browserContextId, options2);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      userAgent() {
        return this._userAgent;
      }
      isClank() {
        return this.options.name === "clank";
      }
      async _waitForAllPagesToBeInitialized() {
        await Promise.all([...this._crPages.values()].map((page) => page.pageOrError()));
      }
      _onAttachedToTarget({
        targetInfo,
        sessionId,
        waitingForDebugger
      }) {
        if (targetInfo.type === "browser")
          return;
        const session = this._connection.session(sessionId);
        (0, _utils.assert)(targetInfo.browserContextId, "targetInfo: " + JSON.stringify(targetInfo, null, 2));
        let context = this._contexts.get(targetInfo.browserContextId) || null;
        if (!context) {
          context = this._defaultContext;
        }
        if (targetInfo.type === "other" && targetInfo.url.startsWith("devtools://devtools") && this._devtools) {
          this._devtools.install(session);
          return;
        }
        if (targetInfo.type === "other" || !context) {
          if (waitingForDebugger) {
            session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
              this._session._sendMayFail("Target.detachFromTarget", {
                sessionId
              });
            });
          }
          return;
        }
        (0, _utils.assert)(!this._crPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        (0, _utils.assert)(!this._backgroundPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        (0, _utils.assert)(!this._serviceWorkers.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        if (targetInfo.type === "background_page") {
          const backgroundPage = new _crPage.CRPage(session, targetInfo.targetId, context, null, false, true);
          this._backgroundPages.set(targetInfo.targetId, backgroundPage);
          return;
        }
        if (targetInfo.type === "page") {
          const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
          const crPage = new _crPage.CRPage(session, targetInfo.targetId, context, opener, true, false);
          this._crPages.set(targetInfo.targetId, crPage);
          return;
        }
        if (targetInfo.type === "service_worker") {
          const serviceWorker = new CRServiceWorker(context, session, targetInfo.url);
          this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
          context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
          return;
        }
        (0, _utils.assert)(false, "Unknown target type: " + targetInfo.type);
      }
      _onDetachedFromTarget(payload) {
        const targetId = payload.targetId;
        const crPage = this._crPages.get(targetId);
        if (crPage) {
          this._crPages.delete(targetId);
          crPage.didClose();
          return;
        }
        const backgroundPage = this._backgroundPages.get(targetId);
        if (backgroundPage) {
          this._backgroundPages.delete(targetId);
          backgroundPage.didClose();
          return;
        }
        const serviceWorker = this._serviceWorkers.get(targetId);
        if (serviceWorker) {
          this._serviceWorkers.delete(targetId);
          serviceWorker.didClose();
          return;
        }
      }
      _findOwningPage(frameId) {
        for (const crPage of this._crPages.values()) {
          const frame = crPage._page._frameManager.frame(frameId);
          if (frame)
            return crPage;
        }
        return null;
      }
      _onDownloadWillBegin(payload) {
        const page = this._findOwningPage(payload.frameId);
        (0, _utils.assert)(page, "Download started in unknown page: " + JSON.stringify(payload));
        page.willBeginDownload();
        let originPage = page._initializedPage;
        if (!originPage && page._opener)
          originPage = page._opener._initializedPage;
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
      }
      _onDownloadProgress(payload) {
        if (payload.state === "completed")
          this._downloadFinished(payload.guid, "");
        if (payload.state === "canceled")
          this._downloadFinished(payload.guid, "canceled");
      }
      async _closePage(crPage) {
        await this._session.send("Target.closeTarget", {
          targetId: crPage._targetId
        });
      }
      async newBrowserCDPSession() {
        return await this._connection.createBrowserSession();
      }
      async startTracing(page, options2 = {}) {
        (0, _utils.assert)(!this._tracingRecording, "Cannot start recording trace while already recording trace.");
        this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
        const defaultCategories = ["-*", "devtools.timeline", "v8.execute", "disabled-by-default-devtools.timeline", "disabled-by-default-devtools.timeline.frame", "toplevel", "blink.console", "blink.user_timing", "latencyInfo", "disabled-by-default-devtools.timeline.stack", "disabled-by-default-v8.cpu_profiler", "disabled-by-default-v8.cpu_profiler.hires"];
        const {
          path = null,
          screenshots = false,
          categories = defaultCategories
        } = options2;
        if (screenshots)
          categories.push("disabled-by-default-devtools.screenshot");
        this._tracingPath = path;
        this._tracingRecording = true;
        await this._tracingClient.send("Tracing.start", {
          transferMode: "ReturnAsStream",
          categories: categories.join(",")
        });
      }
      async stopTracing() {
        (0, _utils.assert)(this._tracingClient, "Tracing was not started.");
        const [event] = await Promise.all([new Promise((f) => this._tracingClient.once("Tracing.tracingComplete", f)), this._tracingClient.send("Tracing.end")]);
        const result = await (0, _crProtocolHelper.readProtocolStream)(this._tracingClient, event.stream, this._tracingPath);
        this._tracingRecording = false;
        return result;
      }
      isConnected() {
        return !this._connection._closed;
      }
      async _clientRootSession() {
        if (!this._clientRootSessionPromise)
          this._clientRootSessionPromise = this._connection.createBrowserSession();
        return this._clientRootSessionPromise;
      }
    };
    exports.CRBrowser = CRBrowser;
    var CRServiceWorker = class extends _page.Worker {
      constructor(browserContext, session, url) {
        super(browserContext, url);
        this._browserContext = void 0;
        this._browserContext = browserContext;
        session.once("Runtime.executionContextCreated", (event) => {
          this._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event.context));
        });
        session.send("Runtime.enable", {}).catch((e) => {
        });
        session.send("Runtime.runIfWaitingForDebugger").catch((e) => {
        });
      }
    };
    var CRBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options2) {
        super(browser, options2, browserContextId);
        this._evaluateOnNewDocumentSources = void 0;
        this._evaluateOnNewDocumentSources = [];
        this._authenticateProxyViaCredentials();
      }
      async _initialize() {
        (0, _utils.assert)(!Array.from(this._browser._crPages.values()).some((page) => page._browserContext === this));
        const promises = [super._initialize()];
        if (this._browser.options.name !== "electron" && this._browser.options.name !== "clank") {
          promises.push(this._browser._session.send("Browser.setDownloadBehavior", {
            behavior: this._options.acceptDownloads ? "allowAndName" : "deny",
            browserContextId: this._browserContextId,
            downloadPath: this._browser.options.downloadsPath,
            eventsEnabled: true
          }));
        }
        if (this._options.permissions)
          promises.push(this.grantPermissions(this._options.permissions));
        await Promise.all(promises);
      }
      pages() {
        const result = [];
        for (const crPage of this._browser._crPages.values()) {
          if (crPage._browserContext === this && crPage._initializedPage)
            result.push(crPage._initializedPage);
        }
        return result;
      }
      async newPageDelegate() {
        (0, _browserContext.assertBrowserContextIsNotOwned)(this);
        const oldKeys = this._browser.isClank() ? new Set(this._browser._crPages.keys()) : void 0;
        let {
          targetId
        } = await this._browser._session.send("Target.createTarget", {
          url: "about:blank",
          browserContextId: this._browserContextId
        });
        if (oldKeys) {
          const newKeys = new Set(this._browser._crPages.keys());
          for (const key of oldKeys)
            newKeys.delete(key);
          for (const key of newKeys) {
            const page = this._browser._crPages.get(key);
            if (page._opener)
              newKeys.delete(key);
          }
          (0, _utils.assert)(newKeys.size === 1);
          [targetId] = [...newKeys];
        }
        return this._browser._crPages.get(targetId);
      }
      async _doCookies(urls) {
        const {
          cookies
        } = await this._browser._session.send("Storage.getCookies", {
          browserContextId: this._browserContextId
        });
        return network.filterCookies(cookies.map((c) => {
          const copy = __spreadValues({
            sameSite: "Lax"
          }, c);
          delete copy.size;
          delete copy.priority;
          delete copy.session;
          delete copy.sameParty;
          delete copy.sourceScheme;
          delete copy.sourcePort;
          return copy;
        }), urls);
      }
      async addCookies(cookies) {
        await this._browser._session.send("Storage.setCookies", {
          cookies: network.rewriteCookies(cookies),
          browserContextId: this._browserContextId
        });
      }
      async clearCookies() {
        await this._browser._session.send("Storage.clearCookies", {
          browserContextId: this._browserContextId
        });
      }
      async _doGrantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
          ["geolocation", "geolocation"],
          ["midi", "midi"],
          ["notifications", "notifications"],
          ["camera", "videoCapture"],
          ["microphone", "audioCapture"],
          ["background-sync", "backgroundSync"],
          ["ambient-light-sensor", "sensors"],
          ["accelerometer", "sensors"],
          ["gyroscope", "sensors"],
          ["magnetometer", "sensors"],
          ["accessibility-events", "accessibilityEvents"],
          ["clipboard-read", "clipboardReadWrite"],
          ["clipboard-write", "clipboardSanitizedWrite"],
          ["payment-handler", "paymentHandler"],
          ["midi-sysex", "midiSysex"]
        ]);
        const filtered = permissions.map((permission) => {
          const protocolPermission = webPermissionToProtocol.get(permission);
          if (!protocolPermission)
            throw new Error("Unknown permission: " + permission);
          return protocolPermission;
        });
        await this._browser._session.send("Browser.grantPermissions", {
          origin: origin === "*" ? void 0 : origin,
          browserContextId: this._browserContextId,
          permissions: filtered
        });
      }
      async _doClearPermissions() {
        await this._browser._session.send("Browser.resetPermissions", {
          browserContextId: this._browserContextId
        });
      }
      async setGeolocation(geolocation) {
        (0, _browserContext.verifyGeolocation)(geolocation);
        this._options.geolocation = geolocation;
        for (const page of this.pages())
          await page._delegate.updateGeolocation();
      }
      async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        for (const page of this.pages())
          await page._delegate.updateExtraHTTPHeaders();
      }
      async setOffline(offline) {
        this._options.offline = offline;
        for (const page of this.pages())
          await page._delegate.updateOffline();
      }
      async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        for (const page of this.pages())
          await page._delegate.updateHttpCredentials();
      }
      async _doAddInitScript(source) {
        this._evaluateOnNewDocumentSources.push(source);
        for (const page of this.pages())
          await page._delegate.evaluateOnNewDocument(source);
      }
      async _doExposeBinding(binding) {
        for (const page of this.pages())
          await page._delegate.exposeBinding(binding);
      }
      async _doUpdateRequestInterception() {
        for (const page of this.pages())
          await page._delegate.updateRequestInterception();
      }
      async _doClose() {
        (0, _utils.assert)(this._browserContextId);
        await this._browser._session.send("Target.disposeBrowserContext", {
          browserContextId: this._browserContextId
        });
        this._browser._contexts.delete(this._browserContextId);
        for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
          if (serviceWorker._browserContext !== this)
            continue;
          serviceWorker.didClose();
          this._browser._serviceWorkers.delete(targetId);
        }
      }
      _onClosePersistent() {
        for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage) {
            backgroundPage.didClose();
            this._browser._backgroundPages.delete(targetId);
          }
        }
      }
      async _doCancelDownload(guid) {
        await this._browser._session.send("Browser.cancelDownload", {
          guid,
          browserContextId: this._browserContextId
        });
      }
      backgroundPages() {
        const result = [];
        for (const backgroundPage of this._browser._backgroundPages.values()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage)
            result.push(backgroundPage._initializedPage);
        }
        return result;
      }
      serviceWorkers() {
        return Array.from(this._browser._serviceWorkers.values()).filter((serviceWorker) => serviceWorker._browserContext === this);
      }
      async newCDPSession(page) {
        let targetId = null;
        if (page instanceof _page.Page) {
          targetId = page._delegate._targetId;
        } else if (page instanceof _frames.Frame) {
          const session = page._page._delegate._sessions.get(page._id);
          if (!session)
            throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);
          targetId = session._targetId;
        } else {
          throw new Error("page: expected Page or Frame");
        }
        const rootSession = await this._browser._clientRootSession();
        const {
          sessionId
        } = await rootSession.send("Target.attachToTarget", {
          targetId,
          flatten: true
        });
        return this._browser._connection.session(sessionId);
      }
    };
    exports.CRBrowserContext = CRBrowserContext;
    CRBrowserContext.CREvents = {
      BackgroundPage: "backgroundpage",
      ServiceWorker: "serviceworker"
    };
  }
});

// node_modules/playwright-core/lib/protocol/transport.js
var require_transport = __commonJS({
  "node_modules/playwright-core/lib/protocol/transport.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transport = void 0;
    var _utils = require_utils();
    var Transport = class {
      constructor(pipeWrite, pipeRead, closeable, endian = "le") {
        this._pipeWrite = void 0;
        this._data = Buffer.from([]);
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this._closed = false;
        this._bytesLeft = 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this._endian = void 0;
        this._closeableStream = void 0;
        this._pipeWrite = pipeWrite;
        this._endian = endian;
        this._closeableStream = closeable;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose();
        });
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        const data = Buffer.from(message, "utf-8");
        const dataLength = Buffer.alloc(4);
        if (this._endian === "be")
          dataLength.writeUInt32BE(data.length, 0);
        else
          dataLength.writeUInt32LE(data.length, 0);
        this._pipeWrite.write(dataLength);
        this._pipeWrite.write(data);
      }
      close() {
        this._closeableStream.close();
      }
      _dispatch(buffer) {
        this._data = Buffer.concat([this._data, buffer]);
        while (true) {
          if (!this._bytesLeft && this._data.length < 4) {
            break;
          }
          if (!this._bytesLeft) {
            this._bytesLeft = this._endian === "be" ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
            this._data = this._data.slice(4);
          }
          if (!this._bytesLeft || this._data.length < this._bytesLeft) {
            break;
          }
          const message = this._data.slice(0, this._bytesLeft);
          this._data = this._data.slice(this._bytesLeft);
          this._bytesLeft = 0;
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(message.toString("utf-8"));
          });
        }
      }
    };
    exports.Transport = Transport;
  }
});

// node_modules/playwright-core/lib/server/android/android.js
var require_android = __commonJS({
  "node_modules/playwright-core/lib/server/android/android.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AndroidDevice = exports.Android = void 0;
    var _debug = _interopRequireDefault(require_src());
    var _events = __require("events");
    var _fs = _interopRequireDefault(__require("fs"));
    var ws = _interopRequireWildcard(require_ws());
    var _utils = require_utils();
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _crBrowser = require_crBrowser();
    var _helper = require_helper();
    var _transport = require_transport();
    var _debugLogger = require_debugLogger();
    var _timeoutSettings = require_timeoutSettings();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Android = class extends _instrumentation.SdkObject {
      constructor(backend, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "android");
        this._backend = void 0;
        this._devices = new Map();
        this._timeoutSettings = void 0;
        this._playwrightOptions = void 0;
        this._backend = backend;
        this._playwrightOptions = playwrightOptions;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async devices() {
        const devices2 = (await this._backend.devices()).filter((d) => d.status === "device");
        const newSerials = new Set();
        for (const d of devices2) {
          newSerials.add(d.serial);
          if (this._devices.has(d.serial))
            continue;
          const device = await AndroidDevice.create(this, d);
          this._devices.set(d.serial, device);
        }
        for (const d of this._devices.keys()) {
          if (!newSerials.has(d))
            this._devices.delete(d);
        }
        return [...this._devices.values()];
      }
      _deviceClosed(device) {
        this._devices.delete(device.serial);
      }
    };
    exports.Android = Android;
    var AndroidDevice = class extends _instrumentation.SdkObject {
      constructor(android, backend, model) {
        super(android, "android-device");
        this._backend = void 0;
        this.model = void 0;
        this.serial = void 0;
        this._driverPromise = void 0;
        this._lastId = 0;
        this._callbacks = new Map();
        this._pollingWebViews = void 0;
        this._timeoutSettings = void 0;
        this._webViews = new Map();
        this._browserConnections = new Set();
        this._android = void 0;
        this._isClosed = false;
        this._android = android;
        this._backend = backend;
        this.model = model;
        this.serial = backend.serial;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(android._timeoutSettings);
      }
      static async create(android, backend) {
        await backend.init();
        const model = await backend.runCommand("shell:getprop ro.product.model");
        const device = new AndroidDevice(android, backend, model.toString().trim());
        await device._init();
        return device;
      }
      async _init() {
        await this._refreshWebViews();
        const poll = () => {
          this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {
          }), 500);
        };
        poll();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async shell(command) {
        const result = await this._backend.runCommand(`shell:${command}`);
        await this._refreshWebViews();
        return result;
      }
      async open(command) {
        return await this._backend.open(`${command}`);
      }
      async screenshot() {
        return await this._backend.runCommand(`shell:screencap -p`);
      }
      async _driver() {
        if (!this._driverPromise)
          this._driverPromise = this._installDriver();
        return this._driverPromise;
      }
      async _installDriver() {
        (0, _debug.default)("pw:android")("Stopping the old driver");
        await this.shell(`am force-stop com.microsoft.playwright.androiddriver`);
        (0, _debug.default)("pw:android")("Uninstalling the old driver");
        await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);
        await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);
        (0, _debug.default)("pw:android")("Installing the new driver");
        for (const file of ["android-driver.apk", "android-driver-target.apk"])
          await this.installApk(await _fs.default.promises.readFile(__require.resolve(`../../../bin/${file}`)));
        (0, _debug.default)("pw:android")("Starting the new driver");
        this.shell("am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner").catch((e) => (0, _debug.default)("pw:android")(e));
        const socket = await this._waitForLocalAbstract("playwright_android_driver_socket");
        const transport = new _transport.Transport(socket, socket, socket, "be");
        transport.onmessage = (message) => {
          const response = JSON.parse(message);
          const {
            id,
            result,
            error: error2
          } = response;
          const callback = this._callbacks.get(id);
          if (!callback)
            return;
          if (error2)
            callback.reject(new Error(error2));
          else
            callback.fulfill(result);
          this._callbacks.delete(id);
        };
        return transport;
      }
      async _waitForLocalAbstract(socketName) {
        let socket;
        (0, _debug.default)("pw:android")(`Polling the socket localabstract:${socketName}`);
        while (!socket) {
          try {
            socket = await this._backend.open(`localabstract:${socketName}`);
          } catch (e) {
            await new Promise((f) => setTimeout(f, 250));
          }
        }
        (0, _debug.default)("pw:android")(`Connected to localabstract:${socketName}`);
        return socket;
      }
      async send(method, params = {}) {
        params.timeout = this._timeoutSettings.timeout(params);
        const driver = await this._driver();
        const id = ++this._lastId;
        const result = new Promise((fulfill, reject) => this._callbacks.set(id, {
          fulfill,
          reject
        }));
        driver.send(JSON.stringify({
          id,
          method,
          params
        }));
        return result;
      }
      async close() {
        this._isClosed = true;
        if (this._pollingWebViews)
          clearTimeout(this._pollingWebViews);
        for (const connection of this._browserConnections)
          await connection.close();
        if (this._driverPromise) {
          const driver = await this._driver();
          driver.close();
        }
        await this._backend.close();
        this._android._deviceClosed(this);
        this.emit(AndroidDevice.Events.Closed);
      }
      async launchBrowser(pkg = "com.android.chrome", options2) {
        (0, _debug.default)("pw:android")("Force-stopping", pkg);
        await this._backend.runCommand(`shell:am force-stop ${pkg}`);
        const socketName = "playwright-" + (0, _utils.createGuid)();
        const commandLine = `_ --disable-fre --no-default-browser-check --no-first-run --remote-debugging-socket-name=${socketName}`;
        (0, _debug.default)("pw:android")("Starting", pkg, commandLine);
        await this._backend.runCommand(`shell:echo "${commandLine}" > /data/local/tmp/chrome-command-line`);
        await this._backend.runCommand(`shell:am start -n ${pkg}/com.google.android.apps.chrome.Main about:blank`);
        return await this._connectToBrowser(socketName, options2);
      }
      async connectToWebView(pid) {
        const webView = this._webViews.get(pid);
        if (!webView)
          throw new Error("WebView has been closed");
        return await this._connectToBrowser(`webview_devtools_remote_${pid}`);
      }
      async _connectToBrowser(socketName, options2 = {}) {
        const socket = await this._waitForLocalAbstract(socketName);
        const androidBrowser = new AndroidBrowser(this, socket);
        await androidBrowser._init();
        this._browserConnections.add(androidBrowser);
        const browserOptions = __spreadProps(__spreadValues({}, this._android._playwrightOptions), {
          name: "clank",
          isChromium: true,
          slowMo: 0,
          persistent: __spreadProps(__spreadValues({}, options2), {
            noDefaultViewport: true
          }),
          artifactsDir: "",
          downloadsPath: "",
          tracesDir: "",
          browserProcess: new ClankBrowserProcess(androidBrowser),
          proxy: options2.proxy,
          protocolLogger: _helper.helper.debugProtocolLogger(),
          browserLogsCollector: new _debugLogger.RecentLogsCollector()
        });
        (0, _browserContext.validateBrowserContextOptions)(options2, browserOptions);
        const browser = await _crBrowser.CRBrowser.connect(androidBrowser, browserOptions);
        const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), this);
        const defaultContext = browser._defaultContext;
        await controller.run(async (progress) => {
          await defaultContext._loadDefaultContextAsIs(progress);
        });
        {
          const page = defaultContext.pages()[0];
          const crPage = page._delegate;
          await crPage._mainFrameSession._client.send("Emulation.setDeviceMetricsOverride", {
            mobile: false,
            width: 0,
            height: 0,
            deviceScaleFactor: 0
          });
          await crPage._mainFrameSession._client.send("Emulation.clearDeviceMetricsOverride", {});
        }
        return defaultContext;
      }
      webViews() {
        return [...this._webViews.values()];
      }
      async installApk(content, options2) {
        const args = options2 && options2.args ? options2.args : ["-r", "-t", "-S"];
        (0, _debug.default)("pw:android")("Opening install socket");
        const installSocket = await this._backend.open(`shell:cmd package install ${args.join(" ")} ${content.length}`);
        (0, _debug.default)("pw:android")("Writing driver bytes: " + content.length);
        await installSocket.write(content);
        const success = await new Promise((f) => installSocket.on("data", f));
        (0, _debug.default)("pw:android")("Written driver bytes: " + success);
        installSocket.close();
      }
      async push(content, path, mode = 420) {
        const socket = await this._backend.open(`sync:`);
        const sendHeader = async (command, length) => {
          const buffer = Buffer.alloc(command.length + 4);
          buffer.write(command, 0);
          buffer.writeUInt32LE(length, command.length);
          await socket.write(buffer);
        };
        const send2 = async (command, data) => {
          await sendHeader(command, data.length);
          await socket.write(data);
        };
        await send2("SEND", Buffer.from(`${path},${mode}`));
        const maxChunk = 65535;
        for (let i = 0; i < content.length; i += maxChunk)
          await send2("DATA", content.slice(i, i + maxChunk));
        await sendHeader("DONE", Date.now() / 1e3 | 0);
        const result = await new Promise((f) => socket.once("data", f));
        const code = result.slice(0, 4).toString();
        if (code !== "OKAY")
          throw new Error("Could not push: " + code);
        socket.close();
      }
      async _refreshWebViews() {
        const sockets = (await this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split("\n");
        if (this._isClosed)
          return;
        const newPids = new Set();
        for (const line of sockets) {
          const match = line.match(/[^@]+@webview_devtools_remote_(\d+)/);
          if (!match)
            continue;
          const pid = +match[1];
          newPids.add(pid);
        }
        for (const pid of newPids) {
          if (this._webViews.has(pid))
            continue;
          const procs = (await this._backend.runCommand(`shell:ps -A | grep ${pid}`)).toString().split("\n");
          if (this._isClosed)
            return;
          let pkg = "";
          for (const proc of procs) {
            const match = proc.match(/[^\s]+\s+(\d+).*$/);
            if (!match)
              continue;
            const p = match[1];
            if (+p !== pid)
              continue;
            pkg = proc.substring(proc.lastIndexOf(" ") + 1);
          }
          const webView = {
            pid,
            pkg
          };
          this._webViews.set(pid, webView);
          this.emit(AndroidDevice.Events.WebViewAdded, webView);
        }
        for (const p of this._webViews.keys()) {
          if (!newPids.has(p)) {
            this._webViews.delete(p);
            this.emit(AndroidDevice.Events.WebViewRemoved, p);
          }
        }
      }
    };
    exports.AndroidDevice = AndroidDevice;
    AndroidDevice.Events = {
      WebViewAdded: "webViewAdded",
      WebViewRemoved: "webViewRemoved",
      Closed: "closed"
    };
    var AndroidBrowser = class extends _events.EventEmitter {
      constructor(device, socket) {
        super();
        this.device = void 0;
        this._socket = void 0;
        this._receiver = void 0;
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this.onmessage = void 0;
        this.onclose = void 0;
        this.setMaxListeners(0);
        this.device = device;
        this._socket = socket;
        this._socket.on("close", () => {
          this._waitForNextTask(() => {
            if (this.onclose)
              this.onclose();
          });
        });
        this._receiver = new ws.Receiver();
        this._receiver.on("message", (message) => {
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(JSON.parse(message));
          });
        });
      }
      async _init() {
        await this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`));
        await new Promise((f) => this._socket.once("data", f));
        this._socket.on("data", (data) => this._receiver._write(data, "binary", () => {
        }));
      }
      async send(s2) {
        await this._socket.write(encodeWebFrame(JSON.stringify(s2)));
      }
      async close() {
        this._socket.close();
      }
    };
    function encodeWebFrame(data) {
      return ws.Sender.frame(Buffer.from(data), {
        opcode: 1,
        mask: true,
        fin: true,
        readOnly: true
      })[0];
    }
    var ClankBrowserProcess = class {
      constructor(browser) {
        this._browser = void 0;
        this.onclose = void 0;
        this._browser = browser;
      }
      async kill() {
      }
      async close() {
        await this._browser.close();
      }
    };
  }
});

// node_modules/playwright-core/lib/server/android/backendAdb.js
var require_backendAdb = __commonJS({
  "node_modules/playwright-core/lib/server/android/backendAdb.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AdbBackend = void 0;
    var _assert = _interopRequireDefault(__require("assert"));
    var _debug = _interopRequireDefault(require_src());
    var net = _interopRequireWildcard(__require("net"));
    var _events = __require("events");
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AdbBackend = class {
      async devices() {
        const result = await runCommand("host:devices");
        const lines = result.toString().trim().split("\n");
        return lines.map((line) => {
          const [serial, status] = line.trim().split("	");
          return new AdbDevice(serial, status);
        });
      }
    };
    exports.AdbBackend = AdbBackend;
    var AdbDevice = class {
      constructor(serial, status) {
        this.serial = void 0;
        this.status = void 0;
        this.serial = serial;
        this.status = status;
      }
      async init() {
      }
      async close() {
      }
      runCommand(command) {
        return runCommand(command, this.serial);
      }
      async open(command) {
        const result = await open(command, this.serial);
        result.becomeSocket();
        return result;
      }
    };
    async function runCommand(command, serial) {
      (0, _debug.default)("pw:adb:runCommand")(command, serial);
      const socket = new BufferedSocketWrapper(command, net.createConnection({
        port: 5037
      }));
      if (serial) {
        await socket.write(encodeMessage(`host:transport:${serial}`));
        const status2 = await socket.read(4);
        (0, _assert.default)(status2.toString() === "OKAY", status2.toString());
      }
      await socket.write(encodeMessage(command));
      const status = await socket.read(4);
      (0, _assert.default)(status.toString() === "OKAY", status.toString());
      let commandOutput;
      if (!command.startsWith("shell:")) {
        const remainingLength = parseInt((await socket.read(4)).toString(), 16);
        commandOutput = await socket.read(remainingLength);
      } else {
        commandOutput = await socket.readAll();
      }
      socket.close();
      return commandOutput;
    }
    async function open(command, serial) {
      const socket = new BufferedSocketWrapper(command, net.createConnection({
        port: 5037
      }));
      if (serial) {
        await socket.write(encodeMessage(`host:transport:${serial}`));
        const status2 = await socket.read(4);
        (0, _assert.default)(status2.toString() === "OKAY", status2.toString());
      }
      await socket.write(encodeMessage(command));
      const status = await socket.read(4);
      (0, _assert.default)(status.toString() === "OKAY", status.toString());
      return socket;
    }
    function encodeMessage(message) {
      let lenHex = message.length.toString(16);
      lenHex = "0".repeat(4 - lenHex.length) + lenHex;
      return Buffer.from(lenHex + message);
    }
    var BufferedSocketWrapper = class extends _events.EventEmitter {
      constructor(command, socket) {
        super();
        this.guid = (0, _utils.createGuid)();
        this._socket = void 0;
        this._buffer = Buffer.from([]);
        this._isSocket = false;
        this._notifyReader = void 0;
        this._connectPromise = void 0;
        this._isClosed = false;
        this._command = void 0;
        this._command = command;
        this._socket = socket;
        this._connectPromise = new Promise((f) => this._socket.on("connect", f));
        this._socket.on("data", (data) => {
          (0, _debug.default)("pw:adb:data")(data.toString());
          if (this._isSocket) {
            this.emit("data", data);
            return;
          }
          this._buffer = Buffer.concat([this._buffer, data]);
          if (this._notifyReader)
            this._notifyReader();
        });
        this._socket.on("close", () => {
          this._isClosed = true;
          if (this._notifyReader)
            this._notifyReader();
          this.close();
          this.emit("close");
        });
        this._socket.on("error", (error2) => this.emit("error", error2));
      }
      async write(data) {
        (0, _debug.default)("pw:adb:send")(data.toString().substring(0, 100) + "...");
        await this._connectPromise;
        await new Promise((f) => this._socket.write(data, f));
      }
      close() {
        if (this._isClosed)
          return;
        (0, _debug.default)("pw:adb")("Close " + this._command);
        this._socket.destroy();
      }
      async read(length) {
        await this._connectPromise;
        (0, _assert.default)(!this._isSocket, "Can not read by length in socket mode");
        while (this._buffer.length < length)
          await new Promise((f) => this._notifyReader = f);
        const result = this._buffer.slice(0, length);
        this._buffer = this._buffer.slice(length);
        (0, _debug.default)("pw:adb:recv")(result.toString().substring(0, 100) + "...");
        return result;
      }
      async readAll() {
        while (!this._isClosed)
          await new Promise((f) => this._notifyReader = f);
        return this._buffer;
      }
      becomeSocket() {
        (0, _assert.default)(!this._buffer.length);
        this._isSocket = true;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/transport.js
var require_transport2 = __commonJS({
  "node_modules/playwright-core/lib/server/transport.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WebSocketTransport = void 0;
    var _ws = _interopRequireDefault(require_ws());
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WebSocketTransport = class {
      static async connect(progress, url, headers) {
        progress.log(`<ws connecting> ${url}`);
        const transport = new WebSocketTransport(progress, url, headers);
        let success = false;
        progress.cleanupWhenAborted(async () => {
          if (!success)
            await transport.closeAndWait().catch((e) => null);
        });
        await new Promise((fulfill, reject) => {
          transport._ws.addEventListener("open", async () => {
            progress.log(`<ws connected> ${url}`);
            fulfill(transport);
          });
          transport._ws.addEventListener("error", (event) => {
            progress.log(`<ws connect error> ${url} ${event.message}`);
            reject(new Error("WebSocket error: " + event.message));
            transport._ws.close();
          });
        });
        success = true;
        return transport;
      }
      constructor(progress, url, headers) {
        this._ws = void 0;
        this._progress = void 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this.wsEndpoint = void 0;
        this.wsEndpoint = url;
        this._ws = new _ws.default(url, [], {
          perMessageDeflate: false,
          maxPayload: 256 * 1024 * 1024,
          handshakeTimeout: progress.timeUntilDeadline(),
          headers
        });
        this._progress = progress;
        const messageWrap = (0, _utils.makeWaitForNextTask)();
        this._ws.addEventListener("message", (event) => {
          messageWrap(() => {
            try {
              if (this.onmessage)
                this.onmessage.call(null, JSON.parse(event.data));
            } catch (e) {
              this._ws.close();
            }
          });
        });
        this._ws.addEventListener("close", (event) => {
          this._progress && this._progress.log(`<ws disconnected> ${url}`);
          if (this.onclose)
            this.onclose.call(null);
        });
        this._ws.addEventListener("error", () => {
        });
      }
      send(message) {
        this._ws.send(JSON.stringify(message));
      }
      close() {
        this._progress && this._progress.log(`<ws disconnecting> ${this._ws.url}`);
        this._ws.close();
      }
      async closeAndWait() {
        const promise = new Promise((f) => this._ws.once("close", f));
        this.close();
        await promise;
      }
    };
    exports.WebSocketTransport = WebSocketTransport;
  }
});

// node_modules/playwright-core/lib/server/pipeTransport.js
var require_pipeTransport = __commonJS({
  "node_modules/playwright-core/lib/server/pipeTransport.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PipeTransport = void 0;
    var _utils = require_utils();
    var _debugLogger = require_debugLogger();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead) {
        this._pipeWrite = void 0;
        this._pendingMessage = "";
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this._closed = false;
        this.onmessage = void 0;
        this.onclose = void 0;
        this._pipeWrite = pipeWrite;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose.call(null);
        });
        pipeRead.on("error", (e) => _debugLogger.debugLogger.log("error", e));
        pipeWrite.on("error", (e) => _debugLogger.debugLogger.log("error", e));
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        this._pipeWrite.write(JSON.stringify(message));
        this._pipeWrite.write("\0");
      }
      close() {
        throw new Error("unimplemented");
      }
      _dispatch(buffer) {
        let end = buffer.indexOf("\0");
        if (end === -1) {
          this._pendingMessage += buffer.toString();
          return;
        }
        const message = this._pendingMessage + buffer.toString(void 0, 0, end);
        this._waitForNextTask(() => {
          if (this.onmessage)
            this.onmessage.call(null, JSON.parse(message));
        });
        let start = end + 1;
        end = buffer.indexOf("\0", start);
        while (end !== -1) {
          const message2 = buffer.toString(void 0, start, end);
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage.call(null, JSON.parse(message2));
          });
          start = end + 1;
          end = buffer.indexOf("\0", start);
        }
        this._pendingMessage = buffer.toString(void 0, start);
      }
    };
    exports.PipeTransport = PipeTransport;
  }
});

// node_modules/playwright-core/lib/server/browserType.js
var require_browserType = __commonJS({
  "node_modules/playwright-core/lib/server/browserType.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BrowserType = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var os = _interopRequireWildcard(__require("os"));
    var _path = _interopRequireDefault(__require("path"));
    var _browserContext = require_browserContext();
    var _registry = require_registry();
    var _transport = require_transport2();
    var _processLauncher = require_processLauncher();
    var _pipeTransport = require_pipeTransport();
    var _progress = require_progress2();
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _helper = require_helper();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(os.tmpdir(), "playwright-artifacts-");
    var BrowserType = class extends _instrumentation.SdkObject {
      constructor(browserName, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "browser-type");
        this._name = void 0;
        this._playwrightOptions = void 0;
        this.attribution.browserType = this;
        this._playwrightOptions = playwrightOptions;
        this._name = browserName;
      }
      executablePath() {
        return _registry.registry.findExecutable(this._name).executablePath(this._playwrightOptions.sdkLanguage) || "";
      }
      name() {
        return this._name;
      }
      async launch(metadata, options2, protocolLogger) {
        options2 = this._validateLaunchOptions(options2);
        const controller = new _progress.ProgressController(metadata, this);
        controller.setLogName("browser");
        const browser = await controller.run((progress) => {
          const seleniumHubUrl = options2.__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;
          if (seleniumHubUrl)
            return this._launchWithSeleniumHub(progress, seleniumHubUrl, options2);
          return this._innerLaunchWithRetries(progress, options2, void 0, _helper.helper.debugProtocolLogger(protocolLogger)).catch((e) => {
            throw this._rewriteStartupError(e);
          });
        }, _timeoutSettings.TimeoutSettings.timeout(options2));
        return browser;
      }
      async launchPersistentContext(metadata, userDataDir, options2) {
        options2 = this._validateLaunchOptions(options2);
        const controller = new _progress.ProgressController(metadata, this);
        const persistent = options2;
        controller.setLogName("browser");
        const browser = await controller.run((progress) => {
          return this._innerLaunchWithRetries(progress, options2, persistent, _helper.helper.debugProtocolLogger(), userDataDir).catch((e) => {
            throw this._rewriteStartupError(e);
          });
        }, _timeoutSettings.TimeoutSettings.timeout(options2));
        return browser._defaultContext;
      }
      async _innerLaunchWithRetries(progress, options2, persistent, protocolLogger, userDataDir) {
        try {
          return this._innerLaunch(progress, options2, persistent, protocolLogger, userDataDir);
        } catch (error2) {
          const errorMessage = typeof error2 === "object" && typeof error2.message === "string" ? error2.message : "";
          if (errorMessage.includes("Inconsistency detected by ld.so")) {
            progress.log(`<restarting browser due to hitting race condition in glibc>`);
            return this._innerLaunch(progress, options2, persistent, protocolLogger, userDataDir);
          }
          throw error2;
        }
      }
      async _innerLaunch(progress, options2, persistent, protocolLogger, userDataDir) {
        options2.proxy = options2.proxy ? (0, _browserContext.normalizeProxySettings)(options2.proxy) : void 0;
        const browserLogsCollector = new _debugLogger.RecentLogsCollector();
        const {
          browserProcess,
          artifactsDir,
          transport
        } = await this._launchProcess(progress, options2, !!persistent, browserLogsCollector, userDataDir);
        if (options2.__testHookBeforeCreateBrowser)
          await options2.__testHookBeforeCreateBrowser();
        const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
          name: this._name,
          isChromium: this._name === "chromium",
          channel: options2.channel,
          slowMo: options2.slowMo,
          persistent,
          headful: !options2.headless,
          artifactsDir,
          downloadsPath: options2.downloadsPath || artifactsDir,
          tracesDir: options2.tracesDir || artifactsDir,
          browserProcess,
          customExecutablePath: options2.executablePath,
          proxy: options2.proxy,
          protocolLogger,
          browserLogsCollector,
          wsEndpoint: options2.useWebSocket ? transport.wsEndpoint : void 0
        });
        if (persistent)
          (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);
        copyTestHooks(options2, browserOptions);
        const browser = await this._connectToTransport(transport, browserOptions);
        if (persistent && !options2.ignoreAllDefaultArgs)
          await browser._defaultContext._loadDefaultContext(progress);
        return browser;
      }
      async _launchProcess(progress, options2, isPersistent, browserLogsCollector, userDataDir) {
        var _options$args;
        const {
          ignoreDefaultArgs,
          ignoreAllDefaultArgs,
          args = [],
          executablePath = null,
          handleSIGINT = true,
          handleSIGTERM = true,
          handleSIGHUP = true
        } = options2;
        const env = options2.env ? (0, _processLauncher.envArrayToObject)(options2.env) : process.env;
        const tempDirectories = [];
        if (options2.downloadsPath)
          await _fs.default.promises.mkdir(options2.downloadsPath, {
            recursive: true
          });
        if (options2.tracesDir)
          await _fs.default.promises.mkdir(options2.tracesDir, {
            recursive: true
          });
        const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
        tempDirectories.push(artifactsDir);
        if (userDataDir) {
          if (!await (0, _utils.existsAsync)(userDataDir))
            await _fs.default.promises.mkdir(userDataDir, {
              recursive: true,
              mode: 448
            });
        } else {
          userDataDir = await _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));
          tempDirectories.push(userDataDir);
        }
        const browserArguments = [];
        if (ignoreAllDefaultArgs)
          browserArguments.push(...args);
        else if (ignoreDefaultArgs)
          browserArguments.push(...this._defaultArgs(options2, isPersistent, userDataDir).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
        else
          browserArguments.push(...this._defaultArgs(options2, isPersistent, userDataDir));
        let executable;
        if (executablePath) {
          if (!await (0, _utils.existsAsync)(executablePath))
            throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);
          executable = executablePath;
        } else {
          const registryExecutable = _registry.registry.findExecutable(options2.channel || this._name);
          if (!registryExecutable || registryExecutable.browserName !== this._name)
            throw new Error(`Unsupported ${this._name} channel "${options2.channel}"`);
          executable = registryExecutable.executablePathOrDie(this._playwrightOptions.sdkLanguage);
          await registryExecutable.validateHostRequirements(this._playwrightOptions.sdkLanguage);
        }
        let wsEndpointCallback;
        const shouldWaitForWSListening = options2.useWebSocket || ((_options$args = options2.args) === null || _options$args === void 0 ? void 0 : _options$args.some((a) => a.startsWith("--remote-debugging-port")));
        const waitForWSEndpoint = shouldWaitForWSListening ? new Promise((f) => wsEndpointCallback = f) : void 0;
        let transport = void 0;
        let browserProcess = void 0;
        const {
          launchedProcess,
          gracefullyClose,
          kill
        } = await (0, _processLauncher.launchProcess)({
          command: executable,
          args: browserArguments,
          env: this._amendEnvironment(env, userDataDir, executable, browserArguments),
          handleSIGINT,
          handleSIGTERM,
          handleSIGHUP,
          log: (message) => {
            if (wsEndpointCallback) {
              const match = message.match(/DevTools listening on (.*)/);
              if (match)
                wsEndpointCallback(match[1]);
            }
            progress.log(message);
            browserLogsCollector.log(message);
          },
          stdio: "pipe",
          tempDirectories,
          attemptToGracefullyClose: async () => {
            if (options2.__testHookGracefullyClose)
              await options2.__testHookGracefullyClose();
            this._attemptToGracefullyCloseBrowser(transport);
          },
          onExit: (exitCode, signal) => {
            if (browserProcess && browserProcess.onclose)
              browserProcess.onclose(exitCode, signal);
          }
        });
        async function closeOrKill(timeout) {
          let timer;
          try {
            await Promise.race([gracefullyClose(), new Promise((resolve3, reject) => timer = setTimeout(reject, timeout))]);
          } catch (ignored) {
            await kill().catch((ignored2) => {
            });
          } finally {
            clearTimeout(timer);
          }
        }
        browserProcess = {
          onclose: void 0,
          process: launchedProcess,
          close: () => closeOrKill(options2.__testHookBrowserCloseTimeout || _timeoutSettings.DEFAULT_TIMEOUT),
          kill
        };
        progress.cleanupWhenAborted(() => closeOrKill(progress.timeUntilDeadline()));
        let wsEndpoint;
        if (shouldWaitForWSListening)
          wsEndpoint = await waitForWSEndpoint;
        if (options2.useWebSocket) {
          transport = await _transport.WebSocketTransport.connect(progress, wsEndpoint);
        } else {
          const stdio = launchedProcess.stdio;
          transport = new _pipeTransport.PipeTransport(stdio[3], stdio[4]);
        }
        return {
          browserProcess,
          artifactsDir,
          transport
        };
      }
      async connectOverCDP(metadata, endpointURL, options2, timeout) {
        throw new Error("CDP connections are only supported by Chromium");
      }
      async _launchWithSeleniumHub(progress, hubUrl, options2) {
        throw new Error("Connecting to SELENIUM_REMOTE_URL is only supported by Chromium");
      }
      _validateLaunchOptions(options2) {
        const {
          devtools = false
        } = options2;
        let {
          headless = !devtools,
          downloadsPath,
          proxy
        } = options2;
        if ((0, _utils.debugMode)())
          headless = false;
        if (downloadsPath && !_path.default.isAbsolute(downloadsPath))
          downloadsPath = _path.default.join(process.cwd(), downloadsPath);
        if (this._playwrightOptions.socksProxyPort)
          proxy = {
            server: `socks5://127.0.0.1:${this._playwrightOptions.socksProxyPort}`
          };
        return __spreadProps(__spreadValues({}, options2), {
          devtools,
          headless,
          downloadsPath,
          proxy
        });
      }
    };
    exports.BrowserType = BrowserType;
    function copyTestHooks(from, to) {
      for (const [key, value] of Object.entries(from)) {
        if (key.startsWith("__testHook"))
          to[key] = value;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crDevTools.js
var require_crDevTools = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crDevTools.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CRDevTools = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kBindingName = "__pw_devtools__";
    var CRDevTools = class {
      constructor(preferencesPath) {
        this._preferencesPath = void 0;
        this._prefs = void 0;
        this._savePromise = void 0;
        this.__testHookOnBinding = void 0;
        this._preferencesPath = preferencesPath;
        this._savePromise = Promise.resolve();
      }
      install(session) {
        session.on("Runtime.bindingCalled", async (event) => {
          if (event.name !== kBindingName)
            return;
          const parsed = JSON.parse(event.payload);
          let result = void 0;
          if (this.__testHookOnBinding)
            this.__testHookOnBinding(parsed);
          if (parsed.method === "getPreferences") {
            if (this._prefs === void 0) {
              try {
                const json = await _fs.default.promises.readFile(this._preferencesPath, "utf8");
                this._prefs = JSON.parse(json);
              } catch (e) {
                this._prefs = {};
              }
            }
            result = this._prefs;
          } else if (parsed.method === "setPreference") {
            this._prefs[parsed.params[0]] = parsed.params[1];
            this._save();
          } else if (parsed.method === "removePreference") {
            delete this._prefs[parsed.params[0]];
            this._save();
          } else if (parsed.method === "clearPreferences") {
            this._prefs = {};
            this._save();
          }
          session.send("Runtime.evaluate", {
            expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
            contextId: event.executionContextId
          }).catch((e) => null);
        });
        Promise.all([session.send("Runtime.enable"), session.send("Runtime.addBinding", {
          name: kBindingName
        }), session.send("Page.enable"), session.send("Page.addScriptToEvaluateOnNewDocument", {
          source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      `
        }), session.send("Runtime.runIfWaitingForDebugger")]).catch((e) => null);
      }
      _save() {
        this._savePromise = this._savePromise.then(async () => {
          await _fs.default.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch((e) => null);
        });
      }
    };
    exports.CRDevTools = CRDevTools;
  }
});

// node_modules/playwright-core/lib/server/chromium/chromium.js
var require_chromium = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/chromium.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Chromium = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var _os = _interopRequireDefault(__require("os"));
    var _path = _interopRequireDefault(__require("path"));
    var _crBrowser = require_crBrowser();
    var _processLauncher = require_processLauncher();
    var _crConnection = require_crConnection();
    var _stackTrace = require_stackTrace();
    var _browserType = require_browserType();
    var _transport = require_transport2();
    var _crDevTools = require_crDevTools();
    var _browser = require_browser2();
    var _utils = require_utils();
    var _debugLogger = require_debugLogger();
    var _progress = require_progress2();
    var _timeoutSettings = require_timeoutSettings();
    var _helper = require_helper();
    var _http = _interopRequireDefault(__require("http"));
    var _https = _interopRequireDefault(__require("https"));
    var _registry = require_registry();
    var _async = require_async();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), "playwright-artifacts-");
    var Chromium = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("chromium", playwrightOptions);
        this._devtools = void 0;
        if ((0, _utils.debugMode)())
          this._devtools = this._createDevTools();
      }
      async connectOverCDP(metadata, endpointURL, options2, timeout) {
        const controller = new _progress.ProgressController(metadata, this);
        controller.setLogName("browser");
        return controller.run(async (progress) => {
          return await this._connectOverCDPInternal(progress, endpointURL, options2);
        }, _timeoutSettings.TimeoutSettings.timeout({
          timeout
        }));
      }
      async _connectOverCDPInternal(progress, endpointURL, options2, onClose) {
        let headersMap;
        if (options2.headers)
          headersMap = (0, _utils.headersArrayToObject)(options2.headers, false);
        const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
        const wsEndpoint = await urlToWSEndpoint(progress, endpointURL);
        progress.throwIfAborted();
        const chromeTransport = await _transport.WebSocketTransport.connect(progress, wsEndpoint, headersMap);
        const cleanedUp = new _async.ManualPromise();
        const doCleanup = async () => {
          await (0, _utils.removeFolders)([artifactsDir]);
          await (onClose === null || onClose === void 0 ? void 0 : onClose());
          cleanedUp.resolve();
        };
        const doClose = async () => {
          await chromeTransport.closeAndWait();
          await cleanedUp;
        };
        const browserProcess = {
          close: doClose,
          kill: doClose
        };
        const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
          slowMo: options2.slowMo,
          name: "chromium",
          isChromium: true,
          persistent: {
            noDefaultViewport: true
          },
          browserProcess,
          protocolLogger: _helper.helper.debugProtocolLogger(),
          browserLogsCollector: new _debugLogger.RecentLogsCollector(),
          artifactsDir,
          downloadsPath: artifactsDir,
          tracesDir: artifactsDir,
          proxy: {
            server: "per-context"
          }
        });
        progress.throwIfAborted();
        const browser = await _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);
        browser.on(_browser.Browser.Events.Disconnected, doCleanup);
        return browser;
      }
      _createDevTools() {
        const directory = _registry.registry.findExecutable("chromium").directory;
        return directory ? new _crDevTools.CRDevTools(_path.default.join(directory, "devtools-preferences.json")) : void 0;
      }
      async _connectToTransport(transport, options2) {
        let devtools = this._devtools;
        if (options2.__testHookForDevTools) {
          devtools = this._createDevTools();
          await options2.__testHookForDevTools(devtools);
        }
        return _crBrowser.CRBrowser.connect(transport, options2, devtools);
      }
      _rewriteStartupError(error2) {
        if (!error2.message.includes("crbug.com/357670") && !error2.message.includes("No usable sandbox!") && !error2.message.includes("crbug.com/638180"))
          return error2;
        return (0, _stackTrace.rewriteErrorMessage)(error2, [`Chromium sandboxing failed!`, `================================`, `To workaround sandboxing issues, do either of the following:`, `  - (preferred): Configure environment to support sandboxing: https://github.com/microsoft/playwright/blob/master/docs/troubleshooting.md`, `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`, `================================`, ``].join("\n"));
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return env;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {
          method: "Browser.close",
          id: _crConnection.kBrowserCloseMessageId,
          params: {}
        };
        transport.send(message);
      }
      async _launchWithSeleniumHub(progress, hubUrl, options2) {
        if (!hubUrl.endsWith("/"))
          hubUrl = hubUrl + "/";
        const args = this._innerDefaultArgs(options2);
        args.push("--remote-debugging-port=0");
        const desiredCapabilities = {
          "browserName": "chrome",
          "goog:chromeOptions": {
            args
          }
        };
        progress.log(`<selenium> connecting to ${hubUrl}`);
        const response = await (0, _utils.fetchData)({
          url: hubUrl + "session",
          method: "POST",
          data: JSON.stringify({
            desiredCapabilities,
            capabilities: {
              alwaysMatch: desiredCapabilities
            }
          }),
          timeout: progress.timeUntilDeadline()
        }, seleniumErrorHandler);
        const value = JSON.parse(response).value;
        const sessionId = value.sessionId;
        progress.log(`<selenium> connected to sessionId=${sessionId}`);
        const disconnectFromSelenium = async () => {
          progress.log(`<selenium> disconnecting from sessionId=${sessionId}`);
          await (0, _utils.fetchData)({
            url: hubUrl + "session/" + sessionId,
            method: "DELETE"
          }).catch((error2) => progress.log(`<error disconnecting from selenium>: ${error2}`));
          progress.log(`<selenium> disconnected from sessionId=${sessionId}`);
          _processLauncher.gracefullyCloseSet.delete(disconnectFromSelenium);
        };
        _processLauncher.gracefullyCloseSet.add(disconnectFromSelenium);
        try {
          const capabilities = value.capabilities;
          let endpointURL;
          if (capabilities["se:cdp"]) {
            const endpointURLString = addProtocol(capabilities["se:cdp"]);
            endpointURL = new URL(endpointURLString);
            endpointURL.hostname = new URL(hubUrl).hostname;
            progress.log(`<selenium> retrieved endpoint ${endpointURL.toString()} for sessionId=${sessionId}`);
          } else {
            const maybeChromeOptions = capabilities["goog:chromeOptions"];
            const chromeOptions = maybeChromeOptions && typeof maybeChromeOptions === "object" ? maybeChromeOptions : void 0;
            const debuggerAddress = chromeOptions && typeof chromeOptions.debuggerAddress === "string" ? chromeOptions.debuggerAddress : void 0;
            const chromeOptionsURL = typeof maybeChromeOptions === "string" ? maybeChromeOptions : void 0;
            const endpointURLString = addProtocol(debuggerAddress || chromeOptionsURL);
            progress.log(`<selenium> retrieved endpoint ${endpointURLString} for sessionId=${sessionId}`);
            endpointURL = new URL(endpointURLString);
            if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1") {
              const sessionInfoUrl = new URL(hubUrl).origin + "/grid/api/testsession?session=" + sessionId;
              try {
                const sessionResponse = await (0, _utils.fetchData)({
                  url: sessionInfoUrl,
                  method: "GET",
                  timeout: progress.timeUntilDeadline()
                }, seleniumErrorHandler);
                const proxyId = JSON.parse(sessionResponse).proxyId;
                endpointURL.hostname = new URL(proxyId).hostname;
                progress.log(`<selenium> resolved endpoint ip ${endpointURL.toString()} for sessionId=${sessionId}`);
              } catch (e) {
                progress.log(`<selenium> unable to resolve endpoint ip for sessionId=${sessionId}, running in standalone?`);
              }
            }
          }
          return await this._connectOverCDPInternal(progress, endpointURL.toString(), {
            slowMo: options2.slowMo
          }, disconnectFromSelenium);
        } catch (e) {
          await disconnectFromSelenium();
          throw e;
        }
      }
      _defaultArgs(options2, isPersistent, userDataDir) {
        const chromeArguments = this._innerDefaultArgs(options2);
        chromeArguments.push(`--user-data-dir=${userDataDir}`);
        if (options2.useWebSocket)
          chromeArguments.push("--remote-debugging-port=0");
        else
          chromeArguments.push("--remote-debugging-pipe");
        if (isPersistent)
          chromeArguments.push("about:blank");
        else
          chromeArguments.push("--no-startup-window");
        return chromeArguments;
      }
      _innerDefaultArgs(options2) {
        const {
          args = [],
          proxy
        } = options2;
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
          throw new Error("Playwright manages remote debugging connection itself.");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const chromeArguments = [...DEFAULT_ARGS];
        if (_os.default.platform() === "darwin")
          chromeArguments.push("--enable-use-zoom-for-dsf=false");
        if (options2.devtools)
          chromeArguments.push("--auto-open-devtools-for-tabs");
        if (options2.headless) {
          chromeArguments.push("--headless", "--hide-scrollbars", "--mute-audio", "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4");
        }
        if (options2.chromiumSandbox !== true)
          chromeArguments.push("--no-sandbox");
        if (proxy) {
          const proxyURL = new URL(proxy.server);
          const isSocks = proxyURL.protocol === "socks5:";
          if (isSocks && !this._playwrightOptions.socksProxyPort) {
            chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
          }
          chromeArguments.push(`--proxy-server=${proxy.server}`);
          const proxyBypassRules = [];
          if (this._playwrightOptions.socksProxyPort)
            proxyBypassRules.push("<-loopback>");
          if (proxy.bypass)
            proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
          if (proxyBypassRules.length > 0)
            chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
        }
        chromeArguments.push(...args);
        return chromeArguments;
      }
    };
    exports.Chromium = Chromium;
    var DEFAULT_ARGS = [
      "--disable-background-networking",
      "--enable-features=NetworkService,NetworkServiceInProcess",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-component-extensions-with-background-pages",
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-extensions",
      "--disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,AcceptCHFrame",
      "--allow-pre-commit-input",
      "--disable-hang-monitor",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--disable-sync",
      "--force-color-profile=srgb",
      "--metrics-recording-only",
      "--no-first-run",
      "--enable-automation",
      "--password-store=basic",
      "--use-mock-keychain",
      "--no-service-autorun"
    ];
    async function urlToWSEndpoint(progress, endpointURL) {
      if (endpointURL.startsWith("ws"))
        return endpointURL;
      progress.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
      const httpURL = endpointURL.endsWith("/") ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;
      const request = endpointURL.startsWith("https") ? _https.default : _http.default;
      const json = await new Promise((resolve3, reject) => {
        request.get(httpURL, (resp) => {
          if (resp.statusCode < 200 || resp.statusCode >= 400) {
            reject(new Error(`Unexpected status ${resp.statusCode} when connecting to ${httpURL}.
This does not look like a DevTools server, try connecting via ws://.`));
          }
          let data = "";
          resp.on("data", (chunk) => data += chunk);
          resp.on("end", () => resolve3(data));
        }).on("error", reject);
      });
      return JSON.parse(json).webSocketDebuggerUrl;
    }
    async function seleniumErrorHandler(params, response) {
      const body = await (0, _utils.streamToString)(response);
      let message = body;
      try {
        const json = JSON.parse(body);
        message = json.value.localizedMessage || json.value.message;
      } catch (e) {
      }
      return new Error(`Error connecting to Selenium at ${params.url}: ${message}`);
    }
    function addProtocol(url) {
      if (!["ws://", "wss://", "http://", "https://"].some((protocol) => url.startsWith(protocol)))
        return "http://" + url;
      return url;
    }
  }
});

// node_modules/electron/index.js
var require_electron = __commonJS({
  "node_modules/electron/index.js"(exports, module) {
    init_shims();
    var fs2 = __require("fs");
    var path = __require("path");
    var pathFile = path.join(__dirname, "path.txt");
    function getElectronPath() {
      let executablePath;
      if (fs2.existsSync(pathFile)) {
        executablePath = fs2.readFileSync(pathFile, "utf-8");
      }
      if (process.env.ELECTRON_OVERRIDE_DIST_PATH) {
        return path.join(process.env.ELECTRON_OVERRIDE_DIST_PATH, executablePath || "electron");
      }
      if (executablePath) {
        return path.join(__dirname, "dist", executablePath);
      } else {
        throw new Error("Electron failed to install correctly, please delete node_modules/electron and try installing again");
      }
    }
    module.exports = getElectronPath();
  }
});

// node_modules/playwright-core/lib/server/electron/electron.js
var require_electron2 = __commonJS({
  "node_modules/playwright-core/lib/server/electron/electron.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Electron = exports.ElectronApplication = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var _os = _interopRequireDefault(__require("os"));
    var _path = _interopRequireDefault(__require("path"));
    var _crBrowser = require_crBrowser();
    var _crConnection = require_crConnection();
    var _crExecutionContext = require_crExecutionContext();
    var js = _interopRequireWildcard(require_javascript());
    var _timeoutSettings = require_timeoutSettings();
    var _transport = require_transport2();
    var _processLauncher = require_processLauncher();
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var readline = _interopRequireWildcard(__require("readline"));
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), "playwright-artifacts-");
    var ElectronApplication = class extends _instrumentation.SdkObject {
      constructor(parent, browser, nodeConnection) {
        super(parent, "electron-app");
        this._browserContext = void 0;
        this._nodeConnection = void 0;
        this._nodeSession = void 0;
        this._nodeExecutionContext = void 0;
        this._nodeElectronHandlePromise = void 0;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._browserContext = browser._defaultContext;
        this._browserContext.on(_browserContext.BrowserContext.Events.Close, () => {
          Promise.resolve().then(() => this.emit(ElectronApplication.Events.Close));
        });
        this._nodeConnection = nodeConnection;
        this._nodeSession = nodeConnection.rootSession;
        this._nodeElectronHandlePromise = new Promise((f) => {
          this._nodeSession.on("Runtime.executionContextCreated", async (event) => {
            if (event.context.auxData && event.context.auxData.isDefault) {
              this._nodeExecutionContext = new js.ExecutionContext(this, new _crExecutionContext.CRExecutionContext(this._nodeSession, event.context));
              f(await js.evaluate(this._nodeExecutionContext, false, `process.mainModule.require('electron')`));
            }
          });
        });
        this._nodeSession.send("Runtime.enable", {}).catch((e) => {
        });
      }
      context() {
        return this._browserContext;
      }
      async close() {
        const progressController = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), this);
        const closed = progressController.run((progress) => _helper.helper.waitForEvent(progress, this, ElectronApplication.Events.Close).promise, this._timeoutSettings.timeout({}));
        const electronHandle = await this._nodeElectronHandlePromise;
        await electronHandle.evaluate(({
          app
        }) => app.quit());
        this._nodeConnection.close();
        await closed;
      }
      async browserWindow(page) {
        const targetId = page._delegate._targetId;
        const electronHandle = await this._nodeElectronHandlePromise;
        return await electronHandle.evaluateHandle(({
          BrowserWindow,
          webContents
        }, targetId2) => {
          const wc = webContents.fromDevToolsTargetId(targetId2);
          return BrowserWindow.fromWebContents(wc);
        }, targetId);
      }
    };
    exports.ElectronApplication = ElectronApplication;
    ElectronApplication.Events = {
      Close: "close"
    };
    var Electron = class extends _instrumentation.SdkObject {
      constructor(playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "electron");
        this._playwrightOptions = void 0;
        this._playwrightOptions = playwrightOptions;
      }
      async launch(options2) {
        const {
          args = []
        } = options2;
        const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), this);
        controller.setLogName("browser");
        return controller.run(async (progress) => {
          let app = void 0;
          const electronArguments = ["--inspect=0", "--remote-debugging-port=0", ...args];
          if (_os.default.platform() === "linux") {
            const runningAsRoot = process.geteuid && process.geteuid() === 0;
            if (runningAsRoot && electronArguments.indexOf("--no-sandbox") === -1)
              electronArguments.push("--no-sandbox");
          }
          const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
          const browserLogsCollector = new _debugLogger.RecentLogsCollector();
          const {
            launchedProcess,
            gracefullyClose,
            kill
          } = await (0, _processLauncher.launchProcess)({
            command: options2.executablePath || require_electron(),
            args: electronArguments,
            env: options2.env ? (0, _processLauncher.envArrayToObject)(options2.env) : process.env,
            log: (message) => {
              progress.log(message);
              browserLogsCollector.log(message);
            },
            stdio: "pipe",
            cwd: options2.cwd,
            tempDirectories: [artifactsDir],
            attemptToGracefullyClose: () => app.close(),
            handleSIGINT: true,
            handleSIGTERM: true,
            handleSIGHUP: true,
            onExit: () => {
            }
          });
          const waitForXserverError = new Promise(async (resolve3, reject) => {
            waitForLine(progress, launchedProcess, /Unable to open X display/).then(() => reject(new Error(["Unable to open X display!", `================================`, "Most likely this is because there is no X server available.", "Use 'xvfb-run' on Linux to launch your tests with an emulated display server.", "For example: 'xvfb-run npm run test:e2e'", `================================`, progress.metadata.log].join("\n")))).catch(() => {
            });
          });
          const nodeMatch = await waitForLine(progress, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
          const nodeTransport = await _transport.WebSocketTransport.connect(progress, nodeMatch[1]);
          const nodeConnection = new _crConnection.CRConnection(nodeTransport, _helper.helper.debugProtocolLogger(), browserLogsCollector);
          const chromeMatch = await Promise.race([waitForLine(progress, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/), waitForXserverError]);
          const chromeTransport = await _transport.WebSocketTransport.connect(progress, chromeMatch[1]);
          const browserProcess = {
            onclose: void 0,
            process: launchedProcess,
            close: gracefullyClose,
            kill
          };
          const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
            name: "electron",
            isChromium: true,
            headful: true,
            persistent: {
              noDefaultViewport: true,
              acceptDownloads: options2.acceptDownloads,
              bypassCSP: options2.bypassCSP,
              colorScheme: options2.colorScheme,
              extraHTTPHeaders: options2.extraHTTPHeaders,
              geolocation: options2.geolocation,
              httpCredentials: options2.httpCredentials,
              ignoreHTTPSErrors: options2.ignoreHTTPSErrors,
              locale: options2.locale,
              offline: options2.offline,
              recordHar: options2.recordHar,
              recordVideo: options2.recordVideo,
              timezoneId: options2.timezoneId
            },
            browserProcess,
            protocolLogger: _helper.helper.debugProtocolLogger(),
            browserLogsCollector,
            artifactsDir,
            downloadsPath: artifactsDir,
            tracesDir: artifactsDir
          });
          const browser = await _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);
          app = new ElectronApplication(this, browser, nodeConnection);
          return app;
        }, _timeoutSettings.TimeoutSettings.timeout(options2));
      }
    };
    exports.Electron = Electron;
    function waitForLine(progress, process2, regex) {
      return new Promise((resolve3, reject) => {
        const rl = readline.createInterface({
          input: process2.stderr
        });
        const failError = new Error("Process failed to launch!");
        const listeners = [
          _eventsHelper.eventsHelper.addEventListener(rl, "line", onLine),
          _eventsHelper.eventsHelper.addEventListener(rl, "close", reject.bind(null, failError)),
          _eventsHelper.eventsHelper.addEventListener(process2, "exit", reject.bind(null, failError)),
          _eventsHelper.eventsHelper.addEventListener(process2, "error", reject.bind(null, failError))
        ];
        progress.cleanupWhenAborted(cleanup);
        function onLine(line) {
          const match = line.match(regex);
          if (!match)
            return;
          cleanup();
          resolve3(match);
        }
        function cleanup() {
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffConnection.js
var require_ffConnection = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffConnection.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FFSession = exports.FFSessionEvents = exports.FFConnection = exports.kBrowserCloseMessageId = exports.ConnectionEvents = void 0;
    var _events = __require("events");
    var _utils = require_utils();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _protocolError = require_protocolError();
    var ConnectionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports.ConnectionEvents = ConnectionEvents;
    var kBrowserCloseMessageId = -9999;
    exports.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var FFConnection = class extends _events.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = void 0;
        this._callbacks = void 0;
        this._transport = void 0;
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this._sessions = void 0;
        this._closed = void 0;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._lastId = 0;
        this._callbacks = new Map();
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._sessions = new Map();
        this._closed = false;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      async send(method, params) {
        this._checkClosed(method);
        const id = this.nextMessageId();
        this._rawSend({
          id,
          method,
          params
        });
        return new Promise((resolve3, reject) => {
          this._callbacks.set(id, {
            resolve: resolve3,
            reject,
            error: new _protocolError.ProtocolError(false),
            method
          });
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      _checkClosed(method) {
        if (this._closed)
          throw new _protocolError.ProtocolError(true, `${method}): Browser closed.` + _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs()));
      }
      _rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      async _onMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === kBrowserCloseMessageId)
          return;
        if (message.sessionId) {
          const session = this._sessions.get(message.sessionId);
          if (session)
            session.dispatchMessage(message);
        } else if (message.id) {
          const callback = this._callbacks.get(message.id);
          if (callback) {
            this._callbacks.delete(message.id);
            if (message.error)
              callback.reject(createProtocolError(callback.error, callback.method, message.error));
            else
              callback.resolve(message.result);
          }
        } else {
          Promise.resolve().then(() => this.emit(message.method, message.params));
        }
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const formattedBrowserLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session.dispose();
        this._sessions.clear();
        for (const callback of this._callbacks.values()) {
          const error2 = (0, _stackTrace.rewriteErrorMessage)(callback.error, `Protocol error (${callback.method}): Browser closed.` + formattedBrowserLogs);
          error2.sessionClosed = true;
          callback.reject(error2);
        }
        this._callbacks.clear();
        Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      createSession(sessionId) {
        const session = new FFSession(this, sessionId, (message) => this._rawSend(__spreadProps(__spreadValues({}, message), {
          sessionId
        })));
        this._sessions.set(sessionId, session);
        return session;
      }
    };
    exports.FFConnection = FFConnection;
    var FFSessionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports.FFSessionEvents = FFSessionEvents;
    var FFSession = class extends _events.EventEmitter {
      constructor(connection, sessionId, rawSend) {
        super();
        this._connection = void 0;
        this._disposed = false;
        this._callbacks = void 0;
        this._sessionId = void 0;
        this._rawSend = void 0;
        this._crashed = false;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this._callbacks = new Map();
        this._connection = connection;
        this._sessionId = sessionId;
        this._rawSend = rawSend;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      markAsCrashed() {
        this._crashed = true;
      }
      async send(method, params) {
        if (this._crashed)
          throw new _protocolError.ProtocolError(true, "Target crashed");
        this._connection._checkClosed(method);
        if (this._disposed)
          throw new _protocolError.ProtocolError(true, "Target closed");
        const id = this._connection.nextMessageId();
        this._rawSend({
          method,
          params,
          id
        });
        return new Promise((resolve3, reject) => {
          this._callbacks.set(id, {
            resolve: resolve3,
            reject,
            error: new _protocolError.ProtocolError(false),
            method
          });
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error2) => _debugLogger.debugLogger.log("error", error2));
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          (0, _utils.assert)(!object.id);
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
      dispose() {
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, "Target closed"));
        }
        this._callbacks.clear();
        this._disposed = true;
        this._connection._sessions.delete(this._sessionId);
        Promise.resolve().then(() => this.emit(FFSessionEvents.Disconnected));
      }
    };
    exports.FFSession = FFSession;
    function createProtocolError(error2, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return (0, _stackTrace.rewriteErrorMessage)(error2, message);
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffAccessibility.js
var require_ffAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffAccessibility.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getAccessibilityTree = getAccessibilityTree;
    async function getAccessibilityTree(session, needle) {
      const objectId = needle ? needle._objectId : void 0;
      const {
        tree
      } = await session.send("Accessibility.getFullAXTree", {
        objectId
      });
      const axNode = new FFAXNode(tree);
      return {
        tree: axNode,
        needle: needle ? axNode._findNeedle() : null
      };
    }
    var FFRoleToARIARole = new Map(Object.entries({
      "pushbutton": "button",
      "checkbutton": "checkbox",
      "editcombobox": "combobox",
      "content deletion": "deletion",
      "footnote": "doc-footnote",
      "non-native document": "document",
      "grouping": "group",
      "graphic": "img",
      "content insertion": "insertion",
      "animation": "marquee",
      "flat equation": "math",
      "menupopup": "menu",
      "check menu item": "menuitemcheckbox",
      "radio menu item": "menuitemradio",
      "listbox option": "option",
      "radiobutton": "radio",
      "statusbar": "status",
      "pagetab": "tab",
      "pagetablist": "tablist",
      "propertypage": "tabpanel",
      "entry": "textbox",
      "outline": "tree",
      "tree table": "treegrid",
      "outlineitem": "treeitem"
    }));
    var FFAXNode = class {
      constructor(payload) {
        this._children = void 0;
        this._payload = void 0;
        this._editable = void 0;
        this._richlyEditable = void 0;
        this._focusable = void 0;
        this._expanded = void 0;
        this._name = void 0;
        this._role = void 0;
        this._cachedHasFocusableChild = void 0;
        this._payload = payload;
        this._children = (payload.children || []).map((x) => new FFAXNode(x));
        this._editable = !!payload.editable;
        this._richlyEditable = this._editable && payload.tag !== "textarea" && payload.tag !== "input";
        this._focusable = !!payload.focusable;
        this._expanded = !!payload.expanded;
        this._name = this._payload.name;
        this._role = this._payload.role;
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "entry";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "text leaf" || role === "text" || role === "statictext";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.foundObject)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "graphic":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "document" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "checkbutton":
          case "check menu item":
          case "check rich option":
          case "combobox":
          case "combobox option":
          case "color chooser":
          case "listbox":
          case "listbox option":
          case "listbox rich option":
          case "popup menu":
          case "menupopup":
          case "menuitem":
          case "menubar":
          case "button":
          case "pushbutton":
          case "radiobutton":
          case "radio menuitem":
          case "scrollbar":
          case "slider":
          case "spinbutton":
          case "switch":
          case "pagetab":
          case "entry":
          case "tree table":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name.trim();
      }
      serialize() {
        const node = {
          role: FFRoleToARIARole.get(this._role) || this._role,
          name: this._name || ""
        };
        const userStringProperties = ["name", "description", "roledescription", "valuetext", "keyshortcuts"];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (this._role === "document" && booleanProperty === "focused")
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level"];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid", "orientation"];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        axNode.valueString = this._payload.value;
        if ("checked" in this._payload)
          axNode.checked = this._payload.checked === true ? "checked" : this._payload.checked === "mixed" ? "mixed" : "unchecked";
        if ("pressed" in this._payload)
          axNode.pressed = this._payload.pressed === true ? "pressed" : "released";
        return axNode;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js
var require_ffExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FFExecutionContext = void 0;
    var js = _interopRequireWildcard(require_javascript());
    var _stackTrace = require_stackTrace();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFExecutionContext = class {
      constructor(session, executionContextId) {
        this._session = void 0;
        this._executionContextId = void 0;
        this._session = session;
        this._executionContextId = executionContextId;
      }
      async rawEvaluateJSON(expression) {
        const payload = await this._session.send("Runtime.evaluate", {
          expression,
          returnByValue: true,
          executionContextId: this._executionContextId
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        return payload.result.value;
      }
      async rawEvaluateHandle(expression) {
        const payload = await this._session.send("Runtime.evaluate", {
          expression,
          returnByValue: false,
          executionContextId: this._executionContextId
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        return payload.result.objectId;
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunction", {
          functionDeclaration: func.toString(),
          args: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          executionContextId: this._executionContextId
        }).catch(() => {
        });
      }
      async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        const payload = await this._session.send("Runtime.callFunction", {
          functionDeclaration: expression,
          args: [{
            objectId: utilityScript._objectId,
            value: void 0
          }, ...values.map((value) => ({
            value
          })), ...objectIds.map((objectId) => ({
            objectId,
            value: void 0
          }))],
          returnByValue,
          executionContextId: this._executionContextId
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        if (returnByValue)
          return (0, _utilityScriptSerializers.parseEvaluationResultValue)(payload.result.value);
        return utilityScript._context.createHandle(payload.result);
      }
      async getProperties(context, objectId) {
        const response = await this._session.send("Runtime.getObjectProperties", {
          executionContextId: this._executionContextId,
          objectId
        });
        const result = new Map();
        for (const property of response.properties)
          result.set(property.name, context.createHandle(property.value));
        return result;
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type || "", renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      async releaseHandle(objectId) {
        await this._session.send("Runtime.disposeObject", {
          executionContextId: this._executionContextId,
          objectId
        });
      }
    };
    exports.FFExecutionContext = FFExecutionContext;
    function checkException(exceptionDetails) {
      if (!exceptionDetails)
        return;
      if (exceptionDetails.value)
        throw new js.JavaScriptErrorInEvaluate(JSON.stringify(exceptionDetails.value));
      else
        throw new js.JavaScriptErrorInEvaluate(exceptionDetails.text + (exceptionDetails.stack ? "\n" + exceptionDetails.stack : ""));
    }
    function rewriteError(error2) {
      if (error2.message.includes("cyclic object value") || error2.message.includes("Object is not serializable"))
        return {
          result: {
            type: "undefined",
            value: void 0
          }
        };
      if (error2 instanceof TypeError && error2.message.startsWith("Converting circular structure to JSON"))
        (0, _stackTrace.rewriteErrorMessage)(error2, error2.message + " Are you passing a nested JSHandle?");
      if (!js.isJavaScriptErrorInEvaluate(error2) && !(0, _protocolError.isSessionClosedError)(error2))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      throw error2;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if (object.unserializableValue)
        return String(object.unserializableValue);
      if (object.type === "symbol")
        return "Symbol()";
      if (object.subtype === "regexp")
        return "RegExp";
      if (object.subtype === "weakmap")
        return "WeakMap";
      if (object.subtype === "weakset")
        return "WeakSet";
      if (object.subtype)
        return object.subtype[0].toUpperCase() + object.subtype.slice(1);
      if ("value" in object)
        return String(object.value);
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffInput.js
var require_ffInput = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffInput.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Shift"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonNumber(button) {
      if (button === "left")
        return 0;
      if (button === "middle")
        return 1;
      if (button === "right")
        return 2;
      return 0;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        if (code === "MetaLeft")
          code = "OSLeft";
        if (code === "MetaRight")
          code = "OSRight";
        if (text === "\r")
          text = "";
        await this._client.send("Page.dispatchKeyEvent", {
          type: "keydown",
          keyCode: keyCodeWithoutLocation,
          code,
          key,
          repeat: autoRepeat,
          location: location2,
          text
        });
      }
      async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        if (code === "MetaLeft")
          code = "OSLeft";
        if (code === "MetaRight")
          code = "OSRight";
        await this._client.send("Page.dispatchKeyEvent", {
          type: "keyup",
          key,
          keyCode: keyCodeWithoutLocation,
          code,
          location: location2,
          repeat: false
        });
      }
      async sendText(text) {
        await this._client.send("Page.insertText", {
          text
        });
      }
    };
    exports.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(client) {
        this._client = void 0;
        this._page = void 0;
        this._client = client;
      }
      async move(x, y, button, buttons, modifiers) {
        await this._client.send("Page.dispatchMouseEvent", {
          type: "mousemove",
          button: 0,
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
      async down(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send("Page.dispatchMouseEvent", {
          type: "mousedown",
          button: toButtonNumber(button),
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
      async up(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send("Page.dispatchMouseEvent", {
          type: "mouseup",
          button: toButtonNumber(button),
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
      async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, "utility");
        await this._client.send("Page.dispatchWheelEvent", {
          deltaX,
          deltaY,
          x,
          y,
          deltaZ: 0,
          modifiers: toModifiersMask(modifiers)
        });
      }
      setPage(page) {
        this._page = page;
      }
    };
    exports.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      async tap(x, y, modifiers) {
        await this._client.send("Page.dispatchTapEvent", {
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
    };
    exports.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js
var require_ffNetworkManager = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FFNetworkManager = void 0;
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFNetworkManager = class {
      constructor(session, page) {
        this._session = void 0;
        this._requests = void 0;
        this._page = void 0;
        this._eventListeners = void 0;
        this._session = session;
        this._requests = new Map();
        this._page = page;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestFinished", this._onRequestFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestFailed", this._onRequestFailed.bind(this))];
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      async setRequestInterception(enabled) {
        await this._session.send("Network.setRequestInterception", {
          enabled
        });
      }
      _onRequestWillBeSent(event) {
        const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;
        const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page._frameManager.frame(event.frameId) : null;
        if (!frame)
          return;
        if (redirectedFrom)
          this._requests.delete(redirectedFrom._id);
        const request = new InterceptableRequest(frame, redirectedFrom, event);
        let route;
        if (event.isIntercepted)
          route = new FFRouteImpl(this._session, request);
        this._requests.set(request._id, request);
        this._page._frameManager.requestStarted(request.request, route);
      }
      _onResponseReceived(event) {
        var _event$securityDetail, _event$securityDetail2, _event$securityDetail3, _event$securityDetail4, _event$securityDetail5;
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const getResponseBody = async () => {
          const response2 = await this._session.send("Network.getResponseBody", {
            requestId: request._id
          });
          if (response2.evicted)
            throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);
          return Buffer.from(response2.base64body, "base64");
        };
        const startTime = event.timing.startTime;
        function relativeToStart(time) {
          if (!time)
            return -1;
          return (time - startTime) / 1e3;
        }
        const timing = {
          startTime: startTime / 1e3,
          domainLookupStart: relativeToStart(event.timing.domainLookupStart),
          domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),
          connectStart: relativeToStart(event.timing.connectStart),
          secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),
          connectEnd: relativeToStart(event.timing.connectEnd),
          requestStart: relativeToStart(event.timing.requestStart),
          responseStart: relativeToStart(event.timing.responseStart)
        };
        const response = new network.Response(request.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody);
        if (event !== null && event !== void 0 && event.remoteIPAddress && typeof (event === null || event === void 0 ? void 0 : event.remotePort) === "number") {
          response._serverAddrFinished({
            ipAddress: event.remoteIPAddress,
            port: event.remotePort
          });
        } else {
          response._serverAddrFinished();
        }
        response._securityDetailsFinished({
          protocol: event === null || event === void 0 ? void 0 : (_event$securityDetail = event.securityDetails) === null || _event$securityDetail === void 0 ? void 0 : _event$securityDetail.protocol,
          subjectName: event === null || event === void 0 ? void 0 : (_event$securityDetail2 = event.securityDetails) === null || _event$securityDetail2 === void 0 ? void 0 : _event$securityDetail2.subjectName,
          issuer: event === null || event === void 0 ? void 0 : (_event$securityDetail3 = event.securityDetails) === null || _event$securityDetail3 === void 0 ? void 0 : _event$securityDetail3.issuer,
          validFrom: event === null || event === void 0 ? void 0 : (_event$securityDetail4 = event.securityDetails) === null || _event$securityDetail4 === void 0 ? void 0 : _event$securityDetail4.validFrom,
          validTo: event === null || event === void 0 ? void 0 : (_event$securityDetail5 = event.securityDetails) === null || _event$securityDetail5 === void 0 ? void 0 : _event$securityDetail5.validTo
        });
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onRequestFinished(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        request.request.responseSize.transferSize = event.transferSize;
        const isRedirected = response.status() >= 300 && response.status() <= 399;
        const responseEndTime = event.responseEndTime ? event.responseEndTime / 1e3 - response.timing().startTime : -1;
        if (isRedirected) {
          response._requestFinished(responseEndTime);
        } else {
          this._requests.delete(request._id);
          response._requestFinished(responseEndTime);
        }
        response._setHttpVersion(event.protocolVersion);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onRequestFailed(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        this._requests.delete(request._id);
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(-1);
        request.request._setFailureText(event.errorCode);
        this._page._frameManager.requestFailed(request.request, event.errorCode === "NS_BINDING_ABORTED");
      }
    };
    exports.FFNetworkManager = FFNetworkManager;
    var causeToResourceType = {
      TYPE_INVALID: "other",
      TYPE_OTHER: "other",
      TYPE_SCRIPT: "script",
      TYPE_IMAGE: "image",
      TYPE_STYLESHEET: "stylesheet",
      TYPE_OBJECT: "other",
      TYPE_DOCUMENT: "document",
      TYPE_SUBDOCUMENT: "document",
      TYPE_REFRESH: "document",
      TYPE_XBL: "other",
      TYPE_PING: "other",
      TYPE_XMLHTTPREQUEST: "xhr",
      TYPE_OBJECT_SUBREQUEST: "other",
      TYPE_DTD: "other",
      TYPE_FONT: "font",
      TYPE_MEDIA: "media",
      TYPE_WEBSOCKET: "websocket",
      TYPE_CSP_REPORT: "other",
      TYPE_XSLT: "other",
      TYPE_BEACON: "other",
      TYPE_FETCH: "fetch",
      TYPE_IMAGESET: "images",
      TYPE_WEB_MANIFEST: "manifest"
    };
    var internalCauseToResourceType = {
      TYPE_INTERNAL_EVENTSOURCE: "eventsource"
    };
    var InterceptableRequest = class {
      constructor(frame, redirectedFrom, payload) {
        this.request = void 0;
        this._id = void 0;
        this._redirectedTo = void 0;
        this._id = payload.requestId;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        let postDataBuffer = null;
        if (payload.postData)
          postDataBuffer = Buffer.from(payload.postData, "base64");
        this.request = new network.Request(frame, redirectedFrom ? redirectedFrom.request : null, payload.navigationId, payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || "other", payload.method, postDataBuffer, payload.headers);
      }
      _finalRequest() {
        let request = this;
        while (request._redirectedTo)
          request = request._redirectedTo;
        return request;
      }
    };
    var FFRouteImpl = class {
      constructor(session, request) {
        this._request = void 0;
        this._session = void 0;
        this._session = session;
        this._request = request;
      }
      async continue(request, overrides) {
        await this._session.sendMayFail("Network.resumeInterceptedRequest", {
          requestId: this._request._id,
          url: overrides.url,
          method: overrides.method,
          headers: overrides.headers,
          postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
        });
      }
      async fulfill(response) {
        const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
        await this._session.sendMayFail("Network.fulfillInterceptedRequest", {
          requestId: this._request._id,
          status: response.status,
          statusText: network.STATUS_TEXTS[String(response.status)] || "",
          headers: response.headers,
          base64body
        });
      }
      async abort(errorCode) {
        await this._session.sendMayFail("Network.abortInterceptedRequest", {
          requestId: this._request._id,
          errorCode
        });
      }
    };
    function parseMultivalueHeaders(headers) {
      const result = [];
      for (const header of headers) {
        const separator = header.name.toLowerCase() === "set-cookie" ? "\n" : ",";
        const tokens = header.value.split(separator).map((s2) => s2.trim());
        for (const token of tokens)
          result.push({
            name: header.name,
            value: token
          });
      }
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffPage.js
var require_ffPage = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffPage.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FFPage = exports.UTILITY_WORLD_NAME = void 0;
    var dialog = _interopRequireWildcard(require_dialog());
    var dom = _interopRequireWildcard(require_dom());
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var _page = require_page();
    var _ffAccessibility = require_ffAccessibility();
    var _ffConnection = require_ffConnection();
    var _ffExecutionContext = require_ffExecutionContext();
    var _ffInput = require_ffInput();
    var _ffNetworkManager = require_ffNetworkManager();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _async = require_async();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    exports.UTILITY_WORLD_NAME = UTILITY_WORLD_NAME;
    var FFPage = class {
      constructor(session, browserContext, opener) {
        this.cspErrorsAsynchronousForInlineScipts = true;
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._session = void 0;
        this._page = void 0;
        this._networkManager = void 0;
        this._browserContext = void 0;
        this._pagePromise = new _async.ManualPromise();
        this._initializedPage = null;
        this._initializationFailed = false;
        this._opener = void 0;
        this._contextIdToContext = void 0;
        this._eventListeners = void 0;
        this._workers = new Map();
        this._screencastId = void 0;
        this._session = session;
        this._opener = opener;
        this.rawKeyboard = new _ffInput.RawKeyboardImpl(session);
        this.rawMouse = new _ffInput.RawMouseImpl(session);
        this.rawTouchscreen = new _ffInput.RawTouchscreenImpl(session);
        this._contextIdToContext = new Map();
        this._browserContext = browserContext;
        this._page = new _page.Page(this, browserContext);
        this.rawMouse.setPage(this._page);
        this._networkManager = new _ffNetworkManager.FFNetworkManager(session, this._page);
        this._page.on(_page.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame));
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, "Page.eventFired", this._onEventFired.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameAttached", this._onFrameAttached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameDetached", this._onFrameDetached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationAborted", this._onNavigationAborted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationCommitted", this._onNavigationCommitted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationStarted", this._onNavigationStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.sameDocumentNavigation", this._onSameDocumentNavigation.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", this._onExecutionContextCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextDestroyed", this._onExecutionContextDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.linkClicked", (event) => this._onLinkClicked(event.phase)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.uncaughtError", this._onUncaughtError.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.console", this._onConsole.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.dialogOpened", this._onDialogOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.bindingCalled", this._onBindingCalled.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", this._onFileChooserOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.workerCreated", this._onWorkerCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.workerDestroyed", this._onWorkerDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.dispatchMessageFromWorker", this._onDispatchMessageFromWorker.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.crashed", this._onCrashed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.videoRecordingStarted", this._onVideoRecordingStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketCreated", this._onWebSocketCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketClosed", this._onWebSocketClosed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketFrameReceived", this._onWebSocketFrameReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketFrameSent", this._onWebSocketFrameSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.screencastFrame", this._onScreencastFrame.bind(this))];
        session.once(_ffConnection.FFSessionEvents.Disconnected, () => {
          this._markAsError(new Error("Page closed"));
          this._page._didDisconnect();
        });
        this._session.once("Page.ready", async () => {
          await this._page.initOpener(this._opener);
          if (this._initializationFailed)
            return;
          this._initializedPage = this._page;
          this._page.reportAsNew();
          this._pagePromise.resolve(this._page);
        });
        this._session.send("Page.addScriptToEvaluateOnNewDocument", {
          script: "",
          worldName: UTILITY_WORLD_NAME
        }).catch((e) => this._markAsError(e));
      }
      async _markAsError(error2) {
        if (this._initializationFailed)
          return;
        this._initializationFailed = true;
        if (!this._initializedPage) {
          await this._page.initOpener(this._opener);
          this._page.reportAsNew(error2);
          this._pagePromise.resolve(error2);
        }
      }
      async pageOrError() {
        return this._pagePromise;
      }
      _onWebSocketCreated(event) {
        this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);
        this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketClosed(event) {
        if (event.error)
          this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);
        this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketFrameReceived(event) {
        this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onWebSocketFrameSent(event) {
        this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onExecutionContextCreated(payload) {
        const {
          executionContextId,
          auxData
        } = payload;
        const frame = this._page._frameManager.frame(auxData.frameId);
        if (!frame)
          return;
        const delegate = new _ffExecutionContext.FFExecutionContext(this._session, executionContextId);
        let worldName = null;
        if (auxData.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        else if (!auxData.name)
          worldName = "main";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(executionContextId, context);
      }
      _onExecutionContextDestroyed(payload) {
        const {
          executionContextId
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _removeContextsForFrame(frame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame)
            this._contextIdToContext.delete(contextId);
        }
      }
      _onLinkClicked(phase) {
        if (phase === "before")
          this._page._frameManager.frameWillPotentiallyRequestNavigation();
        else
          this._page._frameManager.frameDidPotentiallyRequestNavigation();
      }
      _onNavigationStarted(params) {
        this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
      }
      _onNavigationAborted(params) {
        this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
      }
      _onNavigationCommitted(params) {
        for (const [workerId, worker] of this._workers) {
          if (worker.frameId === params.frameId)
            this._onWorkerDestroyed({
              workerId
            });
        }
        this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || "", params.navigationId || "", false);
      }
      _onSameDocumentNavigation(params) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
      }
      _onFrameAttached(params) {
        this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
      }
      _onFrameDetached(params) {
        this._page._frameManager.frameDetached(params.frameId);
      }
      _onEventFired(payload) {
        const {
          frameId,
          name
        } = payload;
        if (name === "load")
          this._page._frameManager.frameLifecycleEvent(frameId, "load");
        if (name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
      }
      _onUncaughtError(params) {
        const {
          name,
          message
        } = (0, _stackTrace.splitErrorMessage)(params.message);
        const error2 = new Error(message);
        error2.stack = params.message + "\n" + params.stack.split("\n").filter(Boolean).map((a) => a.replace(/([^@]*)@(.*)/, "    at $1 ($2)")).join("\n");
        error2.name = name;
        this._page.firePageError(error2);
      }
      _onConsole(payload) {
        const {
          type,
          args,
          executionContextId,
          location: location2
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
      }
      _onDialogOpened(params) {
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, params.type, params.message, async (accept, promptText) => {
          await this._session.sendMayFail("Page.handleDialog", {
            dialogId: params.dialogId,
            accept,
            promptText
          });
        }, params.defaultValue));
      }
      async _onBindingCalled(event) {
        const pageOrError = await this.pageOrError();
        if (!(pageOrError instanceof Error)) {
          const context = this._contextIdToContext.get(event.executionContextId);
          if (context)
            await this._page._onBindingCalled(event.payload, context);
        }
      }
      async _onFileChooserOpened(payload) {
        const {
          executionContextId,
          element
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        const handle = context.createHandle(element).asElement();
        await this._page._onFileChooserOpened(handle);
      }
      async _onWorkerCreated(event) {
        const workerId = event.workerId;
        const worker = new _page.Worker(this._page, event.url);
        const workerSession = new _ffConnection.FFSession(this._session._connection, workerId, (message) => {
          this._session.send("Page.sendMessageToWorker", {
            frameId: event.frameId,
            workerId,
            message: JSON.stringify(message)
          }).catch((e) => {
            workerSession.dispatchMessage({
              id: message.id,
              method: "",
              params: {},
              error: {
                message: e.message,
                data: void 0
              }
            });
          });
        });
        this._workers.set(workerId, {
          session: workerSession,
          frameId: event.frameId
        });
        this._page._addWorker(workerId, worker);
        workerSession.once("Runtime.executionContextCreated", (event2) => {
          worker._createExecutionContext(new _ffExecutionContext.FFExecutionContext(workerSession, event2.executionContextId));
        });
        workerSession.on("Runtime.console", (event2) => {
          const {
            type,
            args,
            location: location2
          } = event2;
          const context = worker._existingExecutionContext;
          this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
        });
      }
      _onWorkerDestroyed(event) {
        const workerId = event.workerId;
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.session.dispose();
        this._workers.delete(workerId);
        this._page._removeWorker(workerId);
      }
      async _onDispatchMessageFromWorker(event) {
        const worker = this._workers.get(event.workerId);
        if (!worker)
          return;
        worker.session.dispatchMessage(JSON.parse(event.message));
      }
      async _onCrashed(event) {
        this._session.markAsCrashed();
        this._page._didCrash();
      }
      _onVideoRecordingStarted(event) {
        this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this.pageOrError());
      }
      async exposeBinding(binding) {
        await this._session.send("Page.addBinding", {
          name: binding.name,
          script: binding.source
        });
      }
      didClose() {
        this._session.dispose();
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
      }
      async navigateFrame(frame, url, referer) {
        const response = await this._session.send("Page.navigate", {
          url,
          referer,
          frameId: frame._id
        });
        return {
          newDocumentId: response.navigationId || void 0
        };
      }
      async updateExtraHTTPHeaders() {
        await this._session.send("Network.setExtraHTTPHeaders", {
          headers: this._page._state.extraHTTPHeaders || []
        });
      }
      async setEmulatedSize(emulatedSize) {
        (0, _utils.assert)(this._page._state.emulatedSize === emulatedSize);
        await this._session.send("Page.setViewportSize", {
          viewportSize: {
            width: emulatedSize.viewport.width,
            height: emulatedSize.viewport.height
          }
        });
      }
      async bringToFront() {
        await this._session.send("Page.bringToFront", {});
      }
      async updateEmulateMedia() {
        const colorScheme = this._page._state.colorScheme === null ? void 0 : this._page._state.colorScheme;
        const reducedMotion = this._page._state.reducedMotion === null ? void 0 : this._page._state.reducedMotion;
        const forcedColors = this._page._state.forcedColors === null ? void 0 : this._page._state.forcedColors;
        await this._session.send("Page.setEmulatedMedia", {
          type: this._page._state.mediaType === null ? "" : this._page._state.mediaType,
          colorScheme,
          reducedMotion,
          forcedColors
        });
      }
      async updateRequestInterception() {
        await this._networkManager.setRequestInterception(this._page._needsRequestInterception());
      }
      async setFileChooserIntercepted(enabled) {
        await this._session.send("Page.setInterceptFileChooserDialog", {
          enabled
        }).catch((e) => {
        });
      }
      async reload() {
        await this._session.send("Page.reload", {
          frameId: this._page.mainFrame()._id
        });
      }
      async goBack() {
        const {
          success
        } = await this._session.send("Page.goBack", {
          frameId: this._page.mainFrame()._id
        });
        return success;
      }
      async goForward() {
        const {
          success
        } = await this._session.send("Page.goForward", {
          frameId: this._page.mainFrame()._id
        });
        return success;
      }
      async evaluateOnNewDocument(source) {
        await this._session.send("Page.addScriptToEvaluateOnNewDocument", {
          script: source
        });
      }
      async closePage(runBeforeUnload) {
        await this._session.send("Page.close", {
          runBeforeUnload
        });
      }
      canScreenshotOutsideViewport() {
        return true;
      }
      async setBackgroundColor(color) {
        if (color)
          throw new Error("Not implemented");
      }
      async takeScreenshot(progress, format2, documentRect, viewportRect, quality) {
        if (!documentRect) {
          const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
            x: window.scrollX,
            y: window.scrollY
          }));
          documentRect = {
            x: viewportRect.x + scrollOffset.x,
            y: viewportRect.y + scrollOffset.y,
            width: viewportRect.width,
            height: viewportRect.height
          };
        }
        progress.throwIfAborted();
        const {
          data
        } = await this._session.send("Page.screenshot", {
          mimeType: "image/" + format2,
          clip: documentRect
        });
        return Buffer.from(data, "base64");
      }
      async resetViewport() {
        (0, _utils.assert)(false, "Should not be called");
      }
      async getContentFrame(handle) {
        const {
          contentFrameId
        } = await this._session.send("Page.describeNode", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId
        });
        if (!contentFrameId)
          return null;
        return this._page._frameManager.frame(contentFrameId);
      }
      async getOwnerFrame(handle) {
        const {
          ownerFrameId
        } = await this._session.send("Page.describeNode", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId
        });
        return ownerFrameId || null;
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
          return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
          for (const point of quad) {
            minX = Math.min(minX, point.x);
            maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y);
            maxY = Math.max(maxY, point.y);
          }
        }
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      async scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._session.send("Page.scrollIntoViewIfNeeded", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId,
          rect
        }).then(() => "done").catch((e) => {
          if (e instanceof Error && e.message.includes("Node is detached from document"))
            return "error:notconnected";
          if (e instanceof Error && e.message.includes("Node does not have a layout object"))
            return "error:notvisible";
          throw e;
        });
      }
      async setScreencastOptions(options2) {
        if (options2) {
          const {
            screencastId
          } = await this._session.send("Page.startScreencast", options2);
          this._screencastId = screencastId;
        } else {
          await this._session.send("Page.stopScreencast");
        }
      }
      _onScreencastFrame(event) {
        if (!this._screencastId)
          return;
        const screencastId = this._screencastId;
        this._page.throttleScreencastFrameAck(() => {
          this._session.send("Page.screencastFrameAck", {
            screencastId
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        });
        const buffer = Buffer.from(event.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          width: event.deviceWidth,
          height: event.deviceHeight
        });
      }
      rafCountForStablePosition() {
        return 1;
      }
      async getContentQuads(handle) {
        const result = await this._session.sendMayFail("Page.getContentQuads", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId
        });
        if (!result)
          return null;
        return result.quads.map((quad) => [quad.p1, quad.p2, quad.p3, quad.p4]);
      }
      async setInputFiles(handle, files) {
        await handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
      }
      async adoptElementHandle(handle, to) {
        const result = await this._session.send("Page.adoptNode", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId,
          executionContextId: to[contextDelegateSymbol]._executionContextId
        });
        if (!result.remoteObject)
          throw new Error(dom.kUnableToAdoptErrorMessage);
        return to.createHandle(result.remoteObject);
      }
      async getAccessibilityTree(needle) {
        return (0, _ffAccessibility.getAccessibilityTree)(this._session, needle);
      }
      async inputActionEpilogue() {
      }
      async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
          throw new Error("Frame has been detached.");
        const info = this._page.parseSelector("frame,iframe");
        const handles = await this._page.selectors._queryAll(parent, info);
        const items = await Promise.all(handles.map(async (handle) => {
          const frame2 = await handle.contentFrame().catch((e) => null);
          return {
            handle,
            frame: frame2
          };
        }));
        const result = items.find((item) => item.frame === frame);
        items.map((item) => item === result ? Promise.resolve() : item.handle.dispose());
        if (!result)
          throw new Error("Frame has been detached.");
        return result.handle;
      }
    };
    exports.FFPage = FFPage;
    function webSocketId(frameId, wsid) {
      return `${frameId}---${wsid}`;
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/firefox/ffBrowser.js
var require_ffBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffBrowser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FFBrowserContext = exports.FFBrowser = void 0;
    var _errors = require_errors();
    var _utils = require_utils();
    var _browser = require_browser2();
    var _browserContext = require_browserContext();
    var network = _interopRequireWildcard(require_network());
    var _ffConnection = require_ffConnection();
    var _ffPage = require_ffPage();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFBrowser = class extends _browser.Browser {
      static async connect(transport, options2) {
        const connection = new _ffConnection.FFConnection(transport, options2.protocolLogger, options2.browserLogsCollector);
        const browser = new FFBrowser(connection, options2);
        if (options2.__testHookOnConnectToBrowser)
          await options2.__testHookOnConnectToBrowser();
        const promises = [connection.send("Browser.enable", {
          attachToDefaultContext: !!options2.persistent
        }), browser._initVersion()];
        if (options2.persistent) {
          browser._defaultContext = new FFBrowserContext(browser, void 0, options2.persistent);
          promises.push(browser._defaultContext._initialize());
        }
        if (options2.proxy)
          promises.push(browser._connection.send("Browser.setBrowserProxy", toJugglerProxyOptions(options2.proxy)));
        await Promise.all(promises);
        return browser;
      }
      constructor(connection, options2) {
        super(options2);
        this._connection = void 0;
        this._ffPages = void 0;
        this._contexts = void 0;
        this._version = "";
        this._userAgent = "";
        this._connection = connection;
        this._ffPages = new Map();
        this._contexts = new Map();
        this._connection.on(_ffConnection.ConnectionEvents.Disconnected, () => this._onDisconnect());
        this._connection.on("Browser.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._connection.on("Browser.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._connection.on("Browser.downloadCreated", this._onDownloadCreated.bind(this));
        this._connection.on("Browser.downloadFinished", this._onDownloadFinished.bind(this));
        this._connection.on("Browser.videoRecordingFinished", this._onVideoRecordingFinished.bind(this));
      }
      async _initVersion() {
        const result = await this._connection.send("Browser.getInfo");
        this._version = result.version.substring(result.version.indexOf("/") + 1);
        this._userAgent = result.userAgent;
      }
      isConnected() {
        return !this._connection._closed;
      }
      async newContext(options2) {
        (0, _browserContext.validateBrowserContextOptions)(options2, this.options);
        if (options2.isMobile)
          throw new Error("options.isMobile is not supported in Firefox");
        const {
          browserContextId
        } = await this._connection.send("Browser.createBrowserContext", {
          removeOnDetach: true
        });
        const context = new FFBrowserContext(this, browserContextId, options2);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      userAgent() {
        return this._userAgent;
      }
      _onDetachedFromTarget(payload) {
        const ffPage = this._ffPages.get(payload.targetId);
        this._ffPages.delete(payload.targetId);
        ffPage.didClose();
      }
      _onAttachedToTarget(payload) {
        const {
          targetId,
          browserContextId,
          openerId,
          type
        } = payload.targetInfo;
        (0, _utils.assert)(type === "page");
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        (0, _utils.assert)(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
        const session = this._connection.createSession(payload.sessionId);
        const opener = openerId ? this._ffPages.get(openerId) : null;
        const ffPage = new _ffPage.FFPage(session, context, opener);
        this._ffPages.set(targetId, ffPage);
      }
      _onDownloadCreated(payload) {
        const ffPage = this._ffPages.get(payload.pageTargetId);
        (0, _utils.assert)(ffPage);
        if (!ffPage)
          return;
        let originPage = ffPage._initializedPage;
        if (!originPage) {
          ffPage._markAsError(new Error("Starting new page download"));
          if (ffPage._opener)
            originPage = ffPage._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
      }
      _onDownloadFinished(payload) {
        const error2 = payload.canceled ? "canceled" : payload.error;
        this._downloadFinished(payload.uuid, error2);
      }
      _onVideoRecordingFinished(payload) {
        var _this$_takeVideo;
        (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
      }
      _onDisconnect() {
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(_errors.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
    };
    exports.FFBrowser = FFBrowser;
    var FFBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options2) {
        super(browser, options2, browserContextId);
      }
      async _initialize() {
        (0, _utils.assert)(!this._ffPages().length);
        const browserContextId = this._browserContextId;
        const promises = [super._initialize()];
        promises.push(this._browser._connection.send("Browser.setDownloadOptions", {
          browserContextId,
          downloadOptions: {
            behavior: this._options.acceptDownloads ? "saveToDisk" : "cancel",
            downloadsDir: this._browser.options.downloadsPath
          }
        }));
        if (this._options.viewport) {
          const viewport = {
            viewportSize: {
              width: this._options.viewport.width,
              height: this._options.viewport.height
            },
            deviceScaleFactor: this._options.deviceScaleFactor || 1
          };
          promises.push(this._browser._connection.send("Browser.setDefaultViewport", {
            browserContextId,
            viewport
          }));
        }
        if (this._options.hasTouch)
          promises.push(this._browser._connection.send("Browser.setTouchOverride", {
            browserContextId,
            hasTouch: true
          }));
        if (this._options.userAgent)
          promises.push(this._browser._connection.send("Browser.setUserAgentOverride", {
            browserContextId,
            userAgent: this._options.userAgent
          }));
        if (this._options.bypassCSP)
          promises.push(this._browser._connection.send("Browser.setBypassCSP", {
            browserContextId,
            bypassCSP: true
          }));
        if (this._options.ignoreHTTPSErrors)
          promises.push(this._browser._connection.send("Browser.setIgnoreHTTPSErrors", {
            browserContextId,
            ignoreHTTPSErrors: true
          }));
        if (this._options.javaScriptEnabled === false)
          promises.push(this._browser._connection.send("Browser.setJavaScriptDisabled", {
            browserContextId,
            javaScriptDisabled: true
          }));
        if (this._options.locale)
          promises.push(this._browser._connection.send("Browser.setLocaleOverride", {
            browserContextId,
            locale: this._options.locale
          }));
        if (this._options.timezoneId)
          promises.push(this._browser._connection.send("Browser.setTimezoneOverride", {
            browserContextId,
            timezoneId: this._options.timezoneId
          }));
        if (this._options.permissions)
          promises.push(this.grantPermissions(this._options.permissions));
        if (this._options.extraHTTPHeaders || this._options.locale)
          promises.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));
        if (this._options.httpCredentials)
          promises.push(this.setHTTPCredentials(this._options.httpCredentials));
        if (this._options.geolocation)
          promises.push(this.setGeolocation(this._options.geolocation));
        if (this._options.offline)
          promises.push(this.setOffline(this._options.offline));
        promises.push(this._browser._connection.send("Browser.setColorScheme", {
          browserContextId,
          colorScheme: this._options.colorScheme !== void 0 ? this._options.colorScheme : "light"
        }));
        promises.push(this._browser._connection.send("Browser.setReducedMotion", {
          browserContextId,
          reducedMotion: this._options.reducedMotion !== void 0 ? this._options.reducedMotion : "no-preference"
        }));
        promises.push(this._browser._connection.send("Browser.setForcedColors", {
          browserContextId,
          forcedColors: this._options.forcedColors !== void 0 ? this._options.forcedColors : "none"
        }));
        if (this._options.recordVideo) {
          promises.push(this._ensureVideosPath().then(() => {
            return this._browser._connection.send("Browser.setVideoRecordingOptions", {
              options: __spreadProps(__spreadValues({}, this._options.recordVideo.size), {
                dir: this._options.recordVideo.dir
              }),
              browserContextId: this._browserContextId
            });
          }));
        }
        if (this._options.proxy) {
          promises.push(this._browser._connection.send("Browser.setContextProxy", __spreadValues({
            browserContextId: this._browserContextId
          }, toJugglerProxyOptions(this._options.proxy))));
        }
        await Promise.all(promises);
      }
      _ffPages() {
        return Array.from(this._browser._ffPages.values()).filter((ffPage) => ffPage._browserContext === this);
      }
      pages() {
        return this._ffPages().map((ffPage) => ffPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      async newPageDelegate() {
        (0, _browserContext.assertBrowserContextIsNotOwned)(this);
        const {
          targetId
        } = await this._browser._connection.send("Browser.newPage", {
          browserContextId: this._browserContextId
        }).catch((e) => {
          if (e.message.includes("Failed to override timezone"))
            throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
          throw e;
        });
        return this._browser._ffPages.get(targetId);
      }
      async _doCookies(urls) {
        const {
          cookies
        } = await this._browser._connection.send("Browser.getCookies", {
          browserContextId: this._browserContextId
        });
        return network.filterCookies(cookies.map((c) => {
          const copy = __spreadValues({}, c);
          delete copy.size;
          delete copy.session;
          return copy;
        }), urls);
      }
      async addCookies(cookies) {
        const cc = network.rewriteCookies(cookies).map((c) => __spreadProps(__spreadValues({}, c), {
          expires: c.expires && c.expires !== -1 ? c.expires : void 0
        }));
        await this._browser._connection.send("Browser.setCookies", {
          browserContextId: this._browserContextId,
          cookies: cc
        });
      }
      async clearCookies() {
        await this._browser._connection.send("Browser.clearCookies", {
          browserContextId: this._browserContextId
        });
      }
      async _doGrantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([["geolocation", "geo"], ["persistent-storage", "persistent-storage"], ["push", "push"], ["notifications", "desktop-notification"]]);
        const filtered = permissions.map((permission) => {
          const protocolPermission = webPermissionToProtocol.get(permission);
          if (!protocolPermission)
            throw new Error("Unknown permission: " + permission);
          return protocolPermission;
        });
        await this._browser._connection.send("Browser.grantPermissions", {
          origin,
          browserContextId: this._browserContextId,
          permissions: filtered
        });
      }
      async _doClearPermissions() {
        await this._browser._connection.send("Browser.resetPermissions", {
          browserContextId: this._browserContextId
        });
      }
      async setGeolocation(geolocation) {
        (0, _browserContext.verifyGeolocation)(geolocation);
        this._options.geolocation = geolocation;
        await this._browser._connection.send("Browser.setGeolocationOverride", {
          browserContextId: this._browserContextId,
          geolocation: geolocation || null
        });
      }
      async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        let allHeaders = this._options.extraHTTPHeaders;
        if (this._options.locale)
          allHeaders = network.mergeHeaders([allHeaders, network.singleHeader("Accept-Language", this._options.locale)]);
        await this._browser._connection.send("Browser.setExtraHTTPHeaders", {
          browserContextId: this._browserContextId,
          headers: allHeaders
        });
      }
      async setOffline(offline) {
        this._options.offline = offline;
        await this._browser._connection.send("Browser.setOnlineOverride", {
          browserContextId: this._browserContextId,
          override: offline ? "offline" : "online"
        });
      }
      async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        await this._browser._connection.send("Browser.setHTTPCredentials", {
          browserContextId: this._browserContextId,
          credentials: httpCredentials || null
        });
      }
      async _doAddInitScript(source) {
        await this._browser._connection.send("Browser.addScriptToEvaluateOnNewDocument", {
          browserContextId: this._browserContextId,
          script: source
        });
      }
      async _doExposeBinding(binding) {
        await this._browser._connection.send("Browser.addBinding", {
          browserContextId: this._browserContextId,
          name: binding.name,
          script: binding.source
        });
      }
      async _doUpdateRequestInterception() {
        await this._browser._connection.send("Browser.setRequestInterception", {
          browserContextId: this._browserContextId,
          enabled: !!this._requestInterceptor
        });
      }
      _onClosePersistent() {
      }
      async _doClose() {
        (0, _utils.assert)(this._browserContextId);
        await this._browser._connection.send("Browser.removeBrowserContext", {
          browserContextId: this._browserContextId
        });
        this._browser._contexts.delete(this._browserContextId);
      }
      async _doCancelDownload(uuid) {
        await this._browser._connection.send("Browser.cancelDownload", {
          uuid
        });
      }
    };
    exports.FFBrowserContext = FFBrowserContext;
    function toJugglerProxyOptions(proxy) {
      const proxyServer = new URL(proxy.server);
      let port = parseInt(proxyServer.port, 10);
      let type = "http";
      if (proxyServer.protocol === "socks5:")
        type = "socks";
      else if (proxyServer.protocol === "socks4:")
        type = "socks4";
      else if (proxyServer.protocol === "https:")
        type = "https";
      if (proxyServer.port === "") {
        if (proxyServer.protocol === "http:")
          port = 80;
        else if (proxyServer.protocol === "https:")
          port = 443;
      }
      return {
        type,
        bypass: proxy.bypass ? proxy.bypass.split(",").map((domain) => domain.trim()) : [],
        host: proxyServer.hostname,
        port,
        username: proxy.username,
        password: proxy.password
      };
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/firefox.js
var require_firefox = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/firefox.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Firefox = void 0;
    var os = _interopRequireWildcard(__require("os"));
    var _fs = _interopRequireDefault(__require("fs"));
    var _path = _interopRequireDefault(__require("path"));
    var _ffBrowser = require_ffBrowser();
    var _ffConnection = require_ffConnection();
    var _browserType = require_browserType();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Firefox = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("firefox", playwrightOptions);
      }
      _connectToTransport(transport, options2) {
        return _ffBrowser.FFBrowser.connect(transport, options2);
      }
      _rewriteStartupError(error2) {
        return error2;
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        if (!_path.default.isAbsolute(os.homedir()))
          throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
        if (os.platform() === "linux") {
          return __spreadProps(__spreadValues({}, env), {
            LD_LIBRARY_PATH: `${_path.default.dirname(executable)}:${process.env.LD_LIBRARY_PATH}`
          });
        }
        return env;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {
          method: "Browser.close",
          params: {},
          id: _ffConnection.kBrowserCloseMessageId
        };
        transport.send(message);
      }
      _defaultArgs(options2, isPersistent, userDataDir) {
        const {
          args = [],
          devtools,
          headless
        } = options2;
        if (devtools)
          console.warn("devtools parameter is not supported as a launch argument in Firefox. You can launch the devtools window manually.");
        const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --profile argument");
        if (args.find((arg) => arg.startsWith("-juggler")))
          throw new Error("Use the port parameter instead of -juggler argument");
        const firefoxUserPrefs = isPersistent ? void 0 : options2.firefoxUserPrefs;
        if (firefoxUserPrefs) {
          const lines = [];
          for (const [name, value] of Object.entries(firefoxUserPrefs))
            lines.push(`user_pref(${JSON.stringify(name)}, ${JSON.stringify(value)});`);
          _fs.default.writeFileSync(_path.default.join(userDataDir, "user.js"), lines.join("\n"));
        }
        const firefoxArguments = ["-no-remote"];
        if (headless) {
          firefoxArguments.push("-headless");
        } else {
          firefoxArguments.push("-wait-for-browser");
          firefoxArguments.push("-foreground");
        }
        firefoxArguments.push(`-profile`, userDataDir);
        firefoxArguments.push("-juggler-pipe");
        firefoxArguments.push(...args);
        if (isPersistent)
          firefoxArguments.push("about:blank");
        else
          firefoxArguments.push("-silent");
        return firefoxArguments;
      }
    };
    exports.Firefox = Firefox;
  }
});

// node_modules/playwright-core/lib/server/selectors.js
var require_selectors = __commonJS({
  "node_modules/playwright-core/lib/server/selectors.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Selectors = void 0;
    var _selectorParser = require_selectorParser();
    var _utils = require_utils();
    var Selectors = class {
      constructor() {
        this._builtinEngines = void 0;
        this._builtinEnginesInMainWorld = void 0;
        this._engines = void 0;
        this.guid = `selectors@${(0, _utils.createGuid)()}`;
        this._builtinEngines = new Set(["css", "css:light", "xpath", "xpath:light", "_react", "_vue", "text", "text:light", "id", "id:light", "data-testid", "data-testid:light", "data-test-id", "data-test-id:light", "data-test", "data-test:light", "nth", "visible", "control"]);
        this._builtinEnginesInMainWorld = new Set(["_react", "_vue"]);
        this._engines = new Map();
      }
      async register(name, source, contentScript = false) {
        if (!name.match(/^[a-zA-Z_0-9-]+$/))
          throw new Error("Selector engine name may only contain [a-zA-Z0-9_] characters");
        if (this._builtinEngines.has(name) || name === "zs" || name === "zs:light")
          throw new Error(`"${name}" is a predefined selector engine`);
        if (this._engines.has(name))
          throw new Error(`"${name}" selector engine has been already registered`);
        this._engines.set(name, {
          source,
          contentScript
        });
      }
      unregisterAll() {
        this._engines.clear();
      }
      async query(frame, info, scope) {
        const context = await frame._context(info.world);
        const injectedScript = await context.injectedScript();
        const handle = await injectedScript.evaluateHandle((injected, {
          parsed,
          scope: scope2,
          strict
        }) => {
          return injected.querySelector(parsed, scope2 || document, strict);
        }, {
          parsed: info.parsed,
          scope,
          strict: info.strict
        });
        const elementHandle = handle.asElement();
        if (!elementHandle) {
          handle.dispose();
          return null;
        }
        const mainContext = await frame._mainContext();
        return this._adoptIfNeeded(elementHandle, mainContext);
      }
      async _queryArray(frame, info, scope) {
        const context = await frame._mainContext();
        const injectedScript = await context.injectedScript();
        const arrayHandle = await injectedScript.evaluateHandle((injected, {
          parsed,
          scope: scope2
        }) => {
          return injected.querySelectorAll(parsed, scope2 || document);
        }, {
          parsed: info.parsed,
          scope
        });
        return arrayHandle;
      }
      async _queryAll(frame, selector, scope, adoptToMain) {
        const info = typeof selector === "string" ? frame._page.parseSelector(selector) : selector;
        const context = await frame._context(info.world);
        const injectedScript = await context.injectedScript();
        const arrayHandle = await injectedScript.evaluateHandle((injected, {
          parsed,
          scope: scope2
        }) => {
          return injected.querySelectorAll(parsed, scope2 || document);
        }, {
          parsed: info.parsed,
          scope
        });
        const properties = await arrayHandle.getProperties();
        arrayHandle.dispose();
        const targetContext = adoptToMain ? await frame._mainContext() : context;
        const result = [];
        for (const property of properties.values()) {
          const elementHandle = property.asElement();
          if (elementHandle)
            result.push(this._adoptIfNeeded(elementHandle, targetContext));
          else
            property.dispose();
        }
        return Promise.all(result);
      }
      async _adoptIfNeeded(handle, context) {
        if (handle._context === context)
          return handle;
        const adopted = handle._page._delegate.adoptElementHandle(handle, context);
        handle.dispose();
        return adopted;
      }
      parseSelector(selector, strict) {
        const parsed = typeof selector === "string" ? (0, _selectorParser.parseSelector)(selector) : selector;
        let needsMainWorld = false;
        for (const part of parsed.parts) {
          const custom = this._engines.get(part.name);
          if (!custom && !this._builtinEngines.has(part.name))
            throw new Error(`Unknown engine "${part.name}" while parsing selector ${(0, _selectorParser.stringifySelector)(parsed)}`);
          if (custom && !custom.contentScript)
            needsMainWorld = true;
          if (this._builtinEnginesInMainWorld.has(part.name))
            needsMainWorld = true;
        }
        return {
          parsed,
          world: needsMainWorld ? "main" : "utility",
          strict
        };
      }
    };
    exports.Selectors = Selectors;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkConnection.js
var require_wkConnection = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkConnection.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createProtocolError = createProtocolError;
    exports.WKSession = exports.WKConnection = exports.kPageProxyMessageReceived = exports.kBrowserCloseMessageId = void 0;
    var _events = __require("events");
    var _utils = require_utils();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _errors = require_errors();
    var _protocolError = require_protocolError();
    var kBrowserCloseMessageId = -9999;
    exports.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var kPageProxyMessageReceived = "kPageProxyMessageReceived";
    exports.kPageProxyMessageReceived = kPageProxyMessageReceived;
    var WKConnection = class {
      constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
        this._transport = void 0;
        this._onDisconnect = void 0;
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this._lastId = 0;
        this._closed = false;
        this.browserSession = void 0;
        this._transport = transport;
        this._transport.onmessage = this._dispatchMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._onDisconnect = onDisconnect;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this.browserSession = new WKSession(this, "", _errors.kBrowserClosedError, (message) => {
          this.rawSend(message);
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      _dispatchMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === kBrowserCloseMessageId)
          return;
        if (message.pageProxyId) {
          const payload = {
            message,
            pageProxyId: message.pageProxyId
          };
          this.browserSession.dispatchMessage({
            method: kPageProxyMessageReceived,
            params: payload
          });
          return;
        }
        this.browserSession.dispatchMessage(message);
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        this.browserSession.dispose(true);
        this._onDisconnect();
      }
      isClosed() {
        return this._closed;
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
    };
    exports.WKConnection = WKConnection;
    var WKSession = class extends _events.EventEmitter {
      constructor(connection, sessionId, errorText, rawSend) {
        super();
        this.connection = void 0;
        this.errorText = void 0;
        this.sessionId = void 0;
        this._disposed = false;
        this._rawSend = void 0;
        this._callbacks = new Map();
        this._crashed = false;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this.connection = connection;
        this.sessionId = sessionId;
        this._rawSend = rawSend;
        this.errorText = errorText;
        this.on = super.on;
        this.off = super.removeListener;
        this.addListener = super.addListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      async send(method, params) {
        if (this._crashed)
          throw new _protocolError.ProtocolError(true, "Target crashed");
        if (this._disposed)
          throw new _protocolError.ProtocolError(true, `Target closed`);
        const id = this.connection.nextMessageId();
        const messageObj = {
          id,
          method,
          params
        };
        this._rawSend(messageObj);
        return new Promise((resolve3, reject) => {
          this._callbacks.set(id, {
            resolve: resolve3,
            reject,
            error: new _protocolError.ProtocolError(false),
            method
          });
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error2) => _debugLogger.debugLogger.log("error", error2));
      }
      markAsCrashed() {
        this._crashed = true;
      }
      isDisposed() {
        return this._disposed;
      }
      dispose(disconnected) {
        if (disconnected)
          this.errorText = "Browser closed." + _helper.helper.formatBrowserLogs(this.connection._browserLogsCollector.recentLogs());
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, this.errorText));
        }
        this._callbacks.clear();
        this._disposed = true;
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else if (object.id && !object.error) {
          (0, _utils.assert)(this.isDisposed());
        } else {
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
    };
    exports.WKSession = WKSession;
    function createProtocolError(error2, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${JSON.stringify(protocolError.data)}`;
      return (0, _stackTrace.rewriteErrorMessage)(error2, message);
    }
  }
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/jpeg-js/lib/encoder.js"(exports, module) {
    init_shims();
    var btoa = btoa || function(buf) {
      return Buffer.from(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer)
          return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        if (typeof module === "undefined")
          return new Uint8Array(byteout);
        return Buffer.from(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init2() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init2();
    }
    if (typeof module !== "undefined") {
      module.exports = encode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].encode = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/jpeg-js/lib/decoder.js"(exports, module) {
    init_shims();
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s2 = rs & 15, r = rs >> 4;
            if (s2 === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s2);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s2 = rs & 15, r = rs >> 4;
            if (s2 === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s2) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s2 = rs & 15, r = rs >> 4;
                if (s2 === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s2 !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s2);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load2(path) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse3(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 0, maxV2 = 0;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    if (typeof module !== "undefined") {
      module.exports = decode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].decode = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        maxMemoryUsageInMB: 512
      };
      var opts = __spreadValues(__spreadValues({}, defaultOpts), userOpts);
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder.width,
          height: decoder.height,
          exifBuffer: decoder.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder.comments.length > 0) {
          image["comments"] = decoder.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        } else {
          throw err;
        }
      }
      decoder.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "node_modules/jpeg-js/index.js"(exports, module) {
    init_shims();
    var encode = require_encoder();
    var decode = require_decoder();
    module.exports = {
      encode,
      decode
    };
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports, module) {
    init_shims();
    "use strict";
    var util = __require("util");
    var Stream2 = __require("stream");
    var ChunkStream = module.exports = function() {
      Stream2.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream2);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read.length);
      while (pos < read.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports) {
    init_shims();
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i = 0; i < imagePasses.length; i++) {
        let pass = imagePasses[i];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    exports.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        let outerXLeftOver = x % imagePasses[pass].x.length;
        let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = function paethPredictor(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports, module) {
    init_shims();
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f3Up = lastLine ? lastLine[x] : 0;
        let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f4Up = lastLine ? lastLine[x] : 0;
        let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports, module) {
    init_shims();
    "use strict";
    var util = __require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports, module) {
    init_shims();
    "use strict";
    var crcTable = [];
    (function() {
      for (let i = 0; i < 256; i++) {
        let currentCrc = i;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    })();
    var CrcCalculator = module.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc = -1;
      for (let i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports, module) {
    init_shims();
    "use strict";
    var constants = require_constants3();
    var CrcCalculator = require_crc();
    var Parser = module.exports = function(options2, dependencies) {
      this._options = options2;
      options2.checkCRC = options2.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      let signature = constants.PNG_SIGNATURE;
      for (let i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name = "";
      for (let i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i = 0; i < entries; i++) {
        this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports) {
    init_shims();
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i];
        i++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports, module) {
    init_shims();
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module.exports = function(indata, imageData) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports, module) {
    init_shims();
    "use strict";
    var util = __require("util");
    var zlib2 = __require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module.exports = function(options2) {
      ChunkStream.call(this);
      this._parser = new Parser(options2, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options2;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib2.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
          this._inflate = zlib2.createInflate({ chunkSize });
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports, module) {
    init_shims();
    "use strict";
    var constants = require_constants3();
    module.exports = function(dataIn, width, height, options2) {
      let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options2.colorType) !== -1;
      if (options2.colorType === options2.inputColorType) {
        let bigEndian = function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options2.bitDepth === 8 || options2.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options2.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants.COLORTYPE_TO_BPP_MAP[options2.inputColorType];
      if (inBpp === 4 && !options2.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants.COLORTYPE_TO_BPP_MAP[options2.colorType];
      if (options2.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options2.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options2.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options2.inputColorType + " is not supported at present");
        }
        if (options2.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let rgba = getRGBA(data, inIndex);
          switch (options2.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options2.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options2.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options2.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports, module) {
    init_shims();
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x = pxPos; x < length; x++) {
        let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        let val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module.exports = function(pxData, width, height, options2, bpp) {
      let filterTypes;
      if (!("filterType" in options2) || options2.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options2.filterType === "number") {
        filterTypes = [options2.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options2.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min = Infinity;
          for (let i = 0; i < filterTypes.length; i++) {
            let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports, module) {
    init_shims();
    "use strict";
    var constants = require_constants3();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib2 = __require("zlib");
    var Packer = module.exports = function(options2) {
      this._options = options2;
      options2.deflateChunkSize = options2.deflateChunkSize || 32 * 1024;
      options2.deflateLevel = options2.deflateLevel != null ? options2.deflateLevel : 9;
      options2.deflateStrategy = options2.deflateStrategy != null ? options2.deflateStrategy : 3;
      options2.inputHasAlpha = options2.inputHasAlpha != null ? options2.inputHasAlpha : true;
      options2.deflateFactory = options2.deflateFactory || zlib2.createDeflate;
      options2.bitDepth = options2.bitDepth || 8;
      options2.colorType = typeof options2.colorType === "number" ? options2.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options2.inputColorType = typeof options2.inputColorType === "number" ? options2.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options2.colorType) === -1) {
        throw new Error("option color type:" + options2.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options2.inputColorType) === -1) {
        throw new Error("option input color type:" + options2.inputColorType + " is not supported at present");
      }
      if (options2.bitDepth !== 8 && options2.bitDepth !== 16) {
        throw new Error("option bit depth:" + options2.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports, module) {
    init_shims();
    "use strict";
    var util = __require("util");
    var Stream2 = __require("stream");
    var constants = require_constants3();
    var Packer = require_packer();
    var PackerAsync = module.exports = function(opt) {
      Stream2.call(this);
      let options2 = opt || {};
      this._packer = new Packer(options2);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream2);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports, module) {
    init_shims();
    "use strict";
    var assert = __require("assert").ok;
    var zlib2 = __require("zlib");
    var util = __require("util");
    var kMaxLength = __require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error2;
      this.on("error", function(err) {
        error2 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error2;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module.exports = exports = inflateSync;
    exports.Inflate = Inflate;
    exports.createInflate = createInflate;
    exports.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports, module) {
    init_shims();
    "use strict";
    var SyncReader = module.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports) {
    init_shims();
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports, module) {
    init_shims();
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = __require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module.exports = function(buffer, options2) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let err;
      function handleError(_err_) {
        err = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser(options2, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib2.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports, module) {
    init_shims();
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = __require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants3();
    var Packer = require_packer();
    module.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let options2 = opt || {};
      let packer = new Packer(options2);
      let chunks = [];
      chunks.push(Buffer.from(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      let compressedData = zlib2.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports) {
    init_shims();
    "use strict";
    var parse3 = require_parser_sync();
    var pack = require_packer_sync();
    exports.read = function(buffer, options2) {
      return parse3(buffer, options2 || {});
    };
    exports.write = function(png, options2) {
      return pack(png, options2);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports) {
    init_shims();
    "use strict";
    var util = __require("util");
    var Stream2 = __require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports.PNG = function(options2) {
      Stream2.call(this);
      options2 = options2 || {};
      this.width = options2.width | 0;
      this.height = options2.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options2.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options2);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options2);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream2);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src2, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src2.width || srcY > src2.height || srcX + width > src2.width || srcY + height > src2.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src2.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src2.width + srcX << 2, (srcY + y) * src2.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src2) {
      if (src2.gamma) {
        for (let y = 0; y < src2.height; y++) {
          for (let x = 0; x < src2.width; x++) {
            let idx = src2.width * y + x << 2;
            for (let i = 0; i < 3; i++) {
              let sample = src2.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src2.gamma);
              src2.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src2.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/playwright-core/lib/server/webkit/wkAccessibility.js
var require_wkAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkAccessibility.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getAccessibilityTree = getAccessibilityTree;
    async function getAccessibilityTree(session, needle) {
      const objectId = needle ? needle._objectId : void 0;
      const {
        axNode
      } = await session.send("Page.accessibilitySnapshot", {
        objectId
      });
      const tree = new WKAXNode(axNode);
      return {
        tree,
        needle: needle ? tree._findNeedle() : null
      };
    }
    var WKRoleToARIARole = new Map(Object.entries({
      "TextField": "textbox"
    }));
    var WKUnhelpfulRoleDescriptions = new Map(Object.entries({
      "WebArea": "HTML content",
      "Summary": "summary",
      "DescriptionList": "description list",
      "ImageMap": "image map",
      "ListMarker": "list marker",
      "Video": "video playback",
      "Mark": "highlighted",
      "contentinfo": "content information",
      "Details": "details",
      "DescriptionListDetail": "description",
      "DescriptionListTerm": "term",
      "alertdialog": "web alert dialog",
      "dialog": "web dialog",
      "status": "application status",
      "tabpanel": "tab panel",
      "application": "web application"
    }));
    var WKAXNode = class {
      constructor(payload) {
        this._payload = void 0;
        this._children = void 0;
        this._payload = payload;
        this._children = [];
        for (const payload2 of this._payload.children || [])
          this._children.push(new WKAXNode(payload2));
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.found)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isControl() {
        switch (this._payload.role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "TextField":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      _isTextControl() {
        switch (this._payload.role) {
          case "combobox":
          case "searchfield":
          case "textbox":
          case "TextField":
            return true;
        }
        return false;
      }
      _name() {
        if (this._payload.role === "text")
          return this._payload.value || "";
        return this._payload.name || "";
      }
      isInteresting(insideControl) {
        const {
          role,
          focusable
        } = this._payload;
        const name = this._name();
        if (role === "ScrollArea")
          return false;
        if (role === "WebArea")
          return true;
        if (focusable || role === "MenuListOption")
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!name;
      }
      _hasRendundantTextChild() {
        if (this._children.length !== 1)
          return false;
        const child = this._children[0];
        return child._payload.role === "text" && this._payload.name === child._payload.value;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isTextControl())
          return true;
        if (this._hasRendundantTextChild())
          return true;
        return false;
      }
      serialize() {
        const node = {
          role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
          name: this._name()
        };
        if ("description" in this._payload && this._payload.description !== node.name)
          node.description = this._payload.description;
        if ("roledescription" in this._payload) {
          const roledescription = this._payload.roledescription;
          if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
            node.roledescription = roledescription;
        }
        if ("value" in this._payload && this._payload.role !== "text") {
          if (typeof this._payload.value === "string")
            node.valueString = this._payload.value;
          else if (typeof this._payload.value === "number")
            node.valueNumber = this._payload.value;
        }
        if ("checked" in this._payload)
          node.checked = this._payload.checked === "true" ? "checked" : this._payload.checked === "false" ? "unchecked" : "mixed";
        if ("pressed" in this._payload)
          node.pressed = this._payload.pressed === "true" ? "pressed" : this._payload.pressed === "false" ? "released" : "mixed";
        const userStringProperties = ["keyshortcuts", "valuetext"];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._payload.role === "WebArea" || this._payload.role === "ScrollArea"))
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level", "valuemax", "valuemin"];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid"];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const orientationIsApplicable = new Set(["ScrollArea", "scrollbar", "listbox", "combobox", "menu", "tree", "separator", "slider", "tablist", "toolbar"]);
        if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
          node.orientation = this._payload.orientation;
        return node;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js
var require_wkExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WKExecutionContext = void 0;
    var js = _interopRequireWildcard(require_javascript());
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var WKExecutionContext = class {
      constructor(session, contextId) {
        this._session = void 0;
        this._contextId = void 0;
        this._session = session;
        this._contextId = contextId;
      }
      async rawEvaluateJSON(expression) {
        try {
          const response = await this._session.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId,
            returnByValue: true
          });
          if (response.wasThrown)
            throw new js.JavaScriptErrorInEvaluate(response.result.description);
          return response.result.value;
        } catch (error2) {
          throw rewriteError(error2);
        }
      }
      async rawEvaluateHandle(expression) {
        try {
          const response = await this._session.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId,
            returnByValue: false
          });
          if (response.wasThrown)
            throw new js.JavaScriptErrorInEvaluate(response.result.description);
          return response.result.objectId;
        } catch (error2) {
          throw rewriteError(error2);
        }
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          objectId: args.find((a) => a instanceof js.JSHandle)._objectId,
          arguments: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          emulateUserGesture: true
        }).catch(() => {
        });
      }
      async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        try {
          const response = await this._session.send("Runtime.callFunctionOn", {
            functionDeclaration: expression,
            objectId: utilityScript._objectId,
            arguments: [{
              objectId: utilityScript._objectId
            }, ...values.map((value) => ({
              value
            })), ...objectIds.map((objectId) => ({
              objectId
            }))],
            returnByValue,
            emulateUserGesture: true,
            awaitPromise: true
          });
          if (response.wasThrown)
            throw new js.JavaScriptErrorInEvaluate(response.result.description);
          if (returnByValue)
            return (0, _utilityScriptSerializers.parseEvaluationResultValue)(response.result.value);
          return utilityScript._context.createHandle(response.result);
        } catch (error2) {
          throw rewriteError(error2);
        }
      }
      async getProperties(context, objectId) {
        const response = await this._session.send("Runtime.getProperties", {
          objectId,
          ownProperties: true
        });
        const result = new Map();
        for (const property of response.properties) {
          if (!property.enumerable || !property.value)
            continue;
          result.set(property.name, context.createHandle(property.value));
        }
        return result;
      }
      createHandle(context, remoteObject) {
        const isPromise = remoteObject.className === "Promise";
        return new js.JSHandle(context, isPromise ? "promise" : remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      async releaseHandle(objectId) {
        await this._session.send("Runtime.releaseObject", {
          objectId
        });
      }
    };
    exports.WKExecutionContext = WKExecutionContext;
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const isUnserializable = remoteObject.type === "number" && ["NaN", "-Infinity", "Infinity", "-0"].includes(remoteObject.description);
      return isUnserializable ? js.parseUnserializableValue(remoteObject.description) : value;
    }
    function rewriteError(error2) {
      if (!js.isJavaScriptErrorInEvaluate(error2) && !(0, _protocolError.isSessionClosedError)(error2))
        return new Error("Execution context was destroyed, most likely because of a navigation.");
      return error2;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if ("value" in object)
        return String(object.value);
      if (object.description === "Object" && object.preview) {
        const tokens = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          tokens.push(`${name}: ${value}`);
        return `{${tokens.join(", ")}}`;
      }
      if (object.subtype === "array" && object.preview) {
        const result = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          result[+name] = value;
        return "[" + String(result) + "]";
      }
      return object.description;
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkInput.js
var require_wkInput = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkInput.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;
    var input = _interopRequireWildcard(require_input());
    var _macEditingCommands = require_macEditingCommands();
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Shift"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Alt"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("middle"))
        mask |= 2;
      if (buttons.has("right"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._session = void 0;
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        const parts = [];
        for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
          if (modifiers.has(modifier))
            parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join("+");
        let commands = _macEditingCommands.macEditingCommands[shortcut];
        if ((0, _utils.isString)(commands))
          commands = [commands];
        await this._pageProxySession.send("Input.dispatchKeyEvent", {
          type: "keyDown",
          modifiers: toModifiersMask(modifiers),
          windowsVirtualKeyCode: keyCode,
          code,
          key,
          text,
          unmodifiedText: text,
          autoRepeat,
          macCommands: commands,
          isKeypad: location2 === input.keypadLocation
        });
      }
      async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        await this._pageProxySession.send("Input.dispatchKeyEvent", {
          type: "keyUp",
          modifiers: toModifiersMask(modifiers),
          key,
          windowsVirtualKeyCode: keyCode,
          code,
          isKeypad: location2 === input.keypadLocation
        });
      }
      async sendText(text) {
        await this._session.send("Page.insertText", {
          text
        });
      }
    };
    exports.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._session = void 0;
        this._page = void 0;
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      async move(x, y, button, buttons, modifiers) {
        await this._pageProxySession.send("Input.dispatchMouseEvent", {
          type: "move",
          button,
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
      async down(x, y, button, buttons, modifiers, clickCount) {
        await this._pageProxySession.send("Input.dispatchMouseEvent", {
          type: "down",
          button,
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
      async up(x, y, button, buttons, modifiers, clickCount) {
        await this._pageProxySession.send("Input.dispatchMouseEvent", {
          type: "up",
          button,
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
      async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        await this._session.send("Page.updateScrollingState");
        await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, "utility");
        await this._pageProxySession.send("Input.dispatchWheelEvent", {
          x,
          y,
          deltaX,
          deltaY,
          modifiers: toModifiersMask(modifiers)
        });
      }
      setPage(page) {
        this._page = page;
      }
    };
    exports.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._pageProxySession = session;
      }
      async tap(x, y, modifiers) {
        await this._pageProxySession.send("Input.dispatchTapEvent", {
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
    };
    exports.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js
var require_wkInterceptableRequest = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WKRouteImpl = exports.WKInterceptableRequest = void 0;
    var network = _interopRequireWildcard(require_network());
    var _utils = require_utils();
    var _async = require_async();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var errorReasons = {
      "aborted": "Cancellation",
      "accessdenied": "AccessControl",
      "addressunreachable": "General",
      "blockedbyclient": "Cancellation",
      "blockedbyresponse": "General",
      "connectionaborted": "General",
      "connectionclosed": "General",
      "connectionfailed": "General",
      "connectionrefused": "General",
      "connectionreset": "General",
      "internetdisconnected": "General",
      "namenotresolved": "General",
      "timedout": "Timeout",
      "failed": "General"
    };
    var WKInterceptableRequest = class {
      constructor(session, route, frame, event, redirectedFrom, documentId) {
        this._session = void 0;
        this.request = void 0;
        this._requestId = void 0;
        this._timestamp = void 0;
        this._wallTime = void 0;
        this._route = void 0;
        this._redirectedFrom = void 0;
        this._session = session;
        this._requestId = event.requestId;
        this._route = route;
        this._redirectedFrom = redirectedFrom;
        const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.request.resourceType() : "other";
        let postDataBuffer = null;
        this._timestamp = event.timestamp;
        this._wallTime = event.walltime * 1e3;
        if (event.request.postData)
          postDataBuffer = Buffer.from(event.request.postData, "base64");
        this.request = new network.Request(frame, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, (0, _utils.headersObjectToArray)(event.request.headers));
      }
      _routeForRedirectChain() {
        let request = this;
        while (request._redirectedFrom)
          request = request._redirectedFrom;
        return request._route;
      }
      createResponse(responsePayload) {
        const getResponseBody = async () => {
          const response = await this._session.send("Network.getResponseBody", {
            requestId: this._requestId
          });
          return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
        };
        const timingPayload = responsePayload.timing;
        const timing = {
          startTime: this._wallTime,
          domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
          domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
          connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
          secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
          connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
          requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
          responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1
        };
        const setCookieSeparator = process.platform === "darwin" ? "," : "\n";
        return new network.Response(this.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers, ",", setCookieSeparator), timing, getResponseBody);
      }
    };
    exports.WKInterceptableRequest = WKInterceptableRequest;
    var WKRouteImpl = class {
      constructor(session, requestId) {
        this._session = void 0;
        this._requestId = void 0;
        this._requestInterceptedPromise = new _async.ManualPromise();
        this._session = session;
        this._requestId = requestId;
      }
      async abort(errorCode) {
        const errorType = errorReasons[errorCode];
        (0, _utils.assert)(errorType, "Unknown error code: " + errorCode);
        await this._requestInterceptedPromise;
        await this._session.sendMayFail("Network.interceptRequestWithError", {
          requestId: this._requestId,
          errorType
        });
      }
      async fulfill(response) {
        if (300 <= response.status && response.status < 400)
          throw new Error("Cannot fulfill with redirect status: " + response.status);
        await this._requestInterceptedPromise;
        let mimeType = response.isBase64 ? "application/octet-stream" : "text/plain";
        const headers = (0, _utils.headersArrayToObject)(response.headers, true);
        const contentType = headers["content-type"];
        if (contentType)
          mimeType = contentType.split(";")[0].trim();
        await this._session.sendMayFail("Network.interceptRequestWithResponse", {
          requestId: this._requestId,
          status: response.status,
          statusText: network.STATUS_TEXTS[String(response.status)],
          mimeType,
          headers,
          base64Encoded: response.isBase64,
          content: response.body
        });
      }
      async continue(request, overrides) {
        await this._requestInterceptedPromise;
        await this._session.sendMayFail("Network.interceptWithRequest", {
          requestId: this._requestId,
          url: overrides.url,
          method: overrides.method,
          headers: overrides.headers ? (0, _utils.headersArrayToObject)(overrides.headers, false) : void 0,
          postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
        });
      }
    };
    exports.WKRouteImpl = WKRouteImpl;
    function wkMillisToRoundishMillis(value) {
      if (value === -1e3)
        return -1;
      if (value <= 0) {
        return -1;
      }
      return (value * 1e3 | 0) / 1e3;
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js
var require_wkProvisionalPage = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WKProvisionalPage = void 0;
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var WKProvisionalPage = class {
      constructor(session, page) {
        this._session = void 0;
        this._wkPage = void 0;
        this._sessionListeners = [];
        this._mainFrameId = null;
        this.initializationPromise = void 0;
        this._session = session;
        this._wkPage = page;
        const overrideFrameId = (handler) => {
          return (payload) => {
            if (payload.frameId)
              payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
            handler(payload);
          };
        };
        const wkPage = this._wkPage;
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", overrideFrameId((e) => wkPage._onRequestWillBeSent(session, e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestIntercepted", overrideFrameId((e) => wkPage._onRequestIntercepted(session, e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", overrideFrameId((e) => wkPage._onResponseReceived(e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFinished", overrideFrameId((e) => wkPage._onLoadingFinished(e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFailed", overrideFrameId((e) => wkPage._onLoadingFailed(e)))];
        this.initializationPromise = this._wkPage._initializeSession(session, true, ({
          frameTree
        }) => this._handleFrameTree(frameTree));
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
      }
      commit() {
        (0, _utils.assert)(this._mainFrameId);
        this._wkPage._onFrameAttached(this._mainFrameId, null);
      }
      _handleFrameTree(frameTree) {
        (0, _utils.assert)(!frameTree.frame.parentId);
        this._mainFrameId = frameTree.frame.id;
      }
    };
    exports.WKProvisionalPage = WKProvisionalPage;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkWorkers.js
var require_wkWorkers = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkWorkers.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WKWorkers = void 0;
    var _eventsHelper = require_eventsHelper();
    var _page = require_page();
    var _wkConnection = require_wkConnection();
    var _wkExecutionContext = require_wkExecutionContext();
    var WKWorkers = class {
      constructor(page) {
        this._sessionListeners = [];
        this._page = void 0;
        this._workerSessions = new Map();
        this._page = page;
      }
      setSession(session) {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        this.clear();
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Worker.workerCreated", (event) => {
          const worker = new _page.Worker(this._page, event.url);
          const workerSession = new _wkConnection.WKSession(session.connection, event.workerId, "Most likely the worker has been closed.", (message) => {
            session.send("Worker.sendMessageToWorker", {
              workerId: event.workerId,
              message: JSON.stringify(message)
            }).catch((e) => {
              workerSession.dispatchMessage({
                id: message.id,
                error: {
                  message: e.message
                }
              });
            });
          });
          this._workerSessions.set(event.workerId, workerSession);
          worker._createExecutionContext(new _wkExecutionContext.WKExecutionContext(workerSession, void 0));
          this._page._addWorker(event.workerId, worker);
          workerSession.on("Console.messageAdded", (event2) => this._onConsoleMessage(worker, event2));
          Promise.all([workerSession.send("Runtime.enable"), workerSession.send("Console.enable"), session.send("Worker.initialized", {
            workerId: event.workerId
          })]).catch((e) => {
            this._page._removeWorker(event.workerId);
          });
        }), _eventsHelper.eventsHelper.addEventListener(session, "Worker.dispatchMessageFromWorker", (event) => {
          const workerSession = this._workerSessions.get(event.workerId);
          if (!workerSession)
            return;
          workerSession.dispatchMessage(JSON.parse(event.message));
        }), _eventsHelper.eventsHelper.addEventListener(session, "Worker.workerTerminated", (event) => {
          const workerSession = this._workerSessions.get(event.workerId);
          if (!workerSession)
            return;
          workerSession.dispose(false);
          this._workerSessions.delete(event.workerId);
          this._page._removeWorker(event.workerId);
        })];
      }
      clear() {
        this._page._clearWorkers();
        this._workerSessions.clear();
      }
      async initializeSession(session) {
        await session.send("Worker.enable");
      }
      async _onConsoleMessage(worker, event) {
        const {
          type,
          level,
          text,
          parameters,
          url,
          line: lineNumber,
          column: columnNumber
        } = event.message;
        let derivedType = type || "";
        if (type === "log")
          derivedType = level;
        else if (type === "timing")
          derivedType = "timeEnd";
        const handles = (parameters || []).map((p) => {
          return worker._existingExecutionContext.createHandle(p);
        });
        const location2 = {
          url: url || "",
          lineNumber: (lineNumber || 1) - 1,
          columnNumber: (columnNumber || 1) - 1
        };
        this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
      }
    };
    exports.WKWorkers = WKWorkers;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkPage.js
var require_wkPage = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkPage.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WKPage = void 0;
    var jpeg = _interopRequireWildcard(require_jpeg_js());
    var _path = _interopRequireDefault(__require("path"));
    var png = _interopRequireWildcard(require_png());
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var dialog = _interopRequireWildcard(require_dialog());
    var dom = _interopRequireWildcard(require_dom());
    var _eventsHelper = require_eventsHelper();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _wkAccessibility = require_wkAccessibility();
    var _wkConnection = require_wkConnection();
    var _wkExecutionContext = require_wkExecutionContext();
    var _wkInput = require_wkInput();
    var _wkInterceptableRequest = require_wkInterceptableRequest();
    var _wkProvisionalPage = require_wkProvisionalPage();
    var _wkWorkers = require_wkWorkers();
    var _debugLogger = require_debugLogger();
    var _async = require_async();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var BINDING_CALL_MESSAGE = "__playwright_binding_call__";
    var WKPage = class {
      constructor(browserContext, pageProxySession, opener) {
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._session = void 0;
        this._provisionalPage = null;
        this._page = void 0;
        this._pagePromise = new _async.ManualPromise();
        this._pageProxySession = void 0;
        this._opener = void 0;
        this._requestIdToRequest = new Map();
        this._workers = void 0;
        this._contextIdToContext = void 0;
        this._mainFrameContextId = void 0;
        this._sessionListeners = [];
        this._eventListeners = void 0;
        this._browserContext = void 0;
        this._initializedPage = null;
        this._firstNonInitialNavigationCommittedPromise = void 0;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._lastConsoleMessage = null;
        this._requestIdToResponseReceivedPayloadEvent = new Map();
        this._nextWindowOpenPopupFeatures = void 0;
        this._recordingVideoFile = null;
        this._screencastGeneration = 0;
        this._pageProxySession = pageProxySession;
        this._opener = opener;
        this.rawKeyboard = new _wkInput.RawKeyboardImpl(pageProxySession);
        this.rawMouse = new _wkInput.RawMouseImpl(pageProxySession);
        this.rawTouchscreen = new _wkInput.RawTouchscreenImpl(pageProxySession);
        this._contextIdToContext = new Map();
        this._page = new _page.Page(this, browserContext);
        this.rawMouse.setPage(this._page);
        this._workers = new _wkWorkers.WKWorkers(this._page);
        this._session = void 0;
        this._browserContext = browserContext;
        this._page.on(_page.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.targetCreated", this._onTargetCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.targetDestroyed", this._onTargetDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.dispatchMessageFromTarget", this._onDispatchMessageFromTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.didCommitProvisionalTarget", this._onDidCommitProvisionalTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Screencast.screencastFrame", this._onScreencastFrame.bind(this))];
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
          const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);
          opener._nextWindowOpenPopupFeatures = void 0;
          if (viewportSize)
            this._page._state.emulatedSize = {
              viewport: viewportSize,
              screen: viewportSize
            };
        }
      }
      async _initializePageProxySession() {
        const promises = [this._pageProxySession.send("Dialog.enable"), this._pageProxySession.send("Emulation.setActiveAndFocused", {
          active: true
        })];
        const contextOptions = this._browserContext._options;
        if (contextOptions.javaScriptEnabled === false)
          promises.push(this._pageProxySession.send("Emulation.setJavaScriptEnabled", {
            enabled: false
          }));
        promises.push(this._updateViewport());
        promises.push(this.updateHttpCredentials());
        if (this._browserContext._permissions.size) {
          for (const [key, value] of this._browserContext._permissions)
            promises.push(this._grantPermissions(key, value));
        }
        if (this._browserContext._options.recordVideo) {
          const outputFile = _path.default.join(this._browserContext._options.recordVideo.dir, (0, _utils.createGuid)() + ".webm");
          promises.push(this._browserContext._ensureVideosPath().then(() => {
            return this._startVideo(__spreadProps(__spreadValues({}, this._browserContext._options.recordVideo.size), {
              outputFile
            }));
          }));
        }
        await Promise.all(promises);
      }
      _setSession(session) {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        this._session = session;
        this.rawKeyboard.setSession(session);
        this.rawMouse.setSession(session);
        this._addSessionListeners();
        this._workers.setSession(session);
      }
      async _initializeSession(session, provisional, resourceTreeHandler) {
        await this._initializeSessionMayThrow(session, resourceTreeHandler).catch((e) => {
          if (provisional && session.isDisposed())
            return;
          if (this._session === session)
            throw e;
        });
      }
      async _initializeSessionMayThrow(session, resourceTreeHandler) {
        const [, frameTree] = await Promise.all([
          session.send("Page.enable"),
          session.send("Page.getResourceTree")
        ]);
        resourceTreeHandler(frameTree);
        const promises = [
          session.send("Runtime.enable"),
          session.send("Page.createUserWorld", {
            name: UTILITY_WORLD_NAME
          }).catch((_) => {
          }),
          session.send("Console.enable"),
          session.send("Network.enable"),
          this._workers.initializeSession(session)
        ];
        if (this._page._needsRequestInterception()) {
          promises.push(session.send("Network.setInterceptionEnabled", {
            enabled: true
          }));
          promises.push(session.send("Network.addInterception", {
            url: ".*",
            stage: "request",
            isRegex: true
          }));
        }
        const contextOptions = this._browserContext._options;
        if (contextOptions.userAgent)
          promises.push(session.send("Page.overrideUserAgent", {
            value: contextOptions.userAgent
          }));
        if (this._page._state.mediaType || this._page._state.colorScheme || this._page._state.reducedMotion)
          promises.push(WKPage._setEmulateMedia(session, this._page._state.mediaType, this._page._state.colorScheme, this._page._state.reducedMotion));
        const bootstrapScript = this._calculateBootstrapScript();
        if (bootstrapScript.length)
          promises.push(session.send("Page.setBootstrapScript", {
            source: bootstrapScript
          }));
        this._page.frames().map((frame) => frame.evaluateExpression(bootstrapScript, false, void 0).catch((e) => {
        }));
        if (contextOptions.bypassCSP)
          promises.push(session.send("Page.setBypassCSP", {
            enabled: true
          }));
        if (this._page._state.emulatedSize) {
          promises.push(session.send("Page.setScreenSizeOverride", {
            width: this._page._state.emulatedSize.screen.width,
            height: this._page._state.emulatedSize.screen.height
          }));
        }
        promises.push(this.updateEmulateMedia());
        promises.push(session.send("Network.setExtraHTTPHeaders", {
          headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false)
        }));
        if (contextOptions.offline)
          promises.push(session.send("Network.setEmulateOfflineState", {
            offline: true
          }));
        promises.push(session.send("Page.setTouchEmulationEnabled", {
          enabled: !!contextOptions.hasTouch
        }));
        if (contextOptions.timezoneId) {
          promises.push(session.send("Page.setTimeZone", {
            timeZone: contextOptions.timezoneId
          }).catch((e) => {
            throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);
          }));
        }
        promises.push(session.send("Page.overrideSetting", {
          setting: "DeviceOrientationEventEnabled",
          value: contextOptions.isMobile
        }));
        promises.push(session.send("Page.overrideSetting", {
          setting: "FullScreenEnabled",
          value: !contextOptions.isMobile
        }));
        promises.push(session.send("Page.overrideSetting", {
          setting: "NotificationsEnabled",
          value: !contextOptions.isMobile
        }));
        promises.push(session.send("Page.overrideSetting", {
          setting: "PointerLockEnabled",
          value: !contextOptions.isMobile
        }));
        promises.push(session.send("Page.overrideSetting", {
          setting: "InputTypeMonthEnabled",
          value: contextOptions.isMobile
        }));
        promises.push(session.send("Page.overrideSetting", {
          setting: "InputTypeWeekEnabled",
          value: contextOptions.isMobile
        }));
        await Promise.all(promises);
      }
      _onDidCommitProvisionalTarget(event) {
        const {
          oldTargetId,
          newTargetId
        } = event;
        (0, _utils.assert)(this._provisionalPage);
        (0, _utils.assert)(this._provisionalPage._session.sessionId === newTargetId, "Unknown new target: " + newTargetId);
        (0, _utils.assert)(this._session.sessionId === oldTargetId, "Unknown old target: " + oldTargetId);
        const newSession = this._provisionalPage._session;
        this._provisionalPage.commit();
        this._provisionalPage.dispose();
        this._provisionalPage = null;
        this._setSession(newSession);
      }
      _onTargetDestroyed(event) {
        const {
          targetId,
          crashed
        } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
          this._provisionalPage._session.dispose(false);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        } else if (this._session.sessionId === targetId) {
          this._session.dispose(false);
          _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
          if (crashed) {
            this._session.markAsCrashed();
            this._page._didCrash();
          }
        }
      }
      didClose() {
        this._page._didClose();
      }
      dispose(disconnected) {
        this._pageProxySession.dispose(disconnected);
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        if (this._session)
          this._session.dispose(disconnected);
        if (this._provisionalPage) {
          this._provisionalPage._session.dispose(disconnected);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        }
        this._page._didDisconnect();
        this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
      }
      dispatchMessageToSession(message) {
        this._pageProxySession.dispatchMessage(message);
      }
      handleProvisionalLoadFailed(event) {
        if (!this._initializedPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Initial load failed"));
          return;
        }
        if (!this._provisionalPage)
          return;
        let errorText = event.error;
        if (errorText.includes("cancelled"))
          errorText += "; maybe frame was detached?";
        this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
      }
      handleWindowOpen(event) {
        (0, _utils.debugAssert)(!this._nextWindowOpenPopupFeatures);
        this._nextWindowOpenPopupFeatures = event.windowFeatures;
      }
      async pageOrError() {
        return this._pagePromise;
      }
      async _onTargetCreated(event) {
        const {
          targetInfo
        } = event;
        const session = new _wkConnection.WKSession(this._pageProxySession.connection, targetInfo.targetId, `Target closed`, (message) => {
          this._pageProxySession.send("Target.sendMessageToTarget", {
            message: JSON.stringify(message),
            targetId: targetInfo.targetId
          }).catch((e) => {
            session.dispatchMessage({
              id: message.id,
              error: {
                message: e.message
              }
            });
          });
        });
        (0, _utils.assert)(targetInfo.type === "page", "Only page targets are expected in WebKit, received: " + targetInfo.type);
        if (!targetInfo.isProvisional) {
          (0, _utils.assert)(!this._initializedPage);
          let pageOrError;
          try {
            this._setSession(session);
            await Promise.all([this._initializePageProxySession(), this._initializeSession(session, false, ({
              frameTree
            }) => this._handleFrameTree(frameTree))]);
            pageOrError = this._page;
          } catch (e) {
            pageOrError = e;
          }
          if (targetInfo.isPaused)
            this._pageProxySession.sendMayFail("Target.resume", {
              targetId: targetInfo.targetId
            });
          if (pageOrError instanceof _page.Page && this._page.mainFrame().url() === "") {
            try {
              await this._firstNonInitialNavigationCommittedPromise;
            } catch (e) {
              pageOrError = e;
            }
          } else {
            this._firstNonInitialNavigationCommittedPromise.catch(() => {
            });
          }
          await this._page.initOpener(this._opener);
          this._initializedPage = pageOrError instanceof _page.Page ? pageOrError : null;
          this._page.reportAsNew(pageOrError instanceof _page.Page ? void 0 : pageOrError);
          this._pagePromise.resolve(pageOrError);
        } else {
          (0, _utils.assert)(targetInfo.isProvisional);
          (0, _utils.assert)(!this._provisionalPage);
          this._provisionalPage = new _wkProvisionalPage.WKProvisionalPage(session, this);
          if (targetInfo.isPaused) {
            this._provisionalPage.initializationPromise.then(() => {
              this._pageProxySession.sendMayFail("Target.resume", {
                targetId: targetInfo.targetId
              });
            });
          }
        }
      }
      _onDispatchMessageFromTarget(event) {
        const {
          targetId,
          message
        } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId)
          this._provisionalPage._session.dispatchMessage(JSON.parse(message));
        else if (this._session.sessionId === targetId)
          this._session.dispatchMessage(JSON.parse(message));
        else
          throw new Error("Unknown target: " + targetId);
      }
      _addSessionListeners() {
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameScheduledNavigation", (event) => this._onFrameScheduledNavigation(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.loadEventFired", (event) => this._onLifecycleEvent(event.frameId, "load")), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.domContentEventFired", (event) => this._onLifecycleEvent(event.frameId, "domcontentloaded")), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._session, "Console.messageAdded", (event) => this._onConsoleMessage(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Console.messageRepeatCountUpdated", (event) => this._onConsoleRepeatCountUpdated(event)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Dialog.javascriptDialogOpening", (event) => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.requestWillBeSent", (e) => this._onRequestWillBeSent(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.requestIntercepted", (e) => this._onRequestIntercepted(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.responseReceived", (e) => this._onResponseReceived(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.loadingFinished", (e) => this._onLoadingFinished(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.loadingFailed", (e) => this._onLoadingFailed(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];
      }
      async _updateState(method, params) {
        await this._forAllSessions((session) => session.send(method, params).then());
      }
      async _forAllSessions(callback) {
        const sessions = [this._session];
        if (this._provisionalPage)
          sessions.push(this._provisionalPage._session);
        await Promise.all(sessions.map((session) => callback(session).catch((e) => {
        })));
      }
      _onFrameScheduledNavigation(frameId) {
        this._page._frameManager.frameRequestedNavigation(frameId);
      }
      _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
      }
      _onLifecycleEvent(frameId, event) {
        this._page._frameManager.frameLifecycleEvent(frameId, event);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "domcontentloaded");
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "load");
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _onFrameAttached(frameId, parentFrameId) {
        return this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        const frame = this._page._frameManager.frame(framePayload.id);
        (0, _utils.assert)(frame);
        this._removeContextsForFrame(frame, true);
        if (!framePayload.parentId)
          this._workers.clear();
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
      }
      _removeContextsForFrame(frame, notifyFrame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame) {
            this._contextIdToContext.delete(contextId);
            if (notifyFrame)
              frame._contextDestroyed(context);
          }
        }
      }
      _onExecutionContextCreated(contextPayload) {
        if (this._contextIdToContext.has(contextPayload.id))
          return;
        const frame = this._page._frameManager.frame(contextPayload.frameId);
        if (!frame)
          return;
        const delegate = new _wkExecutionContext.WKExecutionContext(this._session, contextPayload.id);
        let worldName = null;
        if (contextPayload.type === "normal")
          worldName = "main";
        else if (contextPayload.type === "user" && contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        if (contextPayload.type === "normal" && frame === this._page.mainFrame())
          this._mainFrameContextId = contextPayload.id;
        this._contextIdToContext.set(contextPayload.id, context);
      }
      async navigateFrame(frame, url, referrer) {
        if (this._pageProxySession.isDisposed())
          throw new Error("Target closed");
        const pageProxyId = this._pageProxySession.sessionId;
        const result = await this._pageProxySession.connection.browserSession.send("Playwright.navigate", {
          url,
          pageProxyId,
          frameId: frame._id,
          referrer
        });
        return {
          newDocumentId: result.loaderId
        };
      }
      _onConsoleMessage(event) {
        const {
          type,
          level,
          text,
          parameters,
          url,
          line: lineNumber,
          column: columnNumber,
          source
        } = event.message;
        if (level === "debug" && parameters && parameters[0].value === BINDING_CALL_MESSAGE) {
          const parsedObjectId = JSON.parse(parameters[1].objectId);
          this.pageOrError().then((pageOrError) => {
            const context = this._contextIdToContext.get(parsedObjectId.injectedScriptId);
            if (!(pageOrError instanceof Error) && context)
              this._page._onBindingCalled(parameters[2].value, context);
          });
          return;
        }
        if (level === "error" && source === "javascript") {
          const {
            name,
            message
          } = (0, _stackTrace.splitErrorMessage)(text);
          let stack;
          if (event.message.stackTrace) {
            stack = text + "\n" + event.message.stackTrace.map((callFrame) => {
              return `    at ${callFrame.functionName || "unknown"} (${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber})`;
            }).join("\n");
          } else {
            stack = "";
          }
          const error2 = new Error(message);
          error2.stack = stack;
          error2.name = name;
          this._page.firePageError(error2);
          return;
        }
        let derivedType = type || "";
        if (type === "log")
          derivedType = level;
        else if (type === "timing")
          derivedType = "timeEnd";
        const handles = [];
        for (const p of parameters || []) {
          let context;
          if (p.objectId) {
            const objectId = JSON.parse(p.objectId);
            context = this._contextIdToContext.get(objectId.injectedScriptId);
          } else {
            context = this._contextIdToContext.get(this._mainFrameContextId);
          }
          if (!context)
            return;
          handles.push(context.createHandle(p));
        }
        this._lastConsoleMessage = {
          derivedType,
          text,
          handles,
          count: 0,
          location: {
            url: url || "",
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
          }
        };
        this._onConsoleRepeatCountUpdated({
          count: 1
        });
      }
      _onConsoleRepeatCountUpdated(event) {
        if (this._lastConsoleMessage) {
          const {
            derivedType,
            text,
            handles,
            count,
            location: location2
          } = this._lastConsoleMessage;
          for (let i = count; i < event.count; ++i)
            this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
          this._lastConsoleMessage.count = event.count;
        }
      }
      _onDialog(event) {
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {
          await this._pageProxySession.send("Dialog.handleJavaScriptDialog", {
            accept,
            promptText
          });
        }, event.defaultPrompt));
      }
      async _onFileChooserOpened(event) {
        let handle;
        try {
          const context = await this._page._frameManager.frame(event.frameId)._mainContext();
          handle = context.createHandle(event.element).asElement();
        } catch (e) {
          return;
        }
        await this._page._onFileChooserOpened(handle);
      }
      static async _setEmulateMedia(session, mediaType, colorScheme, reducedMotion) {
        const promises = [];
        promises.push(session.send("Page.setEmulatedMedia", {
          media: mediaType || ""
        }));
        let appearance = void 0;
        switch (colorScheme) {
          case "light":
            appearance = "Light";
            break;
          case "dark":
            appearance = "Dark";
            break;
        }
        promises.push(session.send("Page.setForcedAppearance", {
          appearance
        }));
        let reducedMotionWk = void 0;
        switch (reducedMotion) {
          case "reduce":
            reducedMotionWk = "Reduce";
            break;
          case "no-preference":
            reducedMotionWk = "NoPreference";
            break;
        }
        promises.push(session.send("Page.setForcedReducedMotion", {
          reducedMotion: reducedMotionWk
        }));
        await Promise.all(promises);
      }
      async updateExtraHTTPHeaders() {
        await this._updateState("Network.setExtraHTTPHeaders", {
          headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false)
        });
      }
      _calculateExtraHTTPHeaders() {
        const locale = this._browserContext._options.locale;
        const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._page._state.extraHTTPHeaders, locale ? network.singleHeader("Accept-Language", locale) : void 0]);
        return headers;
      }
      async updateEmulateMedia() {
        const colorScheme = this._page._state.colorScheme;
        const reducedMotion = this._page._state.reducedMotion;
        await this._forAllSessions((session) => WKPage._setEmulateMedia(session, this._page._state.mediaType, colorScheme, reducedMotion));
      }
      async setEmulatedSize(emulatedSize) {
        (0, _utils.assert)(this._page._state.emulatedSize === emulatedSize);
        await this._updateViewport();
      }
      async bringToFront() {
        this._pageProxySession.send("Target.activate", {
          targetId: this._session.sessionId
        });
      }
      async _updateViewport() {
        const options2 = this._browserContext._options;
        const deviceSize = this._page._state.emulatedSize;
        if (deviceSize === null)
          return;
        const viewportSize = deviceSize.viewport;
        const screenSize = deviceSize.screen;
        const promises = [this._pageProxySession.send("Emulation.setDeviceMetricsOverride", {
          width: viewportSize.width,
          height: viewportSize.height,
          fixedLayout: !!options2.isMobile,
          deviceScaleFactor: options2.deviceScaleFactor || 1
        }), this._session.send("Page.setScreenSizeOverride", {
          width: screenSize.width,
          height: screenSize.height
        })];
        if (options2.isMobile) {
          const angle = viewportSize.width > viewportSize.height ? 90 : 0;
          promises.push(this._session.send("Page.setOrientationOverride", {
            angle
          }));
        }
        await Promise.all(promises);
      }
      async updateRequestInterception() {
        const enabled = this._page._needsRequestInterception();
        await Promise.all([this._updateState("Network.setInterceptionEnabled", {
          enabled
        }), this._updateState("Network.addInterception", {
          url: ".*",
          stage: "request",
          isRegex: true
        })]);
      }
      async updateOffline() {
        await this._updateState("Network.setEmulateOfflineState", {
          offline: !!this._browserContext._options.offline
        });
      }
      async updateHttpCredentials() {
        const credentials = this._browserContext._options.httpCredentials || {
          username: "",
          password: ""
        };
        await this._pageProxySession.send("Emulation.setAuthCredentials", {
          username: credentials.username,
          password: credentials.password
        });
      }
      async setFileChooserIntercepted(enabled) {
        await this._session.send("Page.setInterceptFileChooserDialog", {
          enabled
        }).catch((e) => {
        });
      }
      async reload() {
        await this._session.send("Page.reload");
      }
      goBack() {
        return this._session.send("Page.goBack").then(() => true).catch((error2) => {
          if (error2 instanceof Error && error2.message.includes(`Protocol error (Page.goBack): Failed to go`))
            return false;
          throw error2;
        });
      }
      goForward() {
        return this._session.send("Page.goForward").then(() => true).catch((error2) => {
          if (error2 instanceof Error && error2.message.includes(`Protocol error (Page.goForward): Failed to go`))
            return false;
          throw error2;
        });
      }
      async exposeBinding(binding) {
        await this._updateBootstrapScript();
        await this._evaluateBindingScript(binding);
      }
      async _evaluateBindingScript(binding) {
        const script = this._bindingToScript(binding);
        await Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(script, false, {}).catch((e) => {
        })));
      }
      async evaluateOnNewDocument(script) {
        await this._updateBootstrapScript();
      }
      _bindingToScript(binding) {
        return `self.${binding.name} = (param) => console.debug('${BINDING_CALL_MESSAGE}', {}, param); ${binding.source}`;
      }
      _calculateBootstrapScript() {
        const scripts = [];
        for (const binding of this._page.allBindings())
          scripts.push(this._bindingToScript(binding));
        scripts.push(...this._browserContext._evaluateOnNewDocumentSources);
        scripts.push(...this._page._evaluateOnNewDocumentSources);
        return scripts.join(";");
      }
      async _updateBootstrapScript() {
        await this._updateState("Page.setBootstrapScript", {
          source: this._calculateBootstrapScript()
        });
      }
      async closePage(runBeforeUnload) {
        await this._stopVideo();
        await this._pageProxySession.sendMayFail("Target.close", {
          targetId: this._session.sessionId,
          runBeforeUnload
        });
      }
      canScreenshotOutsideViewport() {
        return true;
      }
      async setBackgroundColor(color) {
        await this._session.send("Page.setDefaultBackgroundColorOverride", {
          color
        });
      }
      _toolbarHeight() {
        var _this$_page$_browserC;
        if ((_this$_page$_browserC = this._page._browserContext._browser) !== null && _this$_page$_browserC !== void 0 && _this$_page$_browserC.options.headful)
          return _utils.hostPlatform === "mac10.15" ? 55 : 59;
        return 0;
      }
      async _startVideo(options2) {
        (0, _utils.assert)(!this._recordingVideoFile);
        const {
          screencastId
        } = await this._pageProxySession.send("Screencast.startVideo", {
          file: options2.outputFile,
          width: options2.width,
          height: options2.height,
          toolbarHeight: this._toolbarHeight()
        });
        this._recordingVideoFile = options2.outputFile;
        this._browserContext._browser._videoStarted(this._browserContext, screencastId, options2.outputFile, this.pageOrError());
      }
      async _stopVideo() {
        if (!this._recordingVideoFile)
          return;
        await this._pageProxySession.sendMayFail("Screencast.stopVideo");
        this._recordingVideoFile = null;
      }
      async takeScreenshot(progress, format2, documentRect, viewportRect, quality) {
        const rect = documentRect || viewportRect;
        const result = await this._session.send("Page.snapshotRect", __spreadProps(__spreadValues({}, rect), {
          coordinateSystem: documentRect ? "Page" : "Viewport"
        }));
        const prefix = "data:image/png;base64,";
        let buffer = Buffer.from(result.dataURL.substr(prefix.length), "base64");
        if (format2 === "jpeg")
          buffer = jpeg.encode(png.PNG.sync.read(buffer), quality).data;
        return buffer;
      }
      async resetViewport() {
        (0, _utils.assert)(false, "Should not be called");
      }
      async getContentFrame(handle) {
        const nodeInfo = await this._session.send("DOM.describeNode", {
          objectId: handle._objectId
        });
        if (!nodeInfo.contentFrameId)
          return null;
        return this._page._frameManager.frame(nodeInfo.contentFrameId);
      }
      async getOwnerFrame(handle) {
        if (!handle._objectId)
          return null;
        const nodeInfo = await this._session.send("DOM.describeNode", {
          objectId: handle._objectId
        });
        return nodeInfo.ownerFrameId || null;
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
          return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
          for (const point of quad) {
            minX = Math.min(minX, point.x);
            maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y);
            maxY = Math.max(maxY, point.y);
          }
        }
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      async scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._session.send("DOM.scrollIntoViewIfNeeded", {
          objectId: handle._objectId,
          rect
        }).then(() => "done").catch((e) => {
          if (e instanceof Error && e.message.includes("Node does not have a layout object"))
            return "error:notvisible";
          if (e instanceof Error && e.message.includes("Node is detached from document"))
            return "error:notconnected";
          throw e;
        });
      }
      async setScreencastOptions(options2) {
        if (options2) {
          const so = __spreadProps(__spreadValues({}, options2), {
            toolbarHeight: this._toolbarHeight()
          });
          const {
            generation
          } = await this._pageProxySession.send("Screencast.startScreencast", so);
          this._screencastGeneration = generation;
        } else {
          await this._pageProxySession.send("Screencast.stopScreencast");
        }
      }
      _onScreencastFrame(event) {
        const generation = this._screencastGeneration;
        this._page.throttleScreencastFrameAck(() => {
          this._pageProxySession.send("Screencast.screencastFrameAck", {
            generation
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        });
        const buffer = Buffer.from(event.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          width: event.deviceWidth,
          height: event.deviceHeight
        });
      }
      rafCountForStablePosition() {
        return process.platform === "win32" ? 5 : 1;
      }
      async getContentQuads(handle) {
        const result = await this._session.sendMayFail("DOM.getContentQuads", {
          objectId: handle._objectId
        });
        if (!result)
          return null;
        return result.quads.map((quad) => [{
          x: quad[0],
          y: quad[1]
        }, {
          x: quad[2],
          y: quad[3]
        }, {
          x: quad[4],
          y: quad[5]
        }, {
          x: quad[6],
          y: quad[7]
        }]);
      }
      async setInputFiles(handle, files) {
        const objectId = handle._objectId;
        const protocolFiles = files.map((file) => ({
          name: file.name,
          type: file.mimeType,
          data: file.buffer
        }));
        await this._session.send("DOM.setInputFiles", {
          objectId,
          files: protocolFiles
        });
      }
      async adoptElementHandle(handle, to) {
        const result = await this._session.sendMayFail("DOM.resolveNode", {
          objectId: handle._objectId,
          executionContextId: to[contextDelegateSymbol]._contextId
        });
        if (!result || result.object.subtype === "null")
          throw new Error(dom.kUnableToAdoptErrorMessage);
        return to.createHandle(result.object);
      }
      async getAccessibilityTree(needle) {
        return (0, _wkAccessibility.getAccessibilityTree)(this._session, needle);
      }
      async inputActionEpilogue() {
      }
      async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
          throw new Error("Frame has been detached.");
        const info = this._page.parseSelector("frame,iframe");
        const handles = await this._page.selectors._queryAll(parent, info);
        const items = await Promise.all(handles.map(async (handle) => {
          const frame2 = await handle.contentFrame().catch((e) => null);
          return {
            handle,
            frame: frame2
          };
        }));
        const result = items.find((item) => item.frame === frame);
        items.map((item) => item === result ? Promise.resolve() : item.handle.dispose());
        if (!result)
          throw new Error("Frame has been detached.");
        return result.handle;
      }
      _onRequestWillBeSent(session, event) {
        if (event.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (event.redirectResponse) {
          const request2 = this._requestIdToRequest.get(event.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, event.redirectResponse, event.timestamp);
            redirectedFrom = request2;
          }
        }
        const frame = redirectedFrom ? redirectedFrom.request.frame() : this._page._frameManager.frame(event.frameId);
        if (!frame)
          return;
        const isNavigationRequest = event.type === "Document";
        const documentId = isNavigationRequest ? event.loaderId : void 0;
        let route = null;
        if (this._page._needsRequestInterception() && !redirectedFrom)
          route = new _wkInterceptableRequest.WKRouteImpl(session, event.requestId);
        const request = new _wkInterceptableRequest.WKInterceptableRequest(session, route, frame, event, redirectedFrom, documentId);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request, route || void 0);
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = request.createResponse(responsePayload);
        response._securityDetailsFinished();
        response._serverAddrFinished();
        response._requestFinished(responsePayload.timing ? _helper.helper.secondsToRoundishMillis(timestamp - request._timestamp) : -1);
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onRequestIntercepted(session, event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request) {
          session.sendMayFail("Network.interceptRequestWithError", {
            errorType: "Cancellation",
            requestId: event.requestId
          });
          return;
        }
        if (!request._route) {
          session.sendMayFail("Network.interceptWithRequest", {
            requestId: request._requestId
          });
        } else {
          request._route._requestInterceptedPromise.resolve();
        }
      }
      _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        this._requestIdToResponseReceivedPayloadEvent.set(request._requestId, event);
        const response = request.createResponse(event.response);
        if (event.response.requestHeaders && Object.keys(event.response.requestHeaders).length) {
          const headers = __spreadValues({}, event.response.requestHeaders);
          if (!headers["host"])
            headers["Host"] = new URL(request.request.url()).host;
          request.request.setRawRequestHeaders((0, _utils.headersObjectToArray)(headers));
        }
        this._page._frameManager.requestReceivedResponse(response);
        if (response.status() === 204) {
          this._onLoadingFailed({
            requestId: event.requestId,
            errorText: "Aborted: 204 No Content",
            timestamp: event.timestamp
          });
        }
      }
      _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          var _event$metrics, _event$metrics2, _event$metrics2$secur, _responseReceivedPayl, _responseReceivedPayl2, _responseReceivedPayl3, _responseReceivedPayl4, _responseReceivedPayl5, _responseReceivedPayl6, _event$metrics3, _event$metrics4, _event$metrics5;
          const responseReceivedPayload = this._requestIdToResponseReceivedPayloadEvent.get(request._requestId);
          response._serverAddrFinished(parseRemoteAddress(event === null || event === void 0 ? void 0 : (_event$metrics = event.metrics) === null || _event$metrics === void 0 ? void 0 : _event$metrics.remoteAddress));
          response._securityDetailsFinished({
            protocol: isLoadedSecurely(response.url(), response.timing()) ? (_event$metrics2 = event.metrics) === null || _event$metrics2 === void 0 ? void 0 : (_event$metrics2$secur = _event$metrics2.securityConnection) === null || _event$metrics2$secur === void 0 ? void 0 : _event$metrics2$secur.protocol : void 0,
            subjectName: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl = responseReceivedPayload.response.security) === null || _responseReceivedPayl === void 0 ? void 0 : (_responseReceivedPayl2 = _responseReceivedPayl.certificate) === null || _responseReceivedPayl2 === void 0 ? void 0 : _responseReceivedPayl2.subject,
            validFrom: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl3 = responseReceivedPayload.response.security) === null || _responseReceivedPayl3 === void 0 ? void 0 : (_responseReceivedPayl4 = _responseReceivedPayl3.certificate) === null || _responseReceivedPayl4 === void 0 ? void 0 : _responseReceivedPayl4.validFrom,
            validTo: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl5 = responseReceivedPayload.response.security) === null || _responseReceivedPayl5 === void 0 ? void 0 : (_responseReceivedPayl6 = _responseReceivedPayl5.certificate) === null || _responseReceivedPayl6 === void 0 ? void 0 : _responseReceivedPayl6.validUntil
          });
          if ((_event$metrics3 = event.metrics) !== null && _event$metrics3 !== void 0 && _event$metrics3.protocol)
            response._setHttpVersion(event.metrics.protocol);
          if ((_event$metrics4 = event.metrics) !== null && _event$metrics4 !== void 0 && _event$metrics4.responseBodyBytesReceived)
            request.request.responseSize.encodedBodySize = event.metrics.responseBodyBytesReceived;
          if ((_event$metrics5 = event.metrics) !== null && _event$metrics5 !== void 0 && _event$metrics5.responseHeaderBytesReceived)
            request.request.responseSize.responseHeadersSize = event.metrics.responseHeaderBytesReceived;
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToResponseReceivedPayloadEvent.delete(request._requestId);
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          response._serverAddrFinished();
          response._securityDetailsFinished();
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToRequest.delete(request._requestId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, event.errorText.includes("cancelled"));
      }
      async _grantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([["geolocation", "geolocation"]]);
        const filtered = permissions.map((permission) => {
          const protocolPermission = webPermissionToProtocol.get(permission);
          if (!protocolPermission)
            throw new Error("Unknown permission: " + permission);
          return protocolPermission;
        });
        await this._pageProxySession.send("Emulation.grantPermissions", {
          origin,
          permissions: filtered
        });
      }
      async _clearPermissions() {
        await this._pageProxySession.send("Emulation.resetPermissions", {});
      }
    };
    exports.WKPage = WKPage;
    function parseRemoteAddress(value) {
      if (!value)
        return;
      try {
        const colon = value.lastIndexOf(":");
        const dot = value.lastIndexOf(".");
        if (dot < 0) {
          return {
            ipAddress: `[${value.slice(0, colon)}]`,
            port: +value.slice(colon + 1)
          };
        }
        if (colon > dot) {
          const [address, port] = value.split(":");
          return {
            ipAddress: address,
            port: +port
          };
        } else {
          const [address, port] = value.split(".");
          return {
            ipAddress: `[${address}]`,
            port: +port
          };
        }
      } catch (_) {
      }
    }
    function isLoadedSecurely(url, timing) {
      try {
        const u = new URL(url);
        if (u.protocol !== "https:" && u.protocol !== "wss:" && u.protocol !== "sftp:")
          return false;
        if (timing.secureConnectionStart === -1 && timing.connectStart !== -1)
          return false;
        return true;
      } catch (_) {
      }
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/webkit/wkBrowser.js
var require_wkBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkBrowser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WKBrowserContext = exports.WKBrowser = void 0;
    var _browser = require_browser2();
    var _browserContext = require_browserContext();
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var network = _interopRequireWildcard(require_network());
    var _wkConnection = require_wkConnection();
    var _wkPage = require_wkPage();
    var _errors = require_errors();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var DEFAULT_USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Safari/605.1.15";
    var BROWSER_VERSION = "15.4";
    var WKBrowser = class extends _browser.Browser {
      static async connect(transport, options2) {
        const browser = new WKBrowser(transport, options2);
        if (options2.__testHookOnConnectToBrowser)
          await options2.__testHookOnConnectToBrowser();
        const promises = [browser._browserSession.send("Playwright.enable")];
        if (options2.persistent) {
          browser._defaultContext = new WKBrowserContext(browser, void 0, options2.persistent);
          promises.push(browser._defaultContext._initialize());
        }
        await Promise.all(promises);
        return browser;
      }
      constructor(transport, options2) {
        super(options2);
        this._connection = void 0;
        this._browserSession = void 0;
        this._contexts = new Map();
        this._wkPages = new Map();
        this._eventListeners = void 0;
        this._connection = new _wkConnection.WKConnection(transport, this._onDisconnect.bind(this), options2.protocolLogger, options2.browserLogsCollector);
        this._browserSession = this._connection.browserSession;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.pageProxyCreated", this._onPageProxyCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.pageProxyDestroyed", this._onPageProxyDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.provisionalLoadFailed", (event) => this._onProvisionalLoadFailed(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.windowOpen", (event) => this._onWindowOpen(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadCreated", this._onDownloadCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadFilenameSuggested", this._onDownloadFilenameSuggested.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadFinished", this._onDownloadFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.screencastFinished", this._onScreencastFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, _wkConnection.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this))];
      }
      _onDisconnect() {
        for (const wkPage of this._wkPages.values())
          wkPage.dispose(true);
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(_errors.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
      async newContext(options2) {
        (0, _browserContext.validateBrowserContextOptions)(options2, this.options);
        const createOptions = options2.proxy ? {
          proxyServer: options2.proxy.server,
          proxyBypassList: options2.proxy.bypass
        } : void 0;
        const {
          browserContextId
        } = await this._browserSession.send("Playwright.createContext", createOptions);
        options2.userAgent = options2.userAgent || DEFAULT_USER_AGENT;
        const context = new WKBrowserContext(this, browserContextId, options2);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return BROWSER_VERSION;
      }
      userAgent() {
        return DEFAULT_USER_AGENT;
      }
      _onDownloadCreated(payload) {
        const page = this._wkPages.get(payload.pageProxyId);
        if (!page)
          return;
        page._page._frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
        let originPage = page._initializedPage;
        if (!originPage) {
          page._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
          if (page._opener)
            originPage = page._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url);
      }
      _onDownloadFilenameSuggested(payload) {
        this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
      }
      _onDownloadFinished(payload) {
        this._downloadFinished(payload.uuid, payload.error);
      }
      _onScreencastFinished(payload) {
        var _this$_takeVideo;
        (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
      }
      _onPageProxyCreated(event) {
        const pageProxyId = event.pageProxyId;
        let context = null;
        if (event.browserContextId) {
          context = this._contexts.get(event.browserContextId) || null;
        }
        if (!context)
          context = this._defaultContext;
        if (!context)
          return;
        const pageProxySession = new _wkConnection.WKSession(this._connection, pageProxyId, `Target closed`, (message) => {
          this._connection.rawSend(__spreadProps(__spreadValues({}, message), {
            pageProxyId
          }));
        });
        const opener = event.openerId ? this._wkPages.get(event.openerId) : void 0;
        const wkPage = new _wkPage.WKPage(context, pageProxySession, opener || null);
        this._wkPages.set(pageProxyId, wkPage);
      }
      _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const wkPage = this._wkPages.get(pageProxyId);
        if (!wkPage)
          return;
        wkPage.didClose();
        wkPage.dispose(false);
        this._wkPages.delete(pageProxyId);
      }
      _onPageProxyMessageReceived(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.dispatchMessageToSession(event.message);
      }
      _onProvisionalLoadFailed(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleProvisionalLoadFailed(event);
      }
      _onWindowOpen(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleWindowOpen(event);
      }
      isConnected() {
        return !this._connection.isClosed();
      }
    };
    exports.WKBrowser = WKBrowser;
    var WKBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options2) {
        super(browser, options2, browserContextId);
        this._evaluateOnNewDocumentSources = void 0;
        this._evaluateOnNewDocumentSources = [];
        this._authenticateProxyViaHeader();
      }
      async _initialize() {
        (0, _utils.assert)(!this._wkPages().length);
        const browserContextId = this._browserContextId;
        const promises = [super._initialize()];
        promises.push(this._browser._browserSession.send("Playwright.setDownloadBehavior", {
          behavior: this._options.acceptDownloads ? "allow" : "deny",
          downloadPath: this._browser.options.downloadsPath,
          browserContextId
        }));
        if (this._options.ignoreHTTPSErrors)
          promises.push(this._browser._browserSession.send("Playwright.setIgnoreCertificateErrors", {
            browserContextId,
            ignore: true
          }));
        if (this._options.locale)
          promises.push(this._browser._browserSession.send("Playwright.setLanguages", {
            browserContextId,
            languages: [this._options.locale]
          }));
        if (this._options.permissions)
          promises.push(this.grantPermissions(this._options.permissions));
        if (this._options.geolocation)
          promises.push(this.setGeolocation(this._options.geolocation));
        if (this._options.offline)
          promises.push(this.setOffline(this._options.offline));
        if (this._options.httpCredentials)
          promises.push(this.setHTTPCredentials(this._options.httpCredentials));
        await Promise.all(promises);
      }
      _wkPages() {
        return Array.from(this._browser._wkPages.values()).filter((wkPage) => wkPage._browserContext === this);
      }
      pages() {
        return this._wkPages().map((wkPage) => wkPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      async newPageDelegate() {
        (0, _browserContext.assertBrowserContextIsNotOwned)(this);
        const {
          pageProxyId
        } = await this._browser._browserSession.send("Playwright.createPage", {
          browserContextId: this._browserContextId
        });
        return this._browser._wkPages.get(pageProxyId);
      }
      async _doCookies(urls) {
        const {
          cookies
        } = await this._browser._browserSession.send("Playwright.getAllCookies", {
          browserContextId: this._browserContextId
        });
        return network.filterCookies(cookies.map((c) => {
          const copy = __spreadValues({}, c);
          copy.expires = c.expires === -1 ? -1 : c.expires / 1e3;
          delete copy.session;
          return copy;
        }), urls);
      }
      async addCookies(cookies) {
        const cc = network.rewriteCookies(cookies).map((c) => __spreadProps(__spreadValues({}, c), {
          session: c.expires === -1 || c.expires === void 0,
          expires: c.expires && c.expires !== -1 ? c.expires * 1e3 : c.expires
        }));
        await this._browser._browserSession.send("Playwright.setCookies", {
          cookies: cc,
          browserContextId: this._browserContextId
        });
      }
      async clearCookies() {
        await this._browser._browserSession.send("Playwright.deleteAllCookies", {
          browserContextId: this._browserContextId
        });
      }
      async _doGrantPermissions(origin, permissions) {
        await Promise.all(this.pages().map((page) => page._delegate._grantPermissions(origin, permissions)));
      }
      async _doClearPermissions() {
        await Promise.all(this.pages().map((page) => page._delegate._clearPermissions()));
      }
      async setGeolocation(geolocation) {
        (0, _browserContext.verifyGeolocation)(geolocation);
        this._options.geolocation = geolocation;
        const payload = geolocation ? __spreadProps(__spreadValues({}, geolocation), {
          timestamp: Date.now()
        }) : void 0;
        await this._browser._browserSession.send("Playwright.setGeolocationOverride", {
          browserContextId: this._browserContextId,
          geolocation: payload
        });
      }
      async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        for (const page of this.pages())
          await page._delegate.updateExtraHTTPHeaders();
      }
      async setOffline(offline) {
        this._options.offline = offline;
        for (const page of this.pages())
          await page._delegate.updateOffline();
      }
      async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        for (const page of this.pages())
          await page._delegate.updateHttpCredentials();
      }
      async _doAddInitScript(source) {
        this._evaluateOnNewDocumentSources.push(source);
        for (const page of this.pages())
          await page._delegate._updateBootstrapScript();
      }
      async _doExposeBinding(binding) {
        for (const page of this.pages())
          await page._delegate.exposeBinding(binding);
      }
      async _doUpdateRequestInterception() {
        for (const page of this.pages())
          await page._delegate.updateRequestInterception();
      }
      _onClosePersistent() {
      }
      async _doClose() {
        (0, _utils.assert)(this._browserContextId);
        await this._browser._browserSession.send("Playwright.deleteContext", {
          browserContextId: this._browserContextId
        });
        this._browser._contexts.delete(this._browserContextId);
      }
      async _doCancelDownload(uuid) {
        await this._browser._browserSession.send("Playwright.cancelDownload", {
          uuid
        });
      }
    };
    exports.WKBrowserContext = WKBrowserContext;
  }
});

// node_modules/playwright-core/lib/server/webkit/webkit.js
var require_webkit = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/webkit.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WebKit = void 0;
    var _wkBrowser = require_wkBrowser();
    var _path = _interopRequireDefault(__require("path"));
    var _wkConnection = require_wkConnection();
    var _browserType = require_browserType();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WebKit = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("webkit", playwrightOptions);
      }
      _connectToTransport(transport, options2) {
        return _wkBrowser.WKBrowser.connect(transport, options2);
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return __spreadProps(__spreadValues({}, env), {
          CURL_COOKIE_JAR_PATH: _path.default.join(userDataDir, "cookiejar.db")
        });
      }
      _rewriteStartupError(error2) {
        return error2;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        transport.send({
          method: "Playwright.close",
          params: {},
          id: _wkConnection.kBrowserCloseMessageId
        });
      }
      _defaultArgs(options2, isPersistent, userDataDir) {
        const {
          args = [],
          proxy,
          devtools,
          headless
        } = options2;
        if (devtools)
          console.warn("devtools parameter as a launch argument in WebKit is not supported. Also starting Web Inspector manually will terminate the execution in WebKit.");
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const webkitArguments = ["--inspector-pipe"];
        if (process.platform === "win32")
          webkitArguments.push("--disable-accelerated-compositing");
        if (headless)
          webkitArguments.push("--headless");
        if (isPersistent)
          webkitArguments.push(`--user-data-dir=${userDataDir}`);
        else
          webkitArguments.push(`--no-startup-window`);
        if (proxy) {
          if (process.platform === "darwin") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
          } else if (process.platform === "linux") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(...proxy.bypass.split(",").map((t) => `--ignore-host=${t}`));
          } else if (process.platform === "win32") {
            webkitArguments.push(`--curl-proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
          }
        }
        webkitArguments.push(...args);
        if (isPersistent)
          webkitArguments.push("about:blank");
        return webkitArguments;
      }
    };
    exports.WebKit = WebKit;
  }
});

// node_modules/playwright-core/lib/server/playwright.js
var require_playwright = __commonJS({
  "node_modules/playwright-core/lib/server/playwright.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createPlaywright = createPlaywright;
    exports.Playwright = void 0;
    var _android2 = require_android();
    var _backendAdb = require_backendAdb();
    var _chromium = require_chromium();
    var _electron2 = require_electron2();
    var _firefox = require_firefox();
    var _selectors = require_selectors();
    var _webkit = require_webkit();
    var _instrumentation = require_instrumentation();
    var _debugLogger = require_debugLogger();
    var Playwright = class extends _instrumentation.SdkObject {
      constructor(sdkLanguage, isInternal) {
        super({
          attribution: {
            isInternal
          },
          instrumentation: (0, _instrumentation.createInstrumentation)()
        }, void 0, "Playwright");
        this.selectors = void 0;
        this.chromium = void 0;
        this.android = void 0;
        this.electron = void 0;
        this.firefox = void 0;
        this.webkit = void 0;
        this.options = void 0;
        this.instrumentation.addListener({
          onCallLog: (logName, message, sdkObject, metadata) => {
            _debugLogger.debugLogger.log(logName, message);
          }
        });
        this.options = {
          rootSdkObject: this,
          selectors: new _selectors.Selectors(),
          sdkLanguage
        };
        this.chromium = new _chromium.Chromium(this.options);
        this.firefox = new _firefox.Firefox(this.options);
        this.webkit = new _webkit.WebKit(this.options);
        this.electron = new _electron2.Electron(this.options);
        this.android = new _android2.Android(new _backendAdb.AdbBackend(), this.options);
        this.selectors = this.options.selectors;
      }
    };
    exports.Playwright = Playwright;
    function createPlaywright(sdkLanguage, isInternal = false) {
      return new Playwright(sdkLanguage, isInternal);
    }
  }
});

// node_modules/playwright-core/lib/utils/socksProxy.js
var require_socksProxy = __commonJS({
  "node_modules/playwright-core/lib/utils/socksProxy.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SocksConnection = void 0;
    var _net = _interopRequireDefault(__require("net"));
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SocksAuth;
    (function(SocksAuth2) {
      SocksAuth2[SocksAuth2["NO_AUTHENTICATION_REQUIRED"] = 0] = "NO_AUTHENTICATION_REQUIRED";
      SocksAuth2[SocksAuth2["GSSAPI"] = 1] = "GSSAPI";
      SocksAuth2[SocksAuth2["USERNAME_PASSWORD"] = 2] = "USERNAME_PASSWORD";
      SocksAuth2[SocksAuth2["NO_ACCEPTABLE_METHODS"] = 255] = "NO_ACCEPTABLE_METHODS";
    })(SocksAuth || (SocksAuth = {}));
    var SocksAddressType;
    (function(SocksAddressType2) {
      SocksAddressType2[SocksAddressType2["IPv4"] = 1] = "IPv4";
      SocksAddressType2[SocksAddressType2["FqName"] = 3] = "FqName";
      SocksAddressType2[SocksAddressType2["IPv6"] = 4] = "IPv6";
    })(SocksAddressType || (SocksAddressType = {}));
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["CONNECT"] = 1] = "CONNECT";
      SocksCommand2[SocksCommand2["BIND"] = 2] = "BIND";
      SocksCommand2[SocksCommand2["UDP_ASSOCIATE"] = 3] = "UDP_ASSOCIATE";
    })(SocksCommand || (SocksCommand = {}));
    var SocksReply;
    (function(SocksReply2) {
      SocksReply2[SocksReply2["Succeeded"] = 0] = "Succeeded";
      SocksReply2[SocksReply2["GeneralServerFailure"] = 1] = "GeneralServerFailure";
      SocksReply2[SocksReply2["NotAllowedByRuleSet"] = 2] = "NotAllowedByRuleSet";
      SocksReply2[SocksReply2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      SocksReply2[SocksReply2["HostUnreachable"] = 4] = "HostUnreachable";
      SocksReply2[SocksReply2["ConnectionRefused"] = 5] = "ConnectionRefused";
      SocksReply2[SocksReply2["TtlExpired"] = 6] = "TtlExpired";
      SocksReply2[SocksReply2["CommandNotSupported"] = 7] = "CommandNotSupported";
      SocksReply2[SocksReply2["AddressTypeNotSupported"] = 8] = "AddressTypeNotSupported";
    })(SocksReply || (SocksReply = {}));
    var SocksConnection = class {
      constructor(uid, socket, client) {
        this._buffer = Buffer.from([]);
        this._offset = 0;
        this._fence = 0;
        this._fenceCallback = void 0;
        this._socket = void 0;
        this._boundOnData = void 0;
        this._uid = void 0;
        this._client = void 0;
        this._uid = uid;
        this._socket = socket;
        this._client = client;
        this._boundOnData = this._onData.bind(this);
        socket.on("data", this._boundOnData);
        socket.on("close", () => this._onClose());
        socket.on("end", () => this._onClose());
        socket.on("error", () => this._onClose());
        this._run().catch(() => this._socket.end());
      }
      async _run() {
        (0, _utils.assert)(await this._authenticate());
        const {
          command,
          host,
          port
        } = await this._parseRequest();
        if (command !== SocksCommand.CONNECT) {
          this._writeBytes(Buffer.from([
            5,
            SocksReply.CommandNotSupported,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
          ]));
          return;
        }
        this._socket.off("data", this._boundOnData);
        this._client.onSocketRequested(this._uid, host, port);
      }
      async _authenticate() {
        const version = await this._readByte();
        (0, _utils.assert)(version === 5, "The VER field must be set to x05 for this version of the protocol, was " + version);
        const nMethods = await this._readByte();
        (0, _utils.assert)(nMethods, "No authentication methods specified");
        const methods = await this._readBytes(nMethods);
        for (const method of methods) {
          if (method === 0) {
            this._writeBytes(Buffer.from([version, method]));
            return true;
          }
        }
        this._writeBytes(Buffer.from([version, SocksAuth.NO_ACCEPTABLE_METHODS]));
        return false;
      }
      async _parseRequest() {
        const version = await this._readByte();
        (0, _utils.assert)(version === 5, "The VER field must be set to x05 for this version of the protocol, was " + version);
        const command = await this._readByte();
        await this._readByte();
        const addressType = await this._readByte();
        let host = "";
        switch (addressType) {
          case SocksAddressType.IPv4:
            host = (await this._readBytes(4)).join(".");
            break;
          case SocksAddressType.FqName:
            const length = await this._readByte();
            host = (await this._readBytes(length)).toString();
            break;
          case SocksAddressType.IPv6:
            const bytes = await this._readBytes(16);
            const tokens = [];
            for (let i = 0; i < 8; ++i)
              tokens.push(bytes.readUInt16BE(i * 2));
            host = tokens.join(":");
            break;
        }
        const port = (await this._readBytes(2)).readUInt16BE(0);
        this._buffer = Buffer.from([]);
        this._offset = 0;
        this._fence = 0;
        return {
          command,
          host,
          port
        };
      }
      async _readByte() {
        const buffer = await this._readBytes(1);
        return buffer[0];
      }
      async _readBytes(length) {
        this._fence = this._offset + length;
        if (!this._buffer || this._buffer.length < this._fence)
          await new Promise((f) => this._fenceCallback = f);
        this._offset += length;
        return this._buffer.slice(this._offset - length, this._offset);
      }
      _writeBytes(buffer) {
        if (this._socket.writable)
          this._socket.write(buffer);
      }
      _onClose() {
        this._client.onSocketClosed(this._uid);
      }
      _onData(buffer) {
        this._buffer = Buffer.concat([this._buffer, buffer]);
        if (this._fenceCallback && this._buffer.length >= this._fence) {
          const callback = this._fenceCallback;
          this._fenceCallback = void 0;
          callback();
        }
      }
      socketConnected(host, port) {
        this._writeBytes(Buffer.from([
          5,
          SocksReply.Succeeded,
          0,
          1,
          ...parseIP(host),
          port << 8,
          port & 255
        ]));
        this._socket.on("data", (data) => this._client.onSocketData(this._uid, data));
      }
      socketFailed(errorCode) {
        const buffer = Buffer.from([
          5,
          0,
          0,
          1,
          ...parseIP("0.0.0.0"),
          0,
          0
        ]);
        switch (errorCode) {
          case "ENOENT":
          case "ENOTFOUND":
          case "ETIMEDOUT":
          case "EHOSTUNREACH":
            buffer[1] = SocksReply.HostUnreachable;
            break;
          case "ENETUNREACH":
            buffer[1] = SocksReply.NetworkUnreachable;
            break;
          case "ECONNREFUSED":
            buffer[1] = SocksReply.ConnectionRefused;
            break;
        }
        this._writeBytes(buffer);
        this._socket.end();
      }
      sendData(data) {
        this._socket.write(data);
      }
      end() {
        this._socket.end();
      }
      error(error2) {
        this._socket.destroy(new Error(error2));
      }
    };
    exports.SocksConnection = SocksConnection;
    function parseIP(address) {
      if (!_net.default.isIPv4(address))
        throw new Error("IPv6 is not supported");
      return address.split(".", 4).map((t) => +t);
    }
  }
});

// node_modules/playwright-core/lib/dispatchers/jsHandleDispatcher.js
var require_jsHandleDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/jsHandleDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseArgument = parseArgument;
    exports.parseValue = parseValue;
    exports.serializeResult = serializeResult;
    exports.JSHandleDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _serializers = require_serializers();
    var JSHandleDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, jsHandle) {
        super(scope, jsHandle, jsHandle.asElement() ? "ElementHandle" : "JSHandle", {
          preview: jsHandle.toString()
        });
        jsHandle._setPreviewCallback((preview) => this._dispatchEvent("previewUpdated", {
          preview
        }));
      }
      async evaluateExpression(params) {
        return {
          value: serializeResult(await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true, parseArgument(params.arg)))
        };
      }
      async evaluateExpressionHandle(params) {
        const jsHandle = await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false, parseArgument(params.arg));
        return {
          handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)
        };
      }
      async getProperty(params) {
        const jsHandle = await this._object.getProperty(params.name);
        return {
          handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)
        };
      }
      async getPropertyList() {
        const map = await this._object.getProperties();
        const properties = [];
        for (const [name, value] of map)
          properties.push({
            name,
            value: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, value)
          });
        return {
          properties
        };
      }
      async jsonValue() {
        return {
          value: serializeResult(await this._object.jsonValue())
        };
      }
      async dispose() {
        await this._object.dispose();
      }
    };
    exports.JSHandleDispatcher = JSHandleDispatcher;
    function parseArgument(arg) {
      return (0, _serializers.parseSerializedValue)(arg.value, arg.handles.map((a) => a._object));
    }
    function parseValue(v) {
      return (0, _serializers.parseSerializedValue)(v, []);
    }
    function serializeResult(arg) {
      return (0, _serializers.serializeValue)(arg, (value) => ({
        fallThrough: value
      }), new Set());
    }
  }
});

// node_modules/playwright-core/lib/dispatchers/elementHandlerDispatcher.js
var require_elementHandlerDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/elementHandlerDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElementHandleDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var ElementHandleDispatcher = class extends _jsHandleDispatcher.JSHandleDispatcher {
      static from(scope, handle) {
        return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromNullable(scope, handle) {
        if (!handle)
          return void 0;
        return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromJSHandle(scope, handle) {
        const result = (0, _dispatcher.existingDispatcher)(handle);
        if (result)
          return result;
        return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new _jsHandleDispatcher.JSHandleDispatcher(scope, handle);
      }
      constructor(scope, elementHandle) {
        super(scope, elementHandle);
        this._elementHandle = void 0;
        this._elementHandle = elementHandle;
      }
      async ownerFrame(params, metadata) {
        return {
          frame: (0, _dispatcher.lookupNullableDispatcher)(await this._elementHandle.ownerFrame())
        };
      }
      async contentFrame(params, metadata) {
        return {
          frame: (0, _dispatcher.lookupNullableDispatcher)(await this._elementHandle.contentFrame())
        };
      }
      async getAttribute(params, metadata) {
        const value = await this._elementHandle.getAttribute(params.name);
        return {
          value: value === null ? void 0 : value
        };
      }
      async inputValue(params, metadata) {
        const value = await this._elementHandle.inputValue();
        return {
          value
        };
      }
      async textContent(params, metadata) {
        const value = await this._elementHandle.textContent();
        return {
          value: value === null ? void 0 : value
        };
      }
      async innerText(params, metadata) {
        return {
          value: await this._elementHandle.innerText()
        };
      }
      async innerHTML(params, metadata) {
        return {
          value: await this._elementHandle.innerHTML()
        };
      }
      async isChecked(params, metadata) {
        return {
          value: await this._elementHandle.isChecked()
        };
      }
      async isDisabled(params, metadata) {
        return {
          value: await this._elementHandle.isDisabled()
        };
      }
      async isEditable(params, metadata) {
        return {
          value: await this._elementHandle.isEditable()
        };
      }
      async isEnabled(params, metadata) {
        return {
          value: await this._elementHandle.isEnabled()
        };
      }
      async isHidden(params, metadata) {
        return {
          value: await this._elementHandle.isHidden()
        };
      }
      async isVisible(params, metadata) {
        return {
          value: await this._elementHandle.isVisible()
        };
      }
      async dispatchEvent(params, metadata) {
        await this._elementHandle.dispatchEvent(params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit));
      }
      async scrollIntoViewIfNeeded(params, metadata) {
        await this._elementHandle.scrollIntoViewIfNeeded(metadata, params);
      }
      async hover(params, metadata) {
        return await this._elementHandle.hover(metadata, params);
      }
      async click(params, metadata) {
        return await this._elementHandle.click(metadata, params);
      }
      async dblclick(params, metadata) {
        return await this._elementHandle.dblclick(metadata, params);
      }
      async tap(params, metadata) {
        return await this._elementHandle.tap(metadata, params);
      }
      async selectOption(params, metadata) {
        const elements = (params.elements || []).map((e) => e._elementHandle);
        return {
          values: await this._elementHandle.selectOption(metadata, elements, params.options || [], params)
        };
      }
      async fill(params, metadata) {
        return await this._elementHandle.fill(metadata, params.value, params);
      }
      async selectText(params, metadata) {
        await this._elementHandle.selectText(metadata, params);
      }
      async setInputFiles(params, metadata) {
        return await this._elementHandle.setInputFiles(metadata, params.files, params);
      }
      async focus(params, metadata) {
        await this._elementHandle.focus(metadata);
      }
      async type(params, metadata) {
        return await this._elementHandle.type(metadata, params.text, params);
      }
      async press(params, metadata) {
        return await this._elementHandle.press(metadata, params.key, params);
      }
      async check(params, metadata) {
        return await this._elementHandle.check(metadata, params);
      }
      async uncheck(params, metadata) {
        return await this._elementHandle.uncheck(metadata, params);
      }
      async boundingBox(params, metadata) {
        const value = await this._elementHandle.boundingBox();
        return {
          value: value || void 0
        };
      }
      async screenshot(params, metadata) {
        return {
          binary: (await this._elementHandle.screenshot(metadata, params)).toString("base64")
        };
      }
      async querySelector(params, metadata) {
        const handle = await this._elementHandle.querySelector(params.selector, params);
        return {
          element: ElementHandleDispatcher.fromNullable(this._scope, handle)
        };
      }
      async querySelectorAll(params, metadata) {
        const elements = await this._elementHandle.querySelectorAll(params.selector);
        return {
          elements: elements.map((e) => ElementHandleDispatcher.from(this._scope, e))
        };
      }
      async evalOnSelector(params, metadata) {
        return {
          value: (0, _jsHandleDispatcher.serializeResult)(await this._elementHandle.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
        };
      }
      async evalOnSelectorAll(params, metadata) {
        return {
          value: (0, _jsHandleDispatcher.serializeResult)(await this._elementHandle.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
        };
      }
      async waitForElementState(params, metadata) {
        await this._elementHandle.waitForElementState(metadata, params.state, params);
      }
      async waitForSelector(params, metadata) {
        return {
          element: ElementHandleDispatcher.fromNullable(this._scope, await this._elementHandle.waitForSelector(metadata, params.selector, params))
        };
      }
    };
    exports.ElementHandleDispatcher = ElementHandleDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/consoleMessageDispatcher.js
var require_consoleMessageDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/consoleMessageDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ConsoleMessageDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var ConsoleMessageDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, message) {
        super(scope, message, "ConsoleMessage", {
          type: message.type(),
          text: message.text(),
          args: message.args().map((a) => _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, a)),
          location: message.location()
        });
      }
    };
    exports.ConsoleMessageDispatcher = ConsoleMessageDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/dialogDispatcher.js
var require_dialogDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/dialogDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DialogDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var DialogDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, dialog) {
        super(scope, dialog, "Dialog", {
          type: dialog.type(),
          message: dialog.message(),
          defaultValue: dialog.defaultValue()
        });
      }
      async accept(params) {
        await this._object.accept(params.promptText);
      }
      async dismiss() {
        await this._object.dismiss();
      }
    };
    exports.DialogDispatcher = DialogDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/networkDispatchers.js
var require_networkDispatchers = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/networkDispatchers.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.APIRequestContextDispatcher = exports.WebSocketDispatcher = exports.RouteDispatcher = exports.ResponseDispatcher = exports.RequestDispatcher = void 0;
    var _fetch = require_fetch();
    var _network = require_network();
    var _dispatcher = require_dispatcher();
    var _frameDispatcher = require_frameDispatcher();
    var RequestDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, request) {
        const result = (0, _dispatcher.existingDispatcher)(request);
        return result || new RequestDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? RequestDispatcher.from(scope, request) : void 0;
      }
      constructor(scope, request) {
        const postData = request.postDataBuffer();
        super(scope, request, "Request", {
          frame: _frameDispatcher.FrameDispatcher.from(scope, request.frame()),
          url: request.url(),
          resourceType: request.resourceType(),
          method: request.method(),
          postData: postData === null ? void 0 : postData.toString("base64"),
          headers: request.headers(),
          isNavigationRequest: request.isNavigationRequest(),
          redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom())
        });
      }
      async rawRequestHeaders(params) {
        return {
          headers: await this._object.rawRequestHeaders()
        };
      }
      async response() {
        return {
          response: (0, _dispatcher.lookupNullableDispatcher)(await this._object.response())
        };
      }
    };
    exports.RequestDispatcher = RequestDispatcher;
    var ResponseDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, response) {
        const result = (0, _dispatcher.existingDispatcher)(response);
        return result || new ResponseDispatcher(scope, response);
      }
      static fromNullable(scope, response) {
        return response ? ResponseDispatcher.from(scope, response) : void 0;
      }
      constructor(scope, response) {
        super(scope, response, "Response", {
          request: RequestDispatcher.from(scope, response.request()),
          url: response.url(),
          status: response.status(),
          statusText: response.statusText(),
          headers: response.headers(),
          timing: response.timing()
        });
      }
      async body() {
        return {
          binary: (await this._object.body()).toString("base64")
        };
      }
      async securityDetails() {
        return {
          value: await this._object.securityDetails() || void 0
        };
      }
      async serverAddr() {
        return {
          value: await this._object.serverAddr() || void 0
        };
      }
      async rawResponseHeaders(params) {
        return {
          headers: await this._object.rawResponseHeaders()
        };
      }
      async sizes(params) {
        return {
          sizes: await this._object.sizes()
        };
      }
    };
    exports.ResponseDispatcher = ResponseDispatcher;
    var RouteDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, route) {
        const result = (0, _dispatcher.existingDispatcher)(route);
        return result || new RouteDispatcher(scope, route);
      }
      constructor(scope, route) {
        super(scope, route, "Route", {
          request: RequestDispatcher.from(scope, route.request())
        });
      }
      async continue(params, metadata) {
        await this._object.continue({
          url: params.url,
          method: params.method,
          headers: params.headers,
          postData: params.postData ? Buffer.from(params.postData, "base64") : void 0
        });
      }
      async fulfill(params) {
        await this._object.fulfill(params);
      }
      async abort(params) {
        await this._object.abort(params.errorCode || "failed");
      }
    };
    exports.RouteDispatcher = RouteDispatcher;
    var WebSocketDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, webSocket) {
        super(scope, webSocket, "WebSocket", {
          url: webSocket.url()
        });
        webSocket.on(_network.WebSocket.Events.FrameSent, (event) => this._dispatchEvent("frameSent", event));
        webSocket.on(_network.WebSocket.Events.FrameReceived, (event) => this._dispatchEvent("frameReceived", event));
        webSocket.on(_network.WebSocket.Events.SocketError, (error2) => this._dispatchEvent("socketError", {
          error: error2
        }));
        webSocket.on(_network.WebSocket.Events.Close, () => this._dispatchEvent("close", {}));
      }
    };
    exports.WebSocketDispatcher = WebSocketDispatcher;
    var APIRequestContextDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, request) {
        const result = (0, _dispatcher.existingDispatcher)(request);
        return result || new APIRequestContextDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? APIRequestContextDispatcher.from(scope, request) : void 0;
      }
      constructor(scope, request) {
        super(scope, request, "APIRequestContext", {}, true);
        request.once(_fetch.APIRequestContext.Events.Dispose, () => {
          if (!this._disposed)
            super._dispose();
        });
      }
      async storageState(params) {
        return this._object.storageState();
      }
      async dispose(params) {
        this._object.dispose();
      }
      async fetch(params, metadata) {
        const {
          fetchResponse,
          error: error2
        } = await this._object.fetch(params);
        let response;
        if (fetchResponse) {
          response = {
            url: fetchResponse.url,
            status: fetchResponse.status,
            statusText: fetchResponse.statusText,
            headers: fetchResponse.headers,
            fetchUid: fetchResponse.fetchUid
          };
        }
        return {
          response,
          error: error2
        };
      }
      async fetchResponseBody(params, metadata) {
        const buffer = this._object.fetchResponses.get(params.fetchUid);
        return {
          binary: buffer ? buffer.toString("base64") : void 0
        };
      }
      async disposeAPIResponse(params, metadata) {
        this._object.fetchResponses.delete(params.fetchUid);
      }
    };
    exports.APIRequestContextDispatcher = APIRequestContextDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/frameDispatcher.js
var require_frameDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/frameDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FrameDispatcher = void 0;
    var _frames = require_frames();
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var FrameDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, frame) {
        const result = (0, _dispatcher.existingDispatcher)(frame);
        return result || new FrameDispatcher(scope, frame);
      }
      static fromNullable(scope, frame) {
        if (!frame)
          return;
        return FrameDispatcher.from(scope, frame);
      }
      constructor(scope, frame) {
        super(scope, frame, "Frame", {
          url: frame.url(),
          name: frame.name(),
          parentFrame: FrameDispatcher.fromNullable(scope, frame.parentFrame()),
          loadStates: Array.from(frame._subtreeLifecycleEvents)
        });
        this._frame = void 0;
        this._frame = frame;
        frame.on(_frames.Frame.Events.AddLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {
            add: lifecycleEvent
          });
        });
        frame.on(_frames.Frame.Events.RemoveLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {
            remove: lifecycleEvent
          });
        });
        frame.on(_frames.Frame.Events.Navigation, (event) => {
          const params = {
            url: event.url,
            name: event.name,
            error: event.error ? event.error.message : void 0
          };
          if (event.newDocument)
            params.newDocument = {
              request: _networkDispatchers.RequestDispatcher.fromNullable(this._scope, event.newDocument.request || null)
            };
          this._dispatchEvent("navigated", params);
        });
      }
      async goto(params, metadata) {
        return {
          response: (0, _dispatcher.lookupNullableDispatcher)(await this._frame.goto(metadata, params.url, params))
        };
      }
      async frameElement() {
        return {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, await this._frame.frameElement())
        };
      }
      async evaluateExpression(params, metadata) {
        return {
          value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), "main"))
        };
      }
      async evaluateExpressionHandle(params, metadata) {
        return {
          handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, await this._frame.evaluateExpressionHandleAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), "main"))
        };
      }
      async waitForSelector(params, metadata) {
        return {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this._scope, await this._frame.waitForSelector(metadata, params.selector, params))
        };
      }
      async dispatchEvent(params, metadata) {
        return this._frame.dispatchEvent(metadata, params.selector, params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit), params);
      }
      async evalOnSelector(params, metadata) {
        return {
          value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
        };
      }
      async evalOnSelectorAll(params, metadata) {
        return {
          value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
        };
      }
      async querySelector(params, metadata) {
        return {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this._scope, await this._frame.querySelector(params.selector, params))
        };
      }
      async querySelectorAll(params, metadata) {
        const elements = await this._frame.querySelectorAll(params.selector);
        return {
          elements: elements.map((e) => _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, e))
        };
      }
      async content() {
        return {
          value: await this._frame.content()
        };
      }
      async setContent(params, metadata) {
        return await this._frame.setContent(metadata, params.html, params);
      }
      async addScriptTag(params, metadata) {
        return {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, await this._frame.addScriptTag(params))
        };
      }
      async addStyleTag(params, metadata) {
        return {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, await this._frame.addStyleTag(params))
        };
      }
      async click(params, metadata) {
        return await this._frame.click(metadata, params.selector, params);
      }
      async dblclick(params, metadata) {
        return await this._frame.dblclick(metadata, params.selector, params);
      }
      async dragAndDrop(params, metadata) {
        return await this._frame.dragAndDrop(metadata, params.source, params.target, params);
      }
      async tap(params, metadata) {
        return await this._frame.tap(metadata, params.selector, params);
      }
      async fill(params, metadata) {
        return await this._frame.fill(metadata, params.selector, params.value, params);
      }
      async focus(params, metadata) {
        await this._frame.focus(metadata, params.selector, params);
      }
      async textContent(params, metadata) {
        const value = await this._frame.textContent(metadata, params.selector, params);
        return {
          value: value === null ? void 0 : value
        };
      }
      async innerText(params, metadata) {
        return {
          value: await this._frame.innerText(metadata, params.selector, params)
        };
      }
      async innerHTML(params, metadata) {
        return {
          value: await this._frame.innerHTML(metadata, params.selector, params)
        };
      }
      async getAttribute(params, metadata) {
        const value = await this._frame.getAttribute(metadata, params.selector, params.name, params);
        return {
          value: value === null ? void 0 : value
        };
      }
      async inputValue(params, metadata) {
        const value = await this._frame.inputValue(metadata, params.selector, params);
        return {
          value
        };
      }
      async isChecked(params, metadata) {
        return {
          value: await this._frame.isChecked(metadata, params.selector, params)
        };
      }
      async isDisabled(params, metadata) {
        return {
          value: await this._frame.isDisabled(metadata, params.selector, params)
        };
      }
      async isEditable(params, metadata) {
        return {
          value: await this._frame.isEditable(metadata, params.selector, params)
        };
      }
      async isEnabled(params, metadata) {
        return {
          value: await this._frame.isEnabled(metadata, params.selector, params)
        };
      }
      async isHidden(params, metadata) {
        return {
          value: await this._frame.isHidden(metadata, params.selector, params)
        };
      }
      async isVisible(params, metadata) {
        return {
          value: await this._frame.isVisible(metadata, params.selector, params)
        };
      }
      async hover(params, metadata) {
        return await this._frame.hover(metadata, params.selector, params);
      }
      async selectOption(params, metadata) {
        const elements = (params.elements || []).map((e) => e._elementHandle);
        return {
          values: await this._frame.selectOption(metadata, params.selector, elements, params.options || [], params)
        };
      }
      async setInputFiles(params, metadata) {
        return await this._frame.setInputFiles(metadata, params.selector, params.files, params);
      }
      async type(params, metadata) {
        return await this._frame.type(metadata, params.selector, params.text, params);
      }
      async press(params, metadata) {
        return await this._frame.press(metadata, params.selector, params.key, params);
      }
      async check(params, metadata) {
        return await this._frame.check(metadata, params.selector, params);
      }
      async uncheck(params, metadata) {
        return await this._frame.uncheck(metadata, params.selector, params);
      }
      async waitForTimeout(params, metadata) {
        return await this._frame.waitForTimeout(metadata, params.timeout);
      }
      async waitForFunction(params, metadata) {
        return {
          handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, await this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), params))
        };
      }
      async title(params, metadata) {
        return {
          value: await this._frame.title()
        };
      }
      async expect(params, metadata) {
        const expectedValue = params.expectedValue ? (0, _jsHandleDispatcher.parseArgument)(params.expectedValue) : void 0;
        const result = await this._frame.expect(metadata, params.selector, __spreadProps(__spreadValues({}, params), {
          expectedValue
        }));
        if (result.received !== void 0)
          result.received = (0, _jsHandleDispatcher.serializeResult)(result.received);
        if (result.matches === params.isNot)
          metadata.error = {
            error: {
              name: "Expect",
              message: "Expect failed"
            }
          };
        return result;
      }
    };
    exports.FrameDispatcher = FrameDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/streamDispatcher.js
var require_streamDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/streamDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.StreamDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils = require_utils();
    var StreamDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, stream) {
        super(scope, {
          guid: "stream@" + (0, _utils.createGuid)(),
          stream
        }, "Stream", {});
        this._ended = false;
        stream.once("end", () => this._ended = true);
        stream.once("error", () => this._ended = true);
      }
      async read(params) {
        const stream = this._object.stream;
        if (this._ended)
          return {
            binary: ""
          };
        if (!stream.readableLength) {
          await new Promise((fulfill, reject) => {
            stream.once("readable", fulfill);
            stream.once("end", fulfill);
            stream.once("error", reject);
          });
        }
        const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
        return {
          binary: buffer ? buffer.toString("base64") : ""
        };
      }
      async close() {
        this._object.stream.destroy();
      }
    };
    exports.StreamDispatcher = StreamDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/artifactDispatcher.js
var require_artifactDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/artifactDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArtifactDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _streamDispatcher = require_streamDispatcher();
    var _fs = _interopRequireDefault(__require("fs"));
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ArtifactDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, artifact) {
        super(scope, artifact, "Artifact", {
          absolutePath: artifact.localPath()
        });
      }
      async pathAfterFinished() {
        const path = await this._object.localPathAfterFinished();
        return {
          value: path || void 0
        };
      }
      async saveAs(params) {
        return await new Promise((resolve3, reject) => {
          this._object.saveAs(async (localPath, error2) => {
            if (error2 !== void 0) {
              reject(new Error(error2));
              return;
            }
            try {
              await (0, _utils.mkdirIfNeeded)(params.path);
              await _fs.default.promises.copyFile(localPath, params.path);
              resolve3();
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async saveAsStream() {
        return await new Promise((resolve3, reject) => {
          this._object.saveAs(async (localPath, error2) => {
            if (error2 !== void 0) {
              reject(new Error(error2));
              return;
            }
            try {
              const readable = _fs.default.createReadStream(localPath);
              const stream = new _streamDispatcher.StreamDispatcher(this._scope, readable);
              resolve3({
                stream
              });
              await new Promise((resolve4) => {
                readable.on("close", resolve4);
                readable.on("end", resolve4);
                readable.on("error", resolve4);
              });
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async stream() {
        const fileName = await this._object.localPathAfterFinished();
        if (!fileName)
          return {};
        const readable = _fs.default.createReadStream(fileName);
        return {
          stream: new _streamDispatcher.StreamDispatcher(this._scope, readable)
        };
      }
      async failure() {
        const error2 = await this._object.failureError();
        return {
          error: error2 || void 0
        };
      }
      async cancel() {
        await this._object.cancel();
      }
      async delete() {
        await this._object.delete();
        this._dispose();
      }
    };
    exports.ArtifactDispatcher = ArtifactDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/pageDispatcher.js
var require_pageDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/pageDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BindingCallDispatcher = exports.WorkerDispatcher = exports.PageDispatcher = void 0;
    var _page = require_page();
    var _dispatcher = require_dispatcher();
    var _serializers = require_serializers();
    var _consoleMessageDispatcher = require_consoleMessageDispatcher();
    var _dialogDispatcher = require_dialogDispatcher();
    var _frameDispatcher = require_frameDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _artifactDispatcher = require_artifactDispatcher();
    var _utils = require_utils();
    var PageDispatcher = class extends _dispatcher.Dispatcher {
      static fromNullable(scope, page) {
        if (!page)
          return void 0;
        const result = (0, _dispatcher.existingDispatcher)(page);
        return result || new PageDispatcher(scope, page);
      }
      constructor(scope, page) {
        super(scope, page, "Page", {
          mainFrame: _frameDispatcher.FrameDispatcher.from(scope, page.mainFrame()),
          viewportSize: page.viewportSize() || void 0,
          isClosed: page.isClosed(),
          opener: PageDispatcher.fromNullable(scope, page.opener())
        }, true);
        this._page = void 0;
        this._page = page;
        page.on(_page.Page.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        page.on(_page.Page.Events.Console, (message) => this._dispatchEvent("console", {
          message: new _consoleMessageDispatcher.ConsoleMessageDispatcher(this._scope, message)
        }));
        page.on(_page.Page.Events.Crash, () => this._dispatchEvent("crash"));
        page.on(_page.Page.Events.DOMContentLoaded, () => this._dispatchEvent("domcontentloaded"));
        page.on(_page.Page.Events.Dialog, (dialog) => this._dispatchEvent("dialog", {
          dialog: new _dialogDispatcher.DialogDispatcher(this._scope, dialog)
        }));
        page.on(_page.Page.Events.Download, (download) => {
          this._dispatchEvent("download", {
            url: download.url,
            suggestedFilename: download.suggestedFilename(),
            artifact: new _artifactDispatcher.ArtifactDispatcher(scope, download.artifact)
          });
        });
        this._page.on(_page.Page.Events.FileChooser, (fileChooser) => this._dispatchEvent("fileChooser", {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, fileChooser.element()),
          isMultiple: fileChooser.isMultiple()
        }));
        page.on(_page.Page.Events.FrameAttached, (frame) => this._onFrameAttached(frame));
        page.on(_page.Page.Events.FrameDetached, (frame) => this._onFrameDetached(frame));
        page.on(_page.Page.Events.Load, () => this._dispatchEvent("load"));
        page.on(_page.Page.Events.PageError, (error2) => this._dispatchEvent("pageError", {
          error: (0, _serializers.serializeError)(error2)
        }));
        page.on(_page.Page.Events.WebSocket, (webSocket) => this._dispatchEvent("webSocket", {
          webSocket: new _networkDispatchers.WebSocketDispatcher(this._scope, webSocket)
        }));
        page.on(_page.Page.Events.Worker, (worker) => this._dispatchEvent("worker", {
          worker: new WorkerDispatcher(this._scope, worker)
        }));
        page.on(_page.Page.Events.Video, (artifact) => this._dispatchEvent("video", {
          artifact: (0, _dispatcher.existingDispatcher)(artifact)
        }));
        if (page._video)
          this._dispatchEvent("video", {
            artifact: (0, _dispatcher.existingDispatcher)(page._video)
          });
        const frames = page._frameManager.frames();
        for (let i = 1; i < frames.length; i++)
          this._onFrameAttached(frames[i]);
      }
      page() {
        return this._page;
      }
      async setDefaultNavigationTimeoutNoReply(params, metadata) {
        this._page.setDefaultNavigationTimeout(params.timeout);
      }
      async setDefaultTimeoutNoReply(params, metadata) {
        this._page.setDefaultTimeout(params.timeout);
      }
      async exposeBinding(params, metadata) {
        await this._page.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
          const binding = new BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
          this._dispatchEvent("bindingCall", {
            binding
          });
          return binding.promise();
        });
      }
      async setExtraHTTPHeaders(params, metadata) {
        await this._page.setExtraHTTPHeaders(params.headers);
      }
      async reload(params, metadata) {
        return {
          response: (0, _dispatcher.lookupNullableDispatcher)(await this._page.reload(metadata, params))
        };
      }
      async goBack(params, metadata) {
        return {
          response: (0, _dispatcher.lookupNullableDispatcher)(await this._page.goBack(metadata, params))
        };
      }
      async goForward(params, metadata) {
        return {
          response: (0, _dispatcher.lookupNullableDispatcher)(await this._page.goForward(metadata, params))
        };
      }
      async emulateMedia(params, metadata) {
        await this._page.emulateMedia({
          media: params.media === "null" ? null : params.media,
          colorScheme: params.colorScheme === "null" ? null : params.colorScheme,
          reducedMotion: params.reducedMotion === "null" ? null : params.reducedMotion,
          forcedColors: params.forcedColors === "null" ? null : params.forcedColors
        });
      }
      async setViewportSize(params, metadata) {
        await this._page.setViewportSize(params.viewportSize);
      }
      async addInitScript(params, metadata) {
        await this._page._addInitScriptExpression(params.source);
      }
      async setNetworkInterceptionEnabled(params, metadata) {
        if (!params.enabled) {
          await this._page._setClientRequestInterceptor(void 0);
          return;
        }
        await this._page._setClientRequestInterceptor((route, request) => {
          this._dispatchEvent("route", {
            route: _networkDispatchers.RouteDispatcher.from(this._scope, route),
            request: _networkDispatchers.RequestDispatcher.from(this._scope, request)
          });
        });
      }
      async screenshot(params, metadata) {
        return {
          binary: (await this._page.screenshot(metadata, params)).toString("base64")
        };
      }
      async close(params, metadata) {
        await this._page.close(metadata, params);
      }
      async setFileChooserInterceptedNoReply(params, metadata) {
        await this._page._setFileChooserIntercepted(params.intercepted);
      }
      async keyboardDown(params, metadata) {
        await this._page.keyboard.down(params.key);
      }
      async keyboardUp(params, metadata) {
        await this._page.keyboard.up(params.key);
      }
      async keyboardInsertText(params, metadata) {
        await this._page.keyboard.insertText(params.text);
      }
      async keyboardType(params, metadata) {
        await this._page.keyboard.type(params.text, params);
      }
      async keyboardPress(params, metadata) {
        await this._page.keyboard.press(params.key, params);
      }
      async mouseMove(params, metadata) {
        await this._page.mouse.move(params.x, params.y, params);
      }
      async mouseDown(params, metadata) {
        await this._page.mouse.down(params);
      }
      async mouseUp(params, metadata) {
        await this._page.mouse.up(params);
      }
      async mouseClick(params, metadata) {
        await this._page.mouse.click(params.x, params.y, params);
      }
      async mouseWheel(params, metadata) {
        await this._page.mouse.wheel(params.deltaX, params.deltaY);
      }
      async touchscreenTap(params, metadata) {
        await this._page.touchscreen.tap(params.x, params.y);
      }
      async accessibilitySnapshot(params, metadata) {
        const rootAXNode = await this._page.accessibility.snapshot({
          interestingOnly: params.interestingOnly,
          root: params.root ? params.root._elementHandle : void 0
        });
        return {
          rootAXNode: rootAXNode || void 0
        };
      }
      async pdf(params, metadata) {
        if (!this._page.pdf)
          throw new Error("PDF generation is only supported for Headless Chromium");
        const buffer = await this._page.pdf(params);
        return {
          pdf: buffer.toString("base64")
        };
      }
      async bringToFront(params, metadata) {
        await this._page.bringToFront();
      }
      async startJSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        await coverage.startJSCoverage(params);
      }
      async stopJSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        return {
          entries: await coverage.stopJSCoverage()
        };
      }
      async startCSSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        await coverage.startCSSCoverage(params);
      }
      async stopCSSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        return {
          entries: await coverage.stopCSSCoverage()
        };
      }
      _onFrameAttached(frame) {
        this._dispatchEvent("frameAttached", {
          frame: _frameDispatcher.FrameDispatcher.from(this._scope, frame)
        });
      }
      _onFrameDetached(frame) {
        this._dispatchEvent("frameDetached", {
          frame: (0, _dispatcher.lookupDispatcher)(frame)
        });
      }
    };
    exports.PageDispatcher = PageDispatcher;
    var WorkerDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, worker) {
        super(scope, worker, "Worker", {
          url: worker.url()
        });
        worker.on(_page.Worker.Events.Close, () => this._dispatchEvent("close"));
      }
      async evaluateExpression(params, metadata) {
        return {
          value: (0, _jsHandleDispatcher.serializeResult)(await this._object.evaluateExpression(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
        };
      }
      async evaluateExpressionHandle(params, metadata) {
        return {
          handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
        };
      }
    };
    exports.WorkerDispatcher = WorkerDispatcher;
    var BindingCallDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, name, needsHandle, source, args) {
        super(scope, {
          guid: "bindingCall@" + (0, _utils.createGuid)()
        }, "BindingCall", {
          frame: (0, _dispatcher.lookupDispatcher)(source.frame),
          name,
          args: needsHandle ? void 0 : args.map(_jsHandleDispatcher.serializeResult),
          handle: needsHandle ? _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, args[0]) : void 0
        });
        this._resolve = void 0;
        this._reject = void 0;
        this._promise = void 0;
        this._promise = new Promise((resolve3, reject) => {
          this._resolve = resolve3;
          this._reject = reject;
        });
      }
      promise() {
        return this._promise;
      }
      async resolve(params, metadata) {
        this._resolve((0, _jsHandleDispatcher.parseArgument)(params.result));
      }
      async reject(params, metadata) {
        this._reject((0, _serializers.parseError)(params.error));
      }
    };
    exports.BindingCallDispatcher = BindingCallDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/cdpSessionDispatcher.js
var require_cdpSessionDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/cdpSessionDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CDPSessionDispatcher = void 0;
    var _crConnection = require_crConnection();
    var _dispatcher = require_dispatcher();
    var CDPSessionDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, crSession) {
        super(scope, crSession, "CDPSession", {}, true);
        crSession._eventListener = (method, params) => {
          this._dispatchEvent("event", {
            method,
            params
          });
        };
        crSession.on(_crConnection.CRSessionEvents.Disconnected, () => this._dispose());
      }
      async send(params) {
        return {
          result: await this._object.send(params.method, params.params)
        };
      }
      async detach() {
        return this._object.detach();
      }
    };
    exports.CDPSessionDispatcher = CDPSessionDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/browserContextDispatcher.js
var require_browserContextDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/browserContextDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BrowserContextDispatcher = void 0;
    var _browserContext = require_browserContext();
    var _dispatcher = require_dispatcher();
    var _pageDispatcher = require_pageDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _crBrowser = require_crBrowser();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var _recorderSupplement = require_recorderSupplement();
    var _artifactDispatcher = require_artifactDispatcher();
    var BrowserContextDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, context) {
        super(scope, context, "BrowserContext", {
          isChromium: context._browser.options.isChromium,
          APIRequestContext: _networkDispatchers.APIRequestContextDispatcher.from(scope, context.fetchRequest)
        }, true);
        this._context = void 0;
        this._context = context;
        const onVideo = (artifact) => {
          const artifactDispatcher = new _artifactDispatcher.ArtifactDispatcher(scope, artifact);
          this._dispatchEvent("video", {
            artifact: artifactDispatcher
          });
        };
        context.on(_browserContext.BrowserContext.Events.VideoStarted, onVideo);
        for (const video of context._browser._idToVideo.values()) {
          if (video.context === context)
            onVideo(video.artifact);
        }
        for (const page of context.pages())
          this._dispatchEvent("page", {
            page: new _pageDispatcher.PageDispatcher(this._scope, page)
          });
        context.on(_browserContext.BrowserContext.Events.Page, (page) => this._dispatchEvent("page", {
          page: new _pageDispatcher.PageDispatcher(this._scope, page)
        }));
        context.on(_browserContext.BrowserContext.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        if (context._browser.options.name === "chromium") {
          for (const page of context.backgroundPages())
            this._dispatchEvent("backgroundPage", {
              page: new _pageDispatcher.PageDispatcher(this._scope, page)
            });
          context.on(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, (page) => this._dispatchEvent("backgroundPage", {
            page: new _pageDispatcher.PageDispatcher(this._scope, page)
          }));
          for (const serviceWorker of context.serviceWorkers())
            this._dispatchEvent("serviceWorker", {
              worker: new _pageDispatcher.WorkerDispatcher(this._scope, serviceWorker)
            });
          context.on(_crBrowser.CRBrowserContext.CREvents.ServiceWorker, (serviceWorker) => this._dispatchEvent("serviceWorker", {
            worker: new _pageDispatcher.WorkerDispatcher(this._scope, serviceWorker)
          }));
        }
        context.on(_browserContext.BrowserContext.Events.Request, (request) => {
          return this._dispatchEvent("request", {
            request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
            page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
          });
        });
        context.on(_browserContext.BrowserContext.Events.Response, (response) => this._dispatchEvent("response", {
          response: _networkDispatchers.ResponseDispatcher.from(this._scope, response),
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, response.frame()._page.initializedOrUndefined())
        }));
        context.on(_browserContext.BrowserContext.Events.RequestFailed, (request) => this._dispatchEvent("requestFailed", {
          request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
          failureText: request._failureText || void 0,
          responseEndTiming: request._responseEndTiming,
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
        }));
        context.on(_browserContext.BrowserContext.Events.RequestFinished, ({
          request,
          response
        }) => this._dispatchEvent("requestFinished", {
          request: _networkDispatchers.RequestDispatcher.from(scope, request),
          response: _networkDispatchers.ResponseDispatcher.fromNullable(scope, response),
          responseEndTiming: request._responseEndTiming,
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
        }));
      }
      async setDefaultNavigationTimeoutNoReply(params) {
        this._context.setDefaultNavigationTimeout(params.timeout);
      }
      async setDefaultTimeoutNoReply(params) {
        this._context.setDefaultTimeout(params.timeout);
      }
      async exposeBinding(params) {
        await this._context.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
          const binding = new _pageDispatcher.BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
          this._dispatchEvent("bindingCall", {
            binding
          });
          return binding.promise();
        });
      }
      async newPage(params, metadata) {
        return {
          page: (0, _dispatcher.lookupDispatcher)(await this._context.newPage(metadata))
        };
      }
      async cookies(params) {
        return {
          cookies: await this._context.cookies(params.urls)
        };
      }
      async addCookies(params) {
        await this._context.addCookies(params.cookies);
      }
      async clearCookies() {
        await this._context.clearCookies();
      }
      async grantPermissions(params) {
        await this._context.grantPermissions(params.permissions, params.origin);
      }
      async clearPermissions() {
        await this._context.clearPermissions();
      }
      async setGeolocation(params) {
        await this._context.setGeolocation(params.geolocation);
      }
      async setExtraHTTPHeaders(params) {
        await this._context.setExtraHTTPHeaders(params.headers);
      }
      async setOffline(params) {
        await this._context.setOffline(params.offline);
      }
      async setHTTPCredentials(params) {
        await this._context.setHTTPCredentials(params.httpCredentials);
      }
      async addInitScript(params) {
        await this._context._doAddInitScript(params.source);
      }
      async setNetworkInterceptionEnabled(params) {
        if (!params.enabled) {
          await this._context._setRequestInterceptor(void 0);
          return;
        }
        await this._context._setRequestInterceptor((route, request) => {
          this._dispatchEvent("route", {
            route: _networkDispatchers.RouteDispatcher.from(this._scope, route),
            request: _networkDispatchers.RequestDispatcher.from(this._scope, request)
          });
        });
      }
      async storageState(params, metadata) {
        return await this._context.storageState();
      }
      async close(params, metadata) {
        await this._context.close(metadata);
      }
      async recorderSupplementEnable(params) {
        await _recorderSupplement.RecorderSupplement.show(this._context, params);
      }
      async pause(params, metadata) {
      }
      async newCDPSession(params) {
        if (!this._object._browser.options.isChromium)
          throw new Error(`CDP session is only available in Chromium`);
        if (!params.page && !params.frame || params.page && params.frame)
          throw new Error(`CDP session must be initiated with either Page or Frame, not none or both`);
        const crBrowserContext = this._object;
        return {
          session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, await crBrowserContext.newCDPSession((params.page ? params.page : params.frame)._object))
        };
      }
      async tracingStart(params) {
        await this._context.tracing.start(params);
      }
      async tracingStartChunk(params) {
        await this._context.tracing.startChunk(params);
      }
      async tracingStopChunk(params) {
        const {
          artifact,
          entries
        } = await this._context.tracing.stopChunk(params.save, params.skipCompress);
        return {
          artifact: artifact ? new _artifactDispatcher.ArtifactDispatcher(this._scope, artifact) : void 0,
          entries
        };
      }
      async tracingStop(params) {
        await this._context.tracing.stop();
      }
      async harExport(params) {
        var _this$_context$_harRe;
        const artifact = await ((_this$_context$_harRe = this._context._harRecorder) === null || _this$_context$_harRe === void 0 ? void 0 : _this$_context$_harRe.export());
        if (!artifact)
          throw new Error("No HAR artifact. Ensure record.harPath is set.");
        return {
          artifact: new _artifactDispatcher.ArtifactDispatcher(this._scope, artifact)
        };
      }
    };
    exports.BrowserContextDispatcher = BrowserContextDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/androidDispatcher.js
var require_androidDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/androidDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AndroidSocketDispatcher = exports.AndroidDeviceDispatcher = exports.AndroidDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _android2 = require_android();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var AndroidDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, android) {
        super(scope, android, "Android", {}, true);
      }
      async devices(params) {
        const devices2 = await this._object.devices();
        return {
          devices: devices2.map((d) => AndroidDeviceDispatcher.from(this._scope, d))
        };
      }
      async setDefaultTimeoutNoReply(params) {
        this._object.setDefaultTimeout(params.timeout);
      }
    };
    exports.AndroidDispatcher = AndroidDispatcher;
    var AndroidDeviceDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, device) {
        const result = (0, _dispatcher.existingDispatcher)(device);
        return result || new AndroidDeviceDispatcher(scope, device);
      }
      constructor(scope, device) {
        super(scope, device, "AndroidDevice", {
          model: device.model,
          serial: device.serial
        }, true);
        for (const webView of device.webViews())
          this._dispatchEvent("webViewAdded", {
            webView
          });
        device.on(_android2.AndroidDevice.Events.WebViewAdded, (webView) => this._dispatchEvent("webViewAdded", {
          webView
        }));
        device.on(_android2.AndroidDevice.Events.WebViewRemoved, (pid) => this._dispatchEvent("webViewRemoved", {
          pid
        }));
      }
      async wait(params) {
        await this._object.send("wait", params);
      }
      async fill(params) {
        await this._object.send("click", {
          selector: params.selector
        });
        await this._object.send("fill", params);
      }
      async tap(params) {
        await this._object.send("click", params);
      }
      async drag(params) {
        await this._object.send("drag", params);
      }
      async fling(params) {
        await this._object.send("fling", params);
      }
      async longTap(params) {
        await this._object.send("longClick", params);
      }
      async pinchClose(params) {
        await this._object.send("pinchClose", params);
      }
      async pinchOpen(params) {
        await this._object.send("pinchOpen", params);
      }
      async scroll(params) {
        await this._object.send("scroll", params);
      }
      async swipe(params) {
        await this._object.send("swipe", params);
      }
      async info(params) {
        return {
          info: await this._object.send("info", params)
        };
      }
      async inputType(params) {
        const text = params.text;
        const keyCodes = [];
        for (let i = 0; i < text.length; ++i) {
          const code = keyMap.get(text[i].toUpperCase());
          if (code === void 0)
            throw new Error("No mapping for " + text[i] + " found");
          keyCodes.push(code);
        }
        await Promise.all(keyCodes.map((keyCode) => this._object.send("inputPress", {
          keyCode
        })));
      }
      async inputPress(params) {
        if (!keyMap.has(params.key))
          throw new Error("Unknown key: " + params.key);
        await this._object.send("inputPress", {
          keyCode: keyMap.get(params.key)
        });
      }
      async inputTap(params) {
        await this._object.send("inputClick", params);
      }
      async inputSwipe(params) {
        await this._object.send("inputSwipe", params);
      }
      async inputDrag(params) {
        await this._object.send("inputDrag", params);
      }
      async screenshot(params) {
        return {
          binary: (await this._object.screenshot()).toString("base64")
        };
      }
      async shell(params) {
        return {
          result: (await this._object.shell(params.command)).toString("base64")
        };
      }
      async open(params, metadata) {
        const socket = await this._object.open(params.command);
        return {
          socket: new AndroidSocketDispatcher(this._scope, socket)
        };
      }
      async installApk(params) {
        await this._object.installApk(Buffer.from(params.file, "base64"), {
          args: params.args
        });
      }
      async push(params) {
        await this._object.push(Buffer.from(params.file, "base64"), params.path, params.mode);
      }
      async launchBrowser(params) {
        const context = await this._object.launchBrowser(params.pkg, params);
        return {
          context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
        };
      }
      async close(params) {
        await this._object.close();
      }
      async setDefaultTimeoutNoReply(params) {
        this._object.setDefaultTimeout(params.timeout);
      }
      async connectToWebView(params) {
        return {
          context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, await this._object.connectToWebView(params.pid))
        };
      }
    };
    exports.AndroidDeviceDispatcher = AndroidDeviceDispatcher;
    var AndroidSocketDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, socket) {
        super(scope, socket, "AndroidSocket", {}, true);
        socket.on("data", (data) => this._dispatchEvent("data", {
          data: data.toString("base64")
        }));
        socket.on("close", () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      async write(params, metadata) {
        await this._object.write(Buffer.from(params.data, "base64"));
      }
      async close(params, metadata) {
        this._object.close();
      }
    };
    exports.AndroidSocketDispatcher = AndroidSocketDispatcher;
    var keyMap = new Map([["Unknown", 0], ["SoftLeft", 1], ["SoftRight", 2], ["Home", 3], ["Back", 4], ["Call", 5], ["EndCall", 6], ["0", 7], ["1", 8], ["2", 9], ["3", 10], ["4", 11], ["5", 12], ["6", 13], ["7", 14], ["8", 15], ["9", 16], ["Star", 17], ["*", 17], ["Pound", 18], ["#", 18], ["DialUp", 19], ["DialDown", 20], ["DialLeft", 21], ["DialRight", 22], ["DialCenter", 23], ["VolumeUp", 24], ["VolumeDown", 25], ["Power", 26], ["Camera", 27], ["Clear", 28], ["A", 29], ["B", 30], ["C", 31], ["D", 32], ["E", 33], ["F", 34], ["G", 35], ["H", 36], ["I", 37], ["J", 38], ["K", 39], ["L", 40], ["M", 41], ["N", 42], ["O", 43], ["P", 44], ["Q", 45], ["R", 46], ["S", 47], ["T", 48], ["U", 49], ["V", 50], ["W", 51], ["X", 52], ["Y", 53], ["Z", 54], ["Comma", 55], [",", 55], ["Period", 56], [".", 56], ["AltLeft", 57], ["AltRight", 58], ["ShiftLeft", 59], ["ShiftRight", 60], ["Tab", 61], ["	", 61], ["Space", 62], [" ", 62], ["Sym", 63], ["Explorer", 64], ["Envelop", 65], ["Enter", 66], ["Del", 67], ["Grave", 68], ["Minus", 69], ["-", 69], ["Equals", 70], ["=", 70], ["LeftBracket", 71], ["(", 71], ["RightBracket", 72], [")", 72], ["Backslash", 73], ["\\", 73], ["Semicolon", 74], [";", 74], ["Apostrophe", 75], ["`", 75], ["Slash", 76], ["/", 76], ["At", 77], ["@", 77], ["Num", 78], ["HeadsetHook", 79], ["Focus", 80], ["Plus", 81], ["Menu", 82], ["Notification", 83], ["Search", 84], ["AppSwitch", 187], ["Assist", 219], ["Cut", 277], ["Copy", 278], ["Paste", 279]]);
  }
});

// node_modules/playwright-core/lib/dispatchers/browserDispatcher.js
var require_browserDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/browserDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BrowserDispatcher = void 0;
    var _browser = require_browser2();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var _dispatcher = require_dispatcher();
    var BrowserDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browser) {
        super(scope, browser, "Browser", {
          version: browser.version(),
          name: browser.options.name
        }, true);
        browser.on(_browser.Browser.Events.Disconnected, () => this._didClose());
      }
      _didClose() {
        this._dispatchEvent("close");
        this._dispose();
      }
      async newContext(params, metadata) {
        const context = await this._object.newContext(params);
        if (params.storageState)
          await context.setStorageState(metadata, params.storageState);
        return {
          context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
        };
      }
      async close() {
        await this._object.close();
      }
      async killForTests() {
        await this._object.killForTests();
      }
      async newBrowserCDPSession() {
        if (!this._object.options.isChromium)
          throw new Error(`CDP session is only available in Chromium`);
        const crBrowser = this._object;
        return {
          session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, await crBrowser.newBrowserCDPSession())
        };
      }
      async startTracing(params) {
        if (!this._object.options.isChromium)
          throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        await crBrowser.startTracing(params.page ? params.page._object : void 0, params);
      }
      async stopTracing() {
        if (!this._object.options.isChromium)
          throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        const buffer = await crBrowser.stopTracing();
        return {
          binary: buffer.toString("base64")
        };
      }
    };
    exports.BrowserDispatcher = BrowserDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/jsonPipeDispatcher.js
var require_jsonPipeDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/jsonPipeDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JsonPipeDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils = require_utils();
    var _serializers = require_serializers();
    var JsonPipeDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope) {
        super(scope, {
          guid: "jsonPipe@" + (0, _utils.createGuid)()
        }, "JsonPipe", {});
      }
      async send(params) {
        this.emit("message", params.message);
      }
      async close() {
        this.emit("close");
        if (!this._disposed) {
          this._dispatchEvent("closed", {});
          this._dispose();
        }
      }
      dispatch(message) {
        if (!this._disposed)
          this._dispatchEvent("message", {
            message
          });
      }
      wasClosed(error2) {
        if (!this._disposed) {
          const params = error2 ? {
            error: (0, _serializers.serializeError)(error2)
          } : {};
          this._dispatchEvent("closed", params);
          this._dispose();
        }
      }
      dispose() {
        this._dispose();
      }
    };
    exports.JsonPipeDispatcher = JsonPipeDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/browserTypeDispatcher.js
var require_browserTypeDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/browserTypeDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BrowserTypeDispatcher = void 0;
    var _browserDispatcher = require_browserDispatcher();
    var _dispatcher = require_dispatcher();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _ws = _interopRequireDefault(require_ws());
    var _jsonPipeDispatcher = require_jsonPipeDispatcher();
    var _utils = require_utils();
    var _async = require_async();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var BrowserTypeDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browserType) {
        super(scope, browserType, "BrowserType", {
          executablePath: browserType.executablePath(),
          name: browserType.name()
        }, true);
      }
      async launch(params, metadata) {
        const browser = await this._object.launch(metadata, params);
        return {
          browser: new _browserDispatcher.BrowserDispatcher(this._scope, browser)
        };
      }
      async launchPersistentContext(params, metadata) {
        const browserContext = await this._object.launchPersistentContext(metadata, params.userDataDir, params);
        return {
          context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, browserContext)
        };
      }
      async connectOverCDP(params, metadata) {
        const browser = await this._object.connectOverCDP(metadata, params.endpointURL, params, params.timeout);
        const browserDispatcher = new _browserDispatcher.BrowserDispatcher(this._scope, browser);
        return {
          browser: browserDispatcher,
          defaultContext: browser._defaultContext ? new _browserContextDispatcher.BrowserContextDispatcher(browserDispatcher._scope, browser._defaultContext) : void 0
        };
      }
      async connect(params) {
        const waitForNextTask = params.slowMo ? (cb) => setTimeout(cb, params.slowMo) : (0, _utils.makeWaitForNextTask)();
        const paramsHeaders = Object.assign({
          "User-Agent": (0, _utils.getUserAgent)()
        }, params.headers || {});
        const ws = new _ws.default(params.wsEndpoint, [], {
          perMessageDeflate: false,
          maxPayload: 256 * 1024 * 1024,
          handshakeTimeout: params.timeout,
          headers: paramsHeaders
        });
        const pipe = new _jsonPipeDispatcher.JsonPipeDispatcher(this._scope);
        const openPromise = new _async.ManualPromise();
        ws.on("open", () => openPromise.resolve({
          pipe
        }));
        ws.on("close", () => pipe.wasClosed());
        ws.on("error", (error2) => {
          if (openPromise.isDone()) {
            pipe.wasClosed(error2);
          } else {
            pipe.dispose();
            openPromise.reject(error2);
          }
        });
        pipe.on("close", () => ws.close());
        pipe.on("message", (message) => ws.send(JSON.stringify(message)));
        ws.addEventListener("message", (event) => {
          waitForNextTask(() => {
            try {
              pipe.dispatch(JSON.parse(event.data));
            } catch (e) {
              ws.close();
            }
          });
        });
        return openPromise;
      }
    };
    exports.BrowserTypeDispatcher = BrowserTypeDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/electronDispatcher.js
var require_electronDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/electronDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElectronApplicationDispatcher = exports.ElectronDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _electron2 = require_electron2();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var ElectronDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, electron) {
        super(scope, electron, "Electron", {}, true);
      }
      async launch(params) {
        const electronApplication = await this._object.launch(params);
        return {
          electronApplication: new ElectronApplicationDispatcher(this._scope, electronApplication)
        };
      }
    };
    exports.ElectronDispatcher = ElectronDispatcher;
    var ElectronApplicationDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, electronApplication) {
        super(scope, electronApplication, "ElectronApplication", {
          context: new _browserContextDispatcher.BrowserContextDispatcher(scope, electronApplication.context())
        }, true);
        electronApplication.on(_electron2.ElectronApplication.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      async browserWindow(params) {
        const handle = await this._object.browserWindow(params.page.page());
        return {
          handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, handle)
        };
      }
      async evaluateExpression(params) {
        const handle = await this._object._nodeElectronHandlePromise;
        return {
          value: (0, _jsHandleDispatcher.serializeResult)(await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
        };
      }
      async evaluateExpressionHandle(params) {
        const handle = await this._object._nodeElectronHandlePromise;
        const result = await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false, (0, _jsHandleDispatcher.parseArgument)(params.arg));
        return {
          handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, result)
        };
      }
      async close() {
        await this._object.close();
      }
    };
    exports.ElectronApplicationDispatcher = ElectronApplicationDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/selectorsDispatcher.js
var require_selectorsDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/selectorsDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SelectorsDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var SelectorsDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, selectors2) {
        super(scope, selectors2, "Selectors", {});
      }
      async register(params) {
        await this._object.register(params.name, params.source, params.contentScript);
      }
    };
    exports.SelectorsDispatcher = SelectorsDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/playwrightDispatcher.js
var require_playwrightDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/playwrightDispatcher.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PlaywrightDispatcher = void 0;
    var _net = _interopRequireDefault(__require("net"));
    var _fetch = require_fetch();
    var _debugLogger = require_debugLogger();
    var _socksProxy = require_socksProxy();
    var _utils = require_utils();
    var _androidDispatcher = require_androidDispatcher();
    var _browserTypeDispatcher = require_browserTypeDispatcher();
    var _dispatcher = require_dispatcher();
    var _electronDispatcher = require_electronDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _selectorsDispatcher = require_selectorsDispatcher();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PlaywrightDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, playwright3, customSelectors, preLaunchedBrowser) {
        const descriptors = require_deviceDescriptors();
        const deviceDescriptors = Object.entries(descriptors).map(([name, descriptor]) => ({
          name,
          descriptor
        }));
        super(scope, playwright3, "Playwright", {
          chromium: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright3.chromium),
          firefox: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright3.firefox),
          webkit: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright3.webkit),
          android: new _androidDispatcher.AndroidDispatcher(scope, playwright3.android),
          electron: new _electronDispatcher.ElectronDispatcher(scope, playwright3.electron),
          deviceDescriptors,
          selectors: customSelectors || new _selectorsDispatcher.SelectorsDispatcher(scope, playwright3.selectors),
          preLaunchedBrowser
        }, false);
        this._socksProxy = void 0;
      }
      async enableSocksProxy() {
        this._socksProxy = new SocksProxy(this);
        this._object.options.socksProxyPort = await this._socksProxy.listen(0);
        _debugLogger.debugLogger.log("proxy", `Starting socks proxy server on port ${this._object.options.socksProxyPort}`);
      }
      async socksConnected(params) {
        var _this$_socksProxy;
        (_this$_socksProxy = this._socksProxy) === null || _this$_socksProxy === void 0 ? void 0 : _this$_socksProxy.socketConnected(params);
      }
      async socksFailed(params) {
        var _this$_socksProxy2;
        (_this$_socksProxy2 = this._socksProxy) === null || _this$_socksProxy2 === void 0 ? void 0 : _this$_socksProxy2.socketFailed(params);
      }
      async socksData(params) {
        var _this$_socksProxy3;
        (_this$_socksProxy3 = this._socksProxy) === null || _this$_socksProxy3 === void 0 ? void 0 : _this$_socksProxy3.sendSocketData(params);
      }
      async socksError(params) {
        var _this$_socksProxy4;
        (_this$_socksProxy4 = this._socksProxy) === null || _this$_socksProxy4 === void 0 ? void 0 : _this$_socksProxy4.sendSocketError(params);
      }
      async socksEnd(params) {
        var _this$_socksProxy5;
        (_this$_socksProxy5 = this._socksProxy) === null || _this$_socksProxy5 === void 0 ? void 0 : _this$_socksProxy5.sendSocketEnd(params);
      }
      async newRequest(params, metadata) {
        const request = new _fetch.GlobalAPIRequestContext(this._object, params);
        return {
          request: _networkDispatchers.APIRequestContextDispatcher.from(this._scope, request)
        };
      }
    };
    exports.PlaywrightDispatcher = PlaywrightDispatcher;
    var SocksProxy = class {
      constructor(dispatcher) {
        this._server = void 0;
        this._connections = new Map();
        this._dispatcher = void 0;
        this._dispatcher = dispatcher;
        this._server = new _net.default.Server((socket) => {
          const uid = (0, _utils.createGuid)();
          const connection = new _socksProxy.SocksConnection(uid, socket, this);
          this._connections.set(uid, connection);
        });
      }
      async listen(port) {
        return new Promise((f) => {
          this._server.listen(port, () => {
            f(this._server.address().port);
          });
        });
      }
      onSocketRequested(uid, host, port) {
        this._dispatcher._dispatchEvent("socksRequested", {
          uid,
          host,
          port
        });
      }
      onSocketData(uid, data) {
        this._dispatcher._dispatchEvent("socksData", {
          uid,
          data: data.toString("base64")
        });
      }
      onSocketClosed(uid) {
        this._dispatcher._dispatchEvent("socksClosed", {
          uid
        });
      }
      socketConnected(params) {
        var _this$_connections$ge;
        (_this$_connections$ge = this._connections.get(params.uid)) === null || _this$_connections$ge === void 0 ? void 0 : _this$_connections$ge.socketConnected(params.host, params.port);
      }
      socketFailed(params) {
        var _this$_connections$ge2;
        (_this$_connections$ge2 = this._connections.get(params.uid)) === null || _this$_connections$ge2 === void 0 ? void 0 : _this$_connections$ge2.socketFailed(params.errorCode);
      }
      sendSocketData(params) {
        var _this$_connections$ge3;
        (_this$_connections$ge3 = this._connections.get(params.uid)) === null || _this$_connections$ge3 === void 0 ? void 0 : _this$_connections$ge3.sendData(Buffer.from(params.data, "base64"));
      }
      sendSocketEnd(params) {
        var _this$_connections$ge4;
        (_this$_connections$ge4 = this._connections.get(params.uid)) === null || _this$_connections$ge4 === void 0 ? void 0 : _this$_connections$ge4.end();
      }
      sendSocketError(params) {
        var _this$_connections$ge5;
        (_this$_connections$ge5 = this._connections.get(params.uid)) === null || _this$_connections$ge5 === void 0 ? void 0 : _this$_connections$ge5.error(params.error);
      }
    };
  }
});

// node_modules/playwright-core/lib/client/events.js
var require_events = __commonJS({
  "node_modules/playwright-core/lib/client/events.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Events = void 0;
    var Events = {
      AndroidDevice: {
        WebView: "webview",
        Close: "close"
      },
      AndroidSocket: {
        Data: "data",
        Close: "close"
      },
      AndroidWebView: {
        Close: "close"
      },
      Browser: {
        Disconnected: "disconnected"
      },
      BrowserContext: {
        Close: "close",
        Page: "page",
        BackgroundPage: "backgroundpage",
        ServiceWorker: "serviceworker",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished"
      },
      BrowserServer: {
        Close: "close"
      },
      Page: {
        Close: "close",
        Crash: "crash",
        Console: "console",
        Dialog: "dialog",
        Download: "download",
        FileChooser: "filechooser",
        DOMContentLoaded: "domcontentloaded",
        PageError: "pageerror",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished",
        FrameAttached: "frameattached",
        FrameDetached: "framedetached",
        FrameNavigated: "framenavigated",
        Load: "load",
        Popup: "popup",
        WebSocket: "websocket",
        Worker: "worker"
      },
      WebSocket: {
        Close: "close",
        Error: "socketerror",
        FrameReceived: "framereceived",
        FrameSent: "framesent"
      },
      Worker: {
        Close: "close"
      },
      ElectronApplication: {
        Close: "close",
        Window: "window"
      }
    };
    exports.Events = Events;
  }
});

// node_modules/playwright-core/lib/client/accessibility.js
var require_accessibility2 = __commonJS({
  "node_modules/playwright-core/lib/client/accessibility.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Accessibility = void 0;
    function axNodeFromProtocol(axNode) {
      const result = __spreadProps(__spreadValues({}, axNode), {
        value: axNode.valueNumber !== void 0 ? axNode.valueNumber : axNode.valueString,
        checked: axNode.checked === "checked" ? true : axNode.checked === "unchecked" ? false : axNode.checked,
        pressed: axNode.pressed === "pressed" ? true : axNode.pressed === "released" ? false : axNode.pressed,
        children: axNode.children ? axNode.children.map(axNodeFromProtocol) : void 0
      });
      delete result.valueNumber;
      delete result.valueString;
      return result;
    }
    var Accessibility = class {
      constructor(channel) {
        this._channel = void 0;
        this._channel = channel;
      }
      async snapshot(options2 = {}) {
        const root = options2.root ? options2.root._elementChannel : void 0;
        const result = await this._channel.accessibilitySnapshot({
          interestingOnly: options2.interestingOnly,
          root
        });
        return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
      }
    };
    exports.Accessibility = Accessibility;
  }
});

// node_modules/playwright-core/lib/client/channelOwner.js
var require_channelOwner = __commonJS({
  "node_modules/playwright-core/lib/client/channelOwner.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.renderCallWithParams = renderCallWithParams;
    exports.ChannelOwner = void 0;
    var _events = __require("events");
    var _validator = require_validator();
    var _debugLogger = require_debugLogger();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var ChannelOwner = class extends _events.EventEmitter {
      constructor(parent, type, guid, initializer, instrumentation) {
        var _this$_parent;
        super();
        this._connection = void 0;
        this._parent = void 0;
        this._objects = new Map();
        this._type = void 0;
        this._guid = void 0;
        this._channel = void 0;
        this._initializer = void 0;
        this._logger = void 0;
        this._instrumentation = void 0;
        this.setMaxListeners(0);
        this._connection = parent instanceof ChannelOwner ? parent._connection : parent;
        this._type = type;
        this._guid = guid;
        this._parent = parent instanceof ChannelOwner ? parent : void 0;
        this._instrumentation = instrumentation || ((_this$_parent = this._parent) === null || _this$_parent === void 0 ? void 0 : _this$_parent._instrumentation);
        this._connection._objects.set(guid, this);
        if (this._parent) {
          this._parent._objects.set(guid, this);
          this._logger = this._parent._logger;
        }
        this._channel = this._createChannel(new _events.EventEmitter(), null);
        this._initializer = initializer;
      }
      _dispose() {
        if (this._parent)
          this._parent._objects.delete(this._guid);
        this._connection._objects.delete(this._guid);
        for (const object of [...this._objects.values()])
          object._dispose();
        this._objects.clear();
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._objects.values()).map((o) => o._debugScopeState())
        };
      }
      _createChannel(base2, stackTrace, csi, callCookie) {
        const channel = new Proxy(base2, {
          get: (obj, prop) => {
            if (prop === "debugScopeState")
              return (params) => this._connection.sendMessageToServer(this, prop, params, stackTrace);
            if (typeof prop === "string") {
              const validator = scheme2[paramsName(this._type, prop)];
              if (validator) {
                return (params) => {
                  if (callCookie && csi) {
                    csi.onApiCallBegin(renderCallWithParams(stackTrace.apiName, params), stackTrace, callCookie);
                    csi = void 0;
                  }
                  return this._connection.sendMessageToServer(this, prop, validator(params, ""), stackTrace);
                };
              }
            }
            return obj[prop];
          }
        });
        channel._object = this;
        return channel;
      }
      async _wrapApiCall(func, logger, isInternal) {
        logger = logger || this._logger;
        const stackTrace = (0, _stackTrace.captureStackTrace)();
        const {
          apiName,
          frameTexts
        } = stackTrace;
        isInternal = isInternal || stackTrace.allFrames.filter((f) => {
          var _f$function;
          return (_f$function = f.function) === null || _f$function === void 0 ? void 0 : _f$function.includes("_wrapApiCall");
        }).length > 1;
        if (isInternal)
          delete stackTrace.apiName;
        const csi = isInternal ? void 0 : this._instrumentation;
        const callCookie = {};
        try {
          logApiCall(logger, `=> ${apiName} started`, isInternal);
          const channel = this._createChannel({}, stackTrace, csi, callCookie);
          const result = await func(channel, stackTrace);
          csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie);
          logApiCall(logger, `<= ${apiName} succeeded`, isInternal);
          return result;
        } catch (e) {
          const innerError = (process.env.PWDEBUGIMPL || (0, _utils.isUnderTest)()) && e.stack ? "\n<inner error>\n" + e.stack : "";
          e.message = apiName + ": " + e.message;
          e.stack = e.message + "\n" + frameTexts.join("\n") + innerError;
          csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie, e);
          logApiCall(logger, `<= ${apiName} failed`, isInternal);
          throw e;
        }
      }
      toJSON() {
        return {
          _type: this._type,
          _guid: this._guid
        };
      }
    };
    exports.ChannelOwner = ChannelOwner;
    function logApiCall(logger, message, isNested) {
      if (isNested)
        return;
      if (logger && logger.isEnabled("api", "info"))
        logger.log("api", "info", message, [], {
          color: "cyan"
        });
      _debugLogger.debugLogger.log("api", message);
    }
    function paramsName(type, method) {
      return type + method[0].toUpperCase() + method.substring(1) + "Params";
    }
    var paramsToRender = ["url", "selector", "text", "key"];
    function renderCallWithParams(apiName, params) {
      const paramsArray = [];
      if (params) {
        for (const name of paramsToRender) {
          if (params[name])
            paramsArray.push(params[name]);
        }
      }
      const paramsText = paramsArray.length ? "(" + paramsArray.join(", ") + ")" : "";
      return apiName + paramsText;
    }
    var tChannel = (name) => {
      return (arg, path) => {
        if (arg._object instanceof ChannelOwner && (name === "*" || arg._object._type === name))
          return {
            guid: arg._object._guid
          };
        throw new _validator.ValidationError(`${path}: expected ${name}`);
      };
    };
    var scheme2 = (0, _validator.createScheme)(tChannel);
  }
});

// node_modules/playwright-core/lib/client/jsHandle.js
var require_jsHandle = __commonJS({
  "node_modules/playwright-core/lib/client/jsHandle.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.serializeArgument = serializeArgument;
    exports.parseResult = parseResult;
    exports.assertMaxArguments = assertMaxArguments;
    exports.JSHandle = void 0;
    var _channelOwner = require_channelOwner();
    var _serializers = require_serializers();
    var JSHandle = class extends _channelOwner.ChannelOwner {
      static from(handle) {
        return handle._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._preview = void 0;
        this._preview = this._initializer.preview;
        this._channel.on("previewUpdated", ({
          preview
        }) => this._preview = preview);
      }
      async evaluate(pageFunction, arg) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: serializeArgument(arg)
          });
          return parseResult(result.value);
        });
      }
      async evaluateHandle(pageFunction, arg) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: serializeArgument(arg)
          });
          return JSHandle.from(result.handle);
        });
      }
      async getProperty(propertyName) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.getProperty({
            name: propertyName
          });
          return JSHandle.from(result.handle);
        });
      }
      async getProperties() {
        return this._wrapApiCall(async (channel) => {
          const map = new Map();
          for (const {
            name,
            value
          } of (await channel.getPropertyList()).properties)
            map.set(name, JSHandle.from(value));
          return map;
        });
      }
      async jsonValue() {
        return this._wrapApiCall(async (channel) => {
          return parseResult((await channel.jsonValue()).value);
        });
      }
      asElement() {
        return null;
      }
      async dispose() {
        return this._wrapApiCall(async (channel) => {
          return await channel.dispose();
        });
      }
      toString() {
        return this._preview;
      }
    };
    exports.JSHandle = JSHandle;
    function serializeArgument(arg) {
      const handles = [];
      const pushHandle = (channel) => {
        handles.push(channel);
        return handles.length - 1;
      };
      const value = (0, _serializers.serializeValue)(arg, (value2) => {
        if (value2 instanceof JSHandle)
          return {
            h: pushHandle(value2._channel)
          };
        return {
          fallThrough: value2
        };
      }, new Set());
      return {
        value,
        handles
      };
    }
    function parseResult(value) {
      return (0, _serializers.parseSerializedValue)(value, void 0);
    }
    function assertMaxArguments(count, max) {
      if (count > max)
        throw new Error("Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.");
    }
  }
});

// node_modules/playwright-core/lib/client/consoleMessage.js
var require_consoleMessage = __commonJS({
  "node_modules/playwright-core/lib/client/consoleMessage.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ConsoleMessage = void 0;
    var util = _interopRequireWildcard(__require("util"));
    var _jsHandle = require_jsHandle();
    var _channelOwner = require_channelOwner();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var ConsoleMessage = class extends _channelOwner.ChannelOwner {
      static from(message) {
        return message._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      type() {
        return this._initializer.type;
      }
      text() {
        return this._initializer.text;
      }
      args() {
        return this._initializer.args.map(_jsHandle.JSHandle.from);
      }
      location() {
        return this._initializer.location;
      }
      [util.inspect.custom]() {
        return this.text();
      }
    };
    exports.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright-core/lib/client/dialog.js
var require_dialog2 = __commonJS({
  "node_modules/playwright-core/lib/client/dialog.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Dialog = void 0;
    var _channelOwner = require_channelOwner();
    var Dialog = class extends _channelOwner.ChannelOwner {
      static from(dialog) {
        return dialog._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      type() {
        return this._initializer.type;
      }
      message() {
        return this._initializer.message;
      }
      defaultValue() {
        return this._initializer.defaultValue;
      }
      async accept(promptText) {
        return this._wrapApiCall(async (channel) => {
          await channel.accept({
            promptText
          });
        });
      }
      async dismiss() {
        return this._wrapApiCall(async (channel) => {
          await channel.dismiss();
        });
      }
    };
    exports.Dialog = Dialog;
  }
});

// node_modules/playwright-core/lib/client/download.js
var require_download2 = __commonJS({
  "node_modules/playwright-core/lib/client/download.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Download = void 0;
    var Download = class {
      constructor(page, url, suggestedFilename, artifact) {
        this._page = void 0;
        this._url = void 0;
        this._suggestedFilename = void 0;
        this._artifact = void 0;
        this._page = page;
        this._url = url;
        this._suggestedFilename = suggestedFilename;
        this._artifact = artifact;
      }
      page() {
        return this._page;
      }
      url() {
        return this._url;
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
      async path() {
        return this._artifact.pathAfterFinished();
      }
      async saveAs(path) {
        return this._artifact.saveAs(path);
      }
      async failure() {
        return this._artifact.failure();
      }
      async createReadStream() {
        return this._artifact.createReadStream();
      }
      async cancel() {
        return this._artifact.cancel();
      }
      async delete() {
        return this._artifact.delete();
      }
    };
    exports.Download = Download;
  }
});

// node_modules/playwright-core/lib/client/locator.js
var require_locator = __commonJS({
  "node_modules/playwright-core/lib/client/locator.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FrameLocator = exports.Locator = void 0;
    var util = _interopRequireWildcard(__require("util"));
    var _utils = require_utils();
    var _elementHandle = require_elementHandle();
    var _jsHandle = require_jsHandle();
    var _util$inspect$custom;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    _util$inspect$custom = util.inspect.custom;
    var Locator = class {
      constructor(frame, selector) {
        this._frame = void 0;
        this._selector = void 0;
        this._frame = frame;
        this._selector = selector;
      }
      async _withElement(task, timeout) {
        timeout = this._frame.page()._timeoutSettings.timeout({
          timeout
        });
        const deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;
        return this._frame._wrapApiCall(async (channel) => {
          const result = await channel.waitForSelector({
            selector: this._selector,
            strict: true,
            state: "attached",
            timeout
          });
          const handle = _elementHandle.ElementHandle.fromNullable(result.element);
          if (!handle)
            throw new Error(`Could not resolve ${this._selector} to DOM Element`);
          try {
            return await task(handle, deadline ? deadline - (0, _utils.monotonicTime)() : 0);
          } finally {
            await handle.dispose();
          }
        });
      }
      async boundingBox(options2) {
        return this._withElement((h) => h.boundingBox(), options2 === null || options2 === void 0 ? void 0 : options2.timeout);
      }
      async check(options2 = {}) {
        return this._frame.check(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async click(options2 = {}) {
        return this._frame.click(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async dblclick(options2 = {}) {
        return this._frame.dblclick(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async dispatchEvent(type, eventInit = {}, options2) {
        return this._frame.dispatchEvent(this._selector, type, eventInit, __spreadValues({
          strict: true
        }, options2));
      }
      async evaluate(pageFunction, arg, options2) {
        return this._withElement((h) => h.evaluate(pageFunction, arg), options2 === null || options2 === void 0 ? void 0 : options2.timeout);
      }
      async evaluateAll(pageFunction, arg) {
        return this._frame.$$eval(this._selector, pageFunction, arg);
      }
      async evaluateHandle(pageFunction, arg, options2) {
        return this._withElement((h) => h.evaluateHandle(pageFunction, arg), options2 === null || options2 === void 0 ? void 0 : options2.timeout);
      }
      async fill(value, options2 = {}) {
        return this._frame.fill(this._selector, value, __spreadValues({
          strict: true
        }, options2));
      }
      locator(selector) {
        return new Locator(this._frame, this._selector + " >> " + selector);
      }
      frameLocator(selector) {
        return new FrameLocator(this._frame, this._selector + " >> " + selector);
      }
      async elementHandle(options2) {
        return await this._frame.waitForSelector(this._selector, __spreadValues({
          strict: true,
          state: "attached"
        }, options2));
      }
      async elementHandles() {
        return this._frame.$$(this._selector);
      }
      first() {
        return new Locator(this._frame, this._selector + " >> nth=0");
      }
      last() {
        return new Locator(this._frame, this._selector + ` >> nth=-1`);
      }
      nth(index) {
        return new Locator(this._frame, this._selector + ` >> nth=${index}`);
      }
      async focus(options2) {
        return this._frame.focus(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async count() {
        return this.evaluateAll((ee) => ee.length);
      }
      async getAttribute(name, options2) {
        return this._frame.getAttribute(this._selector, name, __spreadValues({
          strict: true
        }, options2));
      }
      async hover(options2 = {}) {
        return this._frame.hover(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async innerHTML(options2) {
        return this._frame.innerHTML(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async innerText(options2) {
        return this._frame.innerText(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async inputValue(options2) {
        return this._frame.inputValue(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async isChecked(options2) {
        return this._frame.isChecked(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async isDisabled(options2) {
        return this._frame.isDisabled(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async isEditable(options2) {
        return this._frame.isEditable(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async isEnabled(options2) {
        return this._frame.isEnabled(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async isHidden(options2) {
        return this._frame.isHidden(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async isVisible(options2) {
        return this._frame.isVisible(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async press(key, options2 = {}) {
        return this._frame.press(this._selector, key, __spreadValues({
          strict: true
        }, options2));
      }
      async screenshot(options2 = {}) {
        return this._withElement((h, timeout) => h.screenshot(__spreadProps(__spreadValues({}, options2), {
          timeout
        })), options2.timeout);
      }
      async scrollIntoViewIfNeeded(options2 = {}) {
        return this._withElement((h, timeout) => h.scrollIntoViewIfNeeded(__spreadProps(__spreadValues({}, options2), {
          timeout
        })), options2.timeout);
      }
      async selectOption(values, options2 = {}) {
        return this._frame.selectOption(this._selector, values, __spreadValues({
          strict: true
        }, options2));
      }
      async selectText(options2 = {}) {
        return this._withElement((h, timeout) => h.selectText(__spreadProps(__spreadValues({}, options2), {
          timeout
        })), options2.timeout);
      }
      async setChecked(checked, options2) {
        if (checked)
          await this.check(options2);
        else
          await this.uncheck(options2);
      }
      async setInputFiles(files, options2 = {}) {
        return this._frame.setInputFiles(this._selector, files, __spreadValues({
          strict: true
        }, options2));
      }
      async tap(options2 = {}) {
        return this._frame.tap(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async textContent(options2) {
        return this._frame.textContent(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async type(text, options2 = {}) {
        return this._frame.type(this._selector, text, __spreadValues({
          strict: true
        }, options2));
      }
      async uncheck(options2 = {}) {
        return this._frame.uncheck(this._selector, __spreadValues({
          strict: true
        }, options2));
      }
      async allInnerTexts() {
        return this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.innerText));
      }
      async allTextContents() {
        return this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.textContent || ""));
      }
      async waitFor(options2) {
        return this._frame._wrapApiCall(async (channel) => {
          await channel.waitForSelector(__spreadValues({
            selector: this._selector,
            strict: true,
            omitReturnValue: true
          }, options2));
        });
      }
      async _expect(expression, options2) {
        return this._frame._wrapApiCall(async (channel) => {
          const params = __spreadProps(__spreadValues({
            selector: this._selector,
            expression
          }, options2), {
            isNot: !!options2.isNot
          });
          if (options2.expectedValue)
            params.expectedValue = (0, _jsHandle.serializeArgument)(options2.expectedValue);
          const result = await channel.expect(params);
          if (result.received !== void 0)
            result.received = (0, _jsHandle.parseResult)(result.received);
          return result;
        });
      }
      [_util$inspect$custom]() {
        return this.toString();
      }
      toString() {
        return `Locator@${this._selector}`;
      }
    };
    exports.Locator = Locator;
    var FrameLocator = class {
      constructor(frame, selector) {
        this._frame = void 0;
        this._frameSelector = void 0;
        this._frame = frame;
        this._frameSelector = selector;
      }
      locator(selector) {
        return new Locator(this._frame, this._frameSelector + " >> control=enter-frame >> " + selector);
      }
      frameLocator(selector) {
        return new FrameLocator(this._frame, this._frameSelector + " >> control=enter-frame >> " + selector);
      }
      first() {
        return new FrameLocator(this._frame, this._frameSelector + " >> nth=0");
      }
      last() {
        return new FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);
      }
      nth(index) {
        return new FrameLocator(this._frame, this._frameSelector + ` >> nth=${index}`);
      }
    };
    exports.FrameLocator = FrameLocator;
  }
});

// node_modules/playwright-core/lib/client/waiter.js
var require_waiter = __commonJS({
  "node_modules/playwright-core/lib/client/waiter.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Waiter = void 0;
    var _stackTrace = require_stackTrace();
    var _errors = require_errors();
    var _utils = require_utils();
    var Waiter = class {
      constructor(channel, event) {
        this._dispose = void 0;
        this._failures = [];
        this._immediateError = void 0;
        this._logs = [];
        this._channel = void 0;
        this._waitId = void 0;
        this._error = void 0;
        this._waitId = (0, _utils.createGuid)();
        this._channel = channel;
        this._channel.waitForEventInfo({
          info: {
            waitId: this._waitId,
            phase: "before",
            event
          }
        }).catch(() => {
        });
        this._dispose = [() => this._channel.waitForEventInfo({
          info: {
            waitId: this._waitId,
            phase: "after",
            error: this._error
          }
        }).catch(() => {
        })];
      }
      static createForEvent(channel, event) {
        return new Waiter(channel, event);
      }
      async waitForEvent(emitter, event, predicate) {
        const {
          promise,
          dispose
        } = waitForEvent(emitter, event, predicate);
        return this.waitForPromise(promise, dispose);
      }
      rejectOnEvent(emitter, event, error2, predicate) {
        const {
          promise,
          dispose
        } = waitForEvent(emitter, event, predicate);
        this._rejectOn(promise.then(() => {
          throw error2;
        }), dispose);
      }
      rejectOnTimeout(timeout, message) {
        if (!timeout)
          return;
        const {
          promise,
          dispose
        } = waitForTimeout(timeout);
        this._rejectOn(promise.then(() => {
          throw new _errors.TimeoutError(message);
        }), dispose);
      }
      rejectImmediately(error2) {
        this._immediateError = error2;
      }
      dispose() {
        for (const dispose of this._dispose)
          dispose();
      }
      async waitForPromise(promise, dispose) {
        try {
          if (this._immediateError)
            throw this._immediateError;
          const result = await Promise.race([promise, ...this._failures]);
          if (dispose)
            dispose();
          return result;
        } catch (e) {
          if (dispose)
            dispose();
          this._error = e.message;
          this.dispose();
          (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(this._logs));
          throw e;
        }
      }
      log(s2) {
        this._logs.push(s2);
        this._channel.waitForEventInfo({
          info: {
            waitId: this._waitId,
            phase: "log",
            message: s2
          }
        }).catch(() => {
        });
      }
      _rejectOn(promise, dispose) {
        this._failures.push(promise);
        if (dispose)
          this._dispose.push(dispose);
      }
    };
    exports.Waiter = Waiter;
    function waitForEvent(emitter, event, predicate) {
      let listener;
      const promise = new Promise((resolve3, reject) => {
        listener = async (eventArg) => {
          try {
            if (predicate && !await predicate(eventArg))
              return;
            emitter.removeListener(event, listener);
            resolve3(eventArg);
          } catch (e) {
            emitter.removeListener(event, listener);
            reject(e);
          }
        };
        emitter.addListener(event, listener);
      });
      const dispose = () => emitter.removeListener(event, listener);
      return {
        promise,
        dispose
      };
    }
    function waitForTimeout(timeout) {
      let timeoutId;
      const promise = new Promise((resolve3) => timeoutId = setTimeout(resolve3, timeout));
      const dispose = () => clearTimeout(timeoutId);
      return {
        promise,
        dispose
      };
    }
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
  }
});

// node_modules/playwright-core/lib/client/clientHelper.js
var require_clientHelper = __commonJS({
  "node_modules/playwright-core/lib/client/clientHelper.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.deprecate = deprecate;
    exports.envObjectToArray = envObjectToArray;
    exports.evaluationScript = evaluationScript;
    exports.parsedURL = parsedURL;
    exports.urlMatches = urlMatches;
    exports.globToRegex = globToRegex;
    var _fs = _interopRequireDefault(__require("fs"));
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var deprecatedHits = new Set();
    function deprecate(methodName, message) {
      if (deprecatedHits.has(methodName))
        return;
      deprecatedHits.add(methodName);
      console.warn(message);
    }
    function envObjectToArray(env) {
      const result = [];
      for (const name in env) {
        if (!Object.is(env[name], void 0))
          result.push({
            name,
            value: String(env[name])
          });
      }
      return result;
    }
    async function evaluationScript(fun, arg, addSourceUrl = true) {
      if (typeof fun === "function") {
        const source = fun.toString();
        const argString = Object.is(arg, void 0) ? "undefined" : JSON.stringify(arg);
        return `(${source})(${argString})`;
      }
      if (arg !== void 0)
        throw new Error("Cannot evaluate a string with arguments");
      if ((0, _utils.isString)(fun))
        return fun;
      if (fun.content !== void 0)
        return fun.content;
      if (fun.path !== void 0) {
        let source = await _fs.default.promises.readFile(fun.path, "utf8");
        if (addSourceUrl)
          source += "//# sourceURL=" + fun.path.replace(/\n/g, "");
        return source;
      }
      throw new Error("Either path or content property must be present");
    }
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    function urlMatches(baseURL, urlString, match) {
      if (match === void 0 || match === "")
        return true;
      if ((0, _utils.isString)(match) && !match.startsWith("*"))
        match = (0, _utils.constructURLBasedOnBaseURL)(baseURL, match);
      if ((0, _utils.isString)(match))
        match = globToRegex(match);
      if ((0, _utils.isRegExp)(match))
        return match.test(urlString);
      if (typeof match === "string" && match === urlString)
        return true;
      const url = parsedURL(urlString);
      if (!url)
        return false;
      if (typeof match === "string")
        return url.pathname === match;
      if (typeof match !== "function")
        throw new Error("url parameter should be string, RegExp or function");
      return match(url);
    }
    var escapeGlobChars = new Set(["/", "$", "^", "+", ".", "(", ")", "=", "!", "|"]);
    function globToRegex(glob) {
      const tokens = ["^"];
      let inGroup;
      for (let i = 0; i < glob.length; ++i) {
        const c = glob[i];
        if (escapeGlobChars.has(c)) {
          tokens.push("\\" + c);
          continue;
        }
        if (c === "*") {
          const beforeDeep = glob[i - 1];
          let starCount = 1;
          while (glob[i + 1] === "*") {
            starCount++;
            i++;
          }
          const afterDeep = glob[i + 1];
          const isDeep = starCount > 1 && (beforeDeep === "/" || beforeDeep === void 0) && (afterDeep === "/" || afterDeep === void 0);
          if (isDeep) {
            tokens.push("((?:[^/]*(?:/|$))*)");
            i++;
          } else {
            tokens.push("([^/]*)");
          }
          continue;
        }
        switch (c) {
          case "?":
            tokens.push(".");
            break;
          case "{":
            inGroup = true;
            tokens.push("(");
            break;
          case "}":
            inGroup = false;
            tokens.push(")");
            break;
          case ",":
            if (inGroup) {
              tokens.push("|");
              break;
            }
            tokens.push("\\" + c);
            break;
          default:
            tokens.push(c);
        }
      }
      tokens.push("$");
      return new RegExp(tokens.join(""));
    }
  }
});

// node_modules/playwright-core/lib/utils/multimap.js
var require_multimap = __commonJS({
  "node_modules/playwright-core/lib/utils/multimap.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MultiMap = void 0;
    var MultiMap = class {
      constructor() {
        this._map = void 0;
        this._map = new Map();
      }
      set(key, value) {
        let values = this._map.get(key);
        if (!values) {
          values = [];
          this._map.set(key, values);
        }
        values.push(value);
      }
      get(key) {
        return this._map.get(key) || [];
      }
      has(key) {
        return this._map.has(key);
      }
      hasValue(key, value) {
        const values = this._map.get(key);
        if (!values)
          return false;
        return values.includes(value);
      }
      get size() {
        return this._map.size;
      }
      keys() {
        return this._map.keys();
      }
      values() {
        const result = [];
        for (const key of this.keys())
          result.push(...this.get(key));
        return result;
      }
      clear() {
        this._map.clear();
      }
    };
    exports.MultiMap = MultiMap;
  }
});

// node_modules/playwright-core/lib/client/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/playwright-core/lib/client/fetch.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.APIResponse = exports.APIRequestContext = exports.APIRequest = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var _path = _interopRequireDefault(__require("path"));
    var mime = _interopRequireWildcard(require_mime());
    var util = _interopRequireWildcard(__require("util"));
    var _errors = require_errors();
    var _utils = require_utils();
    var _channelOwner = require_channelOwner();
    var network = _interopRequireWildcard(require_network2());
    var _util$inspect$custom;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var APIRequest = class {
      constructor(playwright3) {
        this._playwright = void 0;
        this._playwright = playwright3;
      }
      async newContext(options2 = {}) {
        return await this._playwright._wrapApiCall(async (channel) => {
          const storageState = typeof options2.storageState === "string" ? JSON.parse(await _fs.default.promises.readFile(options2.storageState, "utf8")) : options2.storageState;
          return APIRequestContext.from((await channel.newRequest(__spreadProps(__spreadValues({}, options2), {
            extraHTTPHeaders: options2.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options2.extraHTTPHeaders) : void 0,
            storageState
          }))).request);
        });
      }
    };
    exports.APIRequest = APIRequest;
    var APIRequestContext = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      dispose() {
        return this._wrapApiCall(async (channel) => {
          await channel.dispose();
        });
      }
      async delete(url, options2) {
        return this.fetch(url, __spreadProps(__spreadValues({}, options2), {
          method: "DELETE"
        }));
      }
      async head(url, options2) {
        return this.fetch(url, __spreadProps(__spreadValues({}, options2), {
          method: "HEAD"
        }));
      }
      async get(url, options2) {
        return this.fetch(url, __spreadProps(__spreadValues({}, options2), {
          method: "GET"
        }));
      }
      async patch(url, options2) {
        return this.fetch(url, __spreadProps(__spreadValues({}, options2), {
          method: "PATCH"
        }));
      }
      async post(url, options2) {
        return this.fetch(url, __spreadProps(__spreadValues({}, options2), {
          method: "POST"
        }));
      }
      async put(url, options2) {
        return this.fetch(url, __spreadProps(__spreadValues({}, options2), {
          method: "PUT"
        }));
      }
      async fetch(urlOrRequest, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const request = urlOrRequest instanceof network.Request ? urlOrRequest : void 0;
          (0, _utils.assert)(request || typeof urlOrRequest === "string", "First argument must be either URL string or Request");
          (0, _utils.assert)((options2.data === void 0 ? 0 : 1) + (options2.form === void 0 ? 0 : 1) + (options2.multipart === void 0 ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
          const url = request ? request.url() : urlOrRequest;
          const params = (0, _utils.objectToArray)(options2.params);
          const method = options2.method || (request === null || request === void 0 ? void 0 : request.method());
          const headersObj = options2.headers || (request === null || request === void 0 ? void 0 : request.headers());
          const headers = headersObj ? (0, _utils.headersObjectToArray)(headersObj) : void 0;
          let jsonData;
          let formData;
          let multipartData;
          let postDataBuffer;
          if (options2.data !== void 0) {
            if ((0, _utils.isString)(options2.data)) {
              if (isJsonContentType(headers))
                jsonData = options2.data;
              else
                postDataBuffer = Buffer.from(options2.data, "utf8");
            } else if (Buffer.isBuffer(options2.data)) {
              postDataBuffer = options2.data;
            } else if (typeof options2.data === "object" || typeof options2.data === "number" || typeof options2.data === "boolean") {
              jsonData = options2.data;
            } else {
              throw new Error(`Unexpected 'data' type`);
            }
          } else if (options2.form) {
            formData = (0, _utils.objectToArray)(options2.form);
          } else if (options2.multipart) {
            multipartData = [];
            for (const [name, value] of Object.entries(options2.multipart)) {
              if ((0, _utils.isFilePayload)(value)) {
                const payload = value;
                if (!Buffer.isBuffer(payload.buffer))
                  throw new Error(`Unexpected buffer type of 'data.${name}'`);
                multipartData.push({
                  name,
                  file: filePayloadToJson(payload)
                });
              } else if (value instanceof _fs.default.ReadStream) {
                multipartData.push({
                  name,
                  file: await readStreamToJson(value)
                });
              } else {
                multipartData.push({
                  name,
                  value: String(value)
                });
              }
            }
          }
          if (postDataBuffer === void 0 && jsonData === void 0 && formData === void 0 && multipartData === void 0)
            postDataBuffer = (request === null || request === void 0 ? void 0 : request.postDataBuffer()) || void 0;
          const postData = postDataBuffer ? postDataBuffer.toString("base64") : void 0;
          const result = await channel.fetch({
            url,
            params,
            method,
            headers,
            postData,
            jsonData,
            formData,
            multipartData,
            timeout: options2.timeout,
            failOnStatusCode: options2.failOnStatusCode,
            ignoreHTTPSErrors: options2.ignoreHTTPSErrors
          });
          if (result.error)
            throw new Error(result.error);
          return new APIResponse(this, result.response);
        });
      }
      async storageState(options2 = {}) {
        return await this._wrapApiCall(async (channel) => {
          const state = await channel.storageState();
          if (options2.path) {
            await (0, _utils.mkdirIfNeeded)(options2.path);
            await _fs.default.promises.writeFile(options2.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
    };
    exports.APIRequestContext = APIRequestContext;
    _util$inspect$custom = util.inspect.custom;
    var APIResponse = class {
      constructor(context, initializer) {
        this._initializer = void 0;
        this._headers = void 0;
        this._request = void 0;
        this._request = context;
        this._initializer = initializer;
        this._headers = new network.RawHeaders(this._initializer.headers);
      }
      ok() {
        return this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      url() {
        return this._initializer.url;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      headers() {
        return this._headers.headers();
      }
      headersArray() {
        return this._headers.headersArray();
      }
      async body() {
        return this._request._wrapApiCall(async (channel) => {
          try {
            const result = await channel.fetchResponseBody({
              fetchUid: this._fetchUid()
            });
            if (result.binary === void 0)
              throw new Error("Response has been disposed");
            return Buffer.from(result.binary, "base64");
          } catch (e) {
            if (e.message === _errors.kBrowserOrContextClosedError)
              throw new Error("Response has been disposed");
            throw e;
          }
        });
      }
      async text() {
        const content = await this.body();
        return content.toString("utf8");
      }
      async json() {
        const content = await this.text();
        return JSON.parse(content);
      }
      async dispose() {
        return this._request._wrapApiCall(async (channel) => {
          await channel.disposeAPIResponse({
            fetchUid: this._fetchUid()
          });
        });
      }
      [_util$inspect$custom]() {
        const headers = this.headersArray().map(({
          name,
          value
        }) => `  ${name}: ${value}`);
        return `APIResponse: ${this.status()} ${this.statusText()}
${headers.join("\n")}`;
      }
      _fetchUid() {
        return this._initializer.fetchUid;
      }
    };
    exports.APIResponse = APIResponse;
    function filePayloadToJson(payload) {
      return {
        name: payload.name,
        mimeType: payload.mimeType,
        buffer: payload.buffer.toString("base64")
      };
    }
    async function readStreamToJson(stream) {
      const buffer = await new Promise((resolve3, reject) => {
        const chunks = [];
        stream.on("data", (chunk) => chunks.push(chunk));
        stream.on("end", () => resolve3(Buffer.concat(chunks)));
        stream.on("error", (err) => reject(err));
      });
      const streamPath = Buffer.isBuffer(stream.path) ? stream.path.toString("utf8") : stream.path;
      return {
        name: _path.default.basename(streamPath),
        mimeType: mime.getType(streamPath) || "application/octet-stream",
        buffer: buffer.toString("base64")
      };
    }
    function isJsonContentType(headers) {
      if (!headers)
        return false;
      for (const {
        name,
        value
      } of headers) {
        if (name.toLocaleLowerCase() === "content-type")
          return value === "application/json";
      }
      return false;
    }
  }
});

// node_modules/playwright-core/lib/client/network.js
var require_network2 = __commonJS({
  "node_modules/playwright-core/lib/client/network.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.validateHeaders = validateHeaders;
    exports.RawHeaders = exports.RouteHandler = exports.WebSocket = exports.Response = exports.Route = exports.Request = void 0;
    var _url = __require("url");
    var _channelOwner = require_channelOwner();
    var _frame = require_frame();
    var _fs = _interopRequireDefault(__require("fs"));
    var mime = _interopRequireWildcard(require_mime());
    var _utils = require_utils();
    var _async = require_async();
    var _events = require_events();
    var _waiter = require_waiter();
    var _clientHelper = require_clientHelper();
    var _multimap = require_multimap();
    var _fetch = require_fetch2();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Request2 = class extends _channelOwner.ChannelOwner {
      static from(request) {
        return request._object;
      }
      static fromNullable(request) {
        return request ? Request2.from(request) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._redirectedFrom = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._provisionalHeaders = void 0;
        this._actualHeadersPromise = void 0;
        this._postData = void 0;
        this._timing = void 0;
        this._redirectedFrom = Request2.fromNullable(initializer.redirectedFrom);
        if (this._redirectedFrom)
          this._redirectedFrom._redirectedTo = this;
        this._provisionalHeaders = new RawHeaders(initializer.headers);
        this._postData = initializer.postData ? Buffer.from(initializer.postData, "base64") : null;
        this._timing = {
          startTime: 0,
          domainLookupStart: -1,
          domainLookupEnd: -1,
          connectStart: -1,
          secureConnectionStart: -1,
          connectEnd: -1,
          requestStart: -1,
          responseStart: -1,
          responseEnd: -1
        };
      }
      url() {
        return this._initializer.url;
      }
      resourceType() {
        return this._initializer.resourceType;
      }
      method() {
        return this._initializer.method;
      }
      postData() {
        return this._postData ? this._postData.toString("utf8") : null;
      }
      postDataBuffer() {
        return this._postData;
      }
      postDataJSON() {
        const postData = this.postData();
        if (!postData)
          return null;
        const contentType = this.headers()["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          const entries = {};
          const parsed = new _url.URLSearchParams(postData);
          for (const [k, v] of parsed.entries())
            entries[k] = v;
          return entries;
        }
        try {
          return JSON.parse(postData);
        } catch (e) {
          throw new Error("POST data is not a valid JSON object: " + postData);
        }
      }
      headers() {
        return this._provisionalHeaders.headers();
      }
      _actualHeaders() {
        if (!this._actualHeadersPromise) {
          this._actualHeadersPromise = this._wrapApiCall(async (channel) => {
            return new RawHeaders((await channel.rawRequestHeaders()).headers);
          });
        }
        return this._actualHeadersPromise;
      }
      async allHeaders() {
        return (await this._actualHeaders()).headers();
      }
      async headersArray() {
        return (await this._actualHeaders()).headersArray();
      }
      async headerValue(name) {
        return (await this._actualHeaders()).get(name);
      }
      async response() {
        return this._wrapApiCall(async (channel) => {
          return Response2.fromNullable((await channel.response()).response);
        });
      }
      async _internalResponse() {
        return this._wrapApiCall(async (channel) => {
          return Response2.fromNullable((await channel.response()).response);
        }, void 0, true);
      }
      frame() {
        return _frame.Frame.from(this._initializer.frame);
      }
      isNavigationRequest() {
        return this._initializer.isNavigationRequest;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      redirectedTo() {
        return this._redirectedTo;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      timing() {
        return this._timing;
      }
      async sizes() {
        const response = await this.response();
        if (!response)
          throw new Error("Unable to fetch sizes for failed request");
        return response._wrapApiCall(async (channel) => {
          return (await channel.sizes()).sizes;
        });
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
    };
    exports.Request = Request2;
    var Route = class extends _channelOwner.ChannelOwner {
      static from(route) {
        return route._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      request() {
        return Request2.from(this._initializer.request);
      }
      _raceWithPageClose(promise) {
        const page = this.request().frame()._page;
        return Promise.race([promise, page ? page._closedOrCrashedPromise : Promise.resolve()]);
      }
      async abort(errorCode) {
        return this._wrapApiCall(async (channel) => {
          await this._raceWithPageClose(channel.abort({
            errorCode
          }));
        });
      }
      async fulfill(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          let fetchResponseUid;
          let {
            status: statusOption,
            headers: headersOption,
            body
          } = options2;
          if (options2.response) {
            statusOption || (statusOption = options2.response.status());
            headersOption || (headersOption = options2.response.headers());
            if (options2.body === void 0 && options2.path === void 0 && options2.response instanceof _fetch.APIResponse)
              fetchResponseUid = options2.response._fetchUid();
          }
          let isBase64 = false;
          let length = 0;
          if (options2.path) {
            const buffer = await _fs.default.promises.readFile(options2.path);
            body = buffer.toString("base64");
            isBase64 = true;
            length = buffer.length;
          } else if ((0, _utils.isString)(body)) {
            isBase64 = false;
            length = Buffer.byteLength(body);
          } else if (body) {
            length = body.length;
            body = body.toString("base64");
            isBase64 = true;
          }
          const headers = {};
          for (const header of Object.keys(headersOption || {}))
            headers[header.toLowerCase()] = String(headersOption[header]);
          if (options2.contentType)
            headers["content-type"] = String(options2.contentType);
          else if (options2.path)
            headers["content-type"] = mime.getType(options2.path) || "application/octet-stream";
          if (length && !("content-length" in headers))
            headers["content-length"] = String(length);
          await this._raceWithPageClose(channel.fulfill({
            status: statusOption || 200,
            headers: (0, _utils.headersObjectToArray)(headers),
            body,
            isBase64,
            fetchResponseUid
          }));
        });
      }
      async continue(options2 = {}) {
        await this._continue(options2);
      }
      async _internalContinue(options2 = {}) {
        await this._continue(options2, true).catch(() => {
        });
      }
      async _continue(options2, isInternal) {
        return await this._wrapApiCall(async (channel) => {
          const postDataBuffer = (0, _utils.isString)(options2.postData) ? Buffer.from(options2.postData, "utf8") : options2.postData;
          await this._raceWithPageClose(channel.continue({
            url: options2.url,
            method: options2.method,
            headers: options2.headers ? (0, _utils.headersObjectToArray)(options2.headers) : void 0,
            postData: postDataBuffer ? postDataBuffer.toString("base64") : void 0
          }));
        }, void 0, isInternal);
      }
    };
    exports.Route = Route;
    var Response2 = class extends _channelOwner.ChannelOwner {
      static from(response) {
        return response._object;
      }
      static fromNullable(response) {
        return response ? Response2.from(response) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._provisionalHeaders = void 0;
        this._actualHeadersPromise = void 0;
        this._request = void 0;
        this._finishedPromise = new _async.ManualPromise();
        this._provisionalHeaders = new RawHeaders(initializer.headers);
        this._request = Request2.from(this._initializer.request);
        Object.assign(this._request._timing, this._initializer.timing);
      }
      url() {
        return this._initializer.url;
      }
      ok() {
        return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      headers() {
        return this._provisionalHeaders.headers();
      }
      async _actualHeaders() {
        if (!this._actualHeadersPromise) {
          this._actualHeadersPromise = this._wrapApiCall(async (channel) => {
            return new RawHeaders((await channel.rawResponseHeaders()).headers);
          });
        }
        return this._actualHeadersPromise;
      }
      async allHeaders() {
        return (await this._actualHeaders()).headers();
      }
      async headersArray() {
        return (await this._actualHeaders()).headersArray().slice();
      }
      async headerValue(name) {
        return (await this._actualHeaders()).get(name);
      }
      async headerValues(name) {
        return (await this._actualHeaders()).getAll(name);
      }
      async finished() {
        return this._finishedPromise.then(() => null);
      }
      async body() {
        return this._wrapApiCall(async (channel) => {
          return Buffer.from((await channel.body()).binary, "base64");
        });
      }
      async text() {
        const content = await this.body();
        return content.toString("utf8");
      }
      async json() {
        const content = await this.text();
        return JSON.parse(content);
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
      async serverAddr() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.serverAddr()).value || null;
        });
      }
      async securityDetails() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.securityDetails()).value || null;
        });
      }
    };
    exports.Response = Response2;
    var WebSocket = class extends _channelOwner.ChannelOwner {
      static from(webSocket) {
        return webSocket._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._isClosed = void 0;
        this._isClosed = false;
        this._page = parent;
        this._channel.on("frameSent", (event) => {
          if (event.opcode === 1)
            this.emit(_events.Events.WebSocket.FrameSent, {
              payload: event.data
            });
          else if (event.opcode === 2)
            this.emit(_events.Events.WebSocket.FrameSent, {
              payload: Buffer.from(event.data, "base64")
            });
        });
        this._channel.on("frameReceived", (event) => {
          if (event.opcode === 1)
            this.emit(_events.Events.WebSocket.FrameReceived, {
              payload: event.data
            });
          else if (event.opcode === 2)
            this.emit(_events.Events.WebSocket.FrameReceived, {
              payload: Buffer.from(event.data, "base64")
            });
        });
        this._channel.on("socketError", ({
          error: error2
        }) => this.emit(_events.Events.WebSocket.Error, error2));
        this._channel.on("close", () => {
          this._isClosed = true;
          this.emit(_events.Events.WebSocket.Close, this);
        });
      }
      url() {
        return this._initializer.url;
      }
      isClosed() {
        return this._isClosed;
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        return this._wrapApiCall(async (channel) => {
          const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
          const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
          const waiter = _waiter.Waiter.createForEvent(channel, event);
          waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
          if (event !== _events.Events.WebSocket.Error)
            waiter.rejectOnEvent(this, _events.Events.WebSocket.Error, new Error("Socket error"));
          if (event !== _events.Events.WebSocket.Close)
            waiter.rejectOnEvent(this, _events.Events.WebSocket.Close, new Error("Socket closed"));
          waiter.rejectOnEvent(this._page, _events.Events.Page.Close, new Error("Page closed"));
          const result = await waiter.waitForEvent(this, event, predicate);
          waiter.dispose();
          return result;
        });
      }
    };
    exports.WebSocket = WebSocket;
    function validateHeaders(headers) {
      for (const key of Object.keys(headers)) {
        const value = headers[key];
        if (!Object.is(value, void 0) && !(0, _utils.isString)(value))
          throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
      }
    }
    var RouteHandler = class {
      constructor(baseURL, url, handler, times = Number.MAX_SAFE_INTEGER) {
        this.handledCount = 0;
        this._baseURL = void 0;
        this._times = void 0;
        this.url = void 0;
        this.handler = void 0;
        this._baseURL = baseURL;
        this._times = times;
        this.url = url;
        this.handler = handler;
      }
      matches(requestURL) {
        return (0, _clientHelper.urlMatches)(this._baseURL, requestURL, this.url);
      }
      handle(route, request) {
        try {
          this.handler(route, request);
        } finally {
          return ++this.handledCount >= this._times;
        }
      }
    };
    exports.RouteHandler = RouteHandler;
    var RawHeaders = class {
      constructor(headers) {
        this._headersArray = void 0;
        this._headersMap = new _multimap.MultiMap();
        this._headersArray = headers;
        for (const header of headers)
          this._headersMap.set(header.name.toLowerCase(), header.value);
      }
      get(name) {
        const values = this.getAll(name);
        if (!values || !values.length)
          return null;
        return values.join(name.toLowerCase() === "set-cookie" ? "\n" : ", ");
      }
      getAll(name) {
        return [...this._headersMap.get(name.toLowerCase())];
      }
      headers() {
        const result = {};
        for (const name of this._headersMap.keys())
          result[name] = this.get(name);
        return result;
      }
      headersArray() {
        return this._headersArray;
      }
    };
    exports.RawHeaders = RawHeaders;
  }
});

// node_modules/playwright-core/lib/client/types.js
var require_types3 = __commonJS({
  "node_modules/playwright-core/lib/client/types.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Size", {
      enumerable: true,
      get: function() {
        return _types.Size;
      }
    });
    Object.defineProperty(exports, "Point", {
      enumerable: true,
      get: function() {
        return _types.Point;
      }
    });
    Object.defineProperty(exports, "Rect", {
      enumerable: true,
      get: function() {
        return _types.Rect;
      }
    });
    Object.defineProperty(exports, "Quad", {
      enumerable: true,
      get: function() {
        return _types.Quad;
      }
    });
    Object.defineProperty(exports, "URLMatch", {
      enumerable: true,
      get: function() {
        return _types.URLMatch;
      }
    });
    Object.defineProperty(exports, "TimeoutOptions", {
      enumerable: true,
      get: function() {
        return _types.TimeoutOptions;
      }
    });
    Object.defineProperty(exports, "HeadersArray", {
      enumerable: true,
      get: function() {
        return _types.HeadersArray;
      }
    });
    exports.kLifecycleEvents = void 0;
    var _types = require_types();
    var kLifecycleEvents = new Set(["load", "domcontentloaded", "networkidle", "commit"]);
    exports.kLifecycleEvents = kLifecycleEvents;
  }
});

// node_modules/playwright-core/lib/client/frame.js
var require_frame = __commonJS({
  "node_modules/playwright-core/lib/client/frame.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.verifyLoadState = verifyLoadState;
    exports.Frame = void 0;
    var _utils = require_utils();
    var _channelOwner = require_channelOwner();
    var _locator = require_locator();
    var _elementHandle = require_elementHandle();
    var _jsHandle = require_jsHandle();
    var _fs = _interopRequireDefault(__require("fs"));
    var network = _interopRequireWildcard(require_network2());
    var _events = __require("events");
    var _waiter = require_waiter();
    var _events2 = require_events();
    var _types = require_types3();
    var _clientHelper = require_clientHelper();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Frame = class extends _channelOwner.ChannelOwner {
      static from(frame) {
        return frame._object;
      }
      static fromNullable(frame) {
        return frame ? Frame.from(frame) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._eventEmitter = void 0;
        this._loadStates = void 0;
        this._parentFrame = null;
        this._url = "";
        this._name = "";
        this._detached = false;
        this._childFrames = new Set();
        this._page = void 0;
        this._eventEmitter = new _events.EventEmitter();
        this._eventEmitter.setMaxListeners(0);
        this._parentFrame = Frame.fromNullable(initializer.parentFrame);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._name = initializer.name;
        this._url = initializer.url;
        this._loadStates = new Set(initializer.loadStates);
        this._channel.on("loadstate", (event) => {
          if (event.add) {
            this._loadStates.add(event.add);
            this._eventEmitter.emit("loadstate", event.add);
          }
          if (event.remove)
            this._loadStates.delete(event.remove);
        });
        this._channel.on("navigated", (event) => {
          this._url = event.url;
          this._name = event.name;
          this._eventEmitter.emit("navigated", event);
          if (!event.error && this._page)
            this._page.emit(_events2.Events.Page.FrameNavigated, this);
        });
      }
      page() {
        return this._page;
      }
      async goto(url, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          return network.Response.fromNullable((await channel.goto(__spreadProps(__spreadValues({
            url
          }, options2), {
            waitUntil
          }))).response);
        });
      }
      _setupNavigationWaiter(channel, options2) {
        const waiter = new _waiter.Waiter(channel, "");
        if (this._page.isClosed())
          waiter.rejectImmediately(new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.Close, new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.Crash, new Error("Navigation failed because page crashed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.FrameDetached, new Error("Navigating frame was detached!"), (frame) => frame === this);
        const timeout = this._page._timeoutSettings.navigationTimeout(options2);
        waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
        return waiter;
      }
      async waitForNavigation(options2 = {}) {
        return this._page._wrapApiCall(async (channel) => {
          const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          const waiter = this._setupNavigationWaiter(channel, options2);
          const toUrl = typeof options2.url === "string" ? ` to "${options2.url}"` : "";
          waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
          const navigatedEvent = await waiter.waitForEvent(this._eventEmitter, "navigated", (event) => {
            var _this$_page;
            if (event.error)
              return true;
            waiter.log(`  navigated to "${event.url}"`);
            return (0, _clientHelper.urlMatches)((_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page.context()._options.baseURL, event.url, options2.url);
          });
          if (navigatedEvent.error) {
            const e = new Error(navigatedEvent.error);
            e.stack = "";
            await waiter.waitForPromise(Promise.reject(e));
          }
          if (!this._loadStates.has(waitUntil)) {
            await waiter.waitForEvent(this._eventEmitter, "loadstate", (s2) => {
              waiter.log(`  "${s2}" event fired`);
              return s2 === waitUntil;
            });
          }
          const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;
          const response = request ? await waiter.waitForPromise(request._finalRequest()._internalResponse()) : null;
          waiter.dispose();
          return response;
        });
      }
      async waitForLoadState(state = "load", options2 = {}) {
        state = verifyLoadState("state", state);
        if (this._loadStates.has(state))
          return;
        return this._page._wrapApiCall(async (channel) => {
          const waiter = this._setupNavigationWaiter(channel, options2);
          await waiter.waitForEvent(this._eventEmitter, "loadstate", (s2) => {
            waiter.log(`  "${s2}" event fired`);
            return s2 === state;
          });
          waiter.dispose();
        });
      }
      async waitForURL(url, options2 = {}) {
        var _this$_page2;
        if ((0, _clientHelper.urlMatches)((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2.context()._options.baseURL, this.url(), url))
          return await this.waitForLoadState(options2.waitUntil, options2);
        await this.waitForNavigation(__spreadValues({
          url
        }, options2));
      }
      async frameElement() {
        return this._wrapApiCall(async (channel) => {
          return _elementHandle.ElementHandle.from((await channel.frameElement()).element);
        });
      }
      async evaluateHandle(pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      async evaluate(pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      async $(selector, options2) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.querySelector(__spreadValues({
            selector
          }, options2));
          return _elementHandle.ElementHandle.fromNullable(result.element);
        });
      }
      async waitForSelector(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          if (options2.visibility)
            throw new Error("options.visibility is not supported, did you mean options.state?");
          if (options2.waitFor && options2.waitFor !== "visible")
            throw new Error("options.waitFor is not supported, did you mean options.state?");
          const result = await channel.waitForSelector(__spreadValues({
            selector
          }, options2));
          return _elementHandle.ElementHandle.fromNullable(result.element);
        });
      }
      async dispatchEvent(selector, type, eventInit, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.dispatchEvent(__spreadValues({
            selector,
            type,
            eventInit: (0, _jsHandle.serializeArgument)(eventInit)
          }, options2));
        });
      }
      async $eval(selector, pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evalOnSelector({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      async $$eval(selector, pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evalOnSelectorAll({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      async $$(selector) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.querySelectorAll({
            selector
          });
          return result.elements.map((e) => _elementHandle.ElementHandle.from(e));
        });
      }
      async content() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.content()).value;
        });
      }
      async setContent(html, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          await channel.setContent(__spreadProps(__spreadValues({
            html
          }, options2), {
            waitUntil
          }));
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      isDetached() {
        return this._detached;
      }
      async addScriptTag(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const copy = __spreadValues({}, options2);
          if (copy.path) {
            copy.content = (await _fs.default.promises.readFile(copy.path)).toString();
            copy.content += "//# sourceURL=" + copy.path.replace(/\n/g, "");
          }
          return _elementHandle.ElementHandle.from((await channel.addScriptTag(__spreadValues({}, copy))).element);
        });
      }
      async addStyleTag(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const copy = __spreadValues({}, options2);
          if (copy.path) {
            copy.content = (await _fs.default.promises.readFile(copy.path)).toString();
            copy.content += "/*# sourceURL=" + copy.path.replace(/\n/g, "") + "*/";
          }
          return _elementHandle.ElementHandle.from((await channel.addStyleTag(__spreadValues({}, copy))).element);
        });
      }
      async click(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.click(__spreadValues({
            selector
          }, options2));
        });
      }
      async dblclick(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.dblclick(__spreadValues({
            selector
          }, options2));
        });
      }
      async dragAndDrop(source, target, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.dragAndDrop(__spreadValues({
            source,
            target
          }, options2));
        });
      }
      async tap(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.tap(__spreadValues({
            selector
          }, options2));
        });
      }
      async fill(selector, value, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.fill(__spreadValues({
            selector,
            value
          }, options2));
        });
      }
      locator(selector) {
        return new _locator.Locator(this, selector);
      }
      frameLocator(selector) {
        return new _locator.FrameLocator(this, selector);
      }
      async focus(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.focus(__spreadValues({
            selector
          }, options2));
        });
      }
      async textContent(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const value = (await channel.textContent(__spreadValues({
            selector
          }, options2))).value;
          return value === void 0 ? null : value;
        });
      }
      async innerText(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.innerText(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async innerHTML(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.innerHTML(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async getAttribute(selector, name, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const value = (await channel.getAttribute(__spreadValues({
            selector,
            name
          }, options2))).value;
          return value === void 0 ? null : value;
        });
      }
      async inputValue(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.inputValue(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async isChecked(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isChecked(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async isDisabled(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isDisabled(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async isEditable(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isEditable(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async isEnabled(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isEnabled(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async isHidden(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isHidden(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async isVisible(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isVisible(__spreadValues({
            selector
          }, options2))).value;
        });
      }
      async hover(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.hover(__spreadValues({
            selector
          }, options2));
        });
      }
      async selectOption(selector, values, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return (await channel.selectOption(__spreadValues(__spreadValues({
            selector
          }, (0, _elementHandle.convertSelectOptionValues)(values)), options2))).values;
        });
      }
      async setInputFiles(selector, files, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.setInputFiles(__spreadValues({
            selector,
            files: await (0, _elementHandle.convertInputFiles)(files)
          }, options2));
        });
      }
      async type(selector, text, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.type(__spreadValues({
            selector,
            text
          }, options2));
        });
      }
      async press(selector, key, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.press(__spreadValues({
            selector,
            key
          }, options2));
        });
      }
      async check(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.check(__spreadValues({
            selector
          }, options2));
        });
      }
      async uncheck(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.uncheck(__spreadValues({
            selector
          }, options2));
        });
      }
      async setChecked(selector, checked, options2) {
        if (checked)
          await this.check(selector, options2);
        else
          await this.uncheck(selector, options2);
      }
      async waitForTimeout(timeout) {
        return this._wrapApiCall(async (channel) => {
          await channel.waitForTimeout({
            timeout
          });
        });
      }
      async waitForFunction(pageFunction, arg, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          if (typeof options2.polling === "string")
            (0, _utils.assert)(options2.polling === "raf", "Unknown polling option: " + options2.polling);
          const result = await channel.waitForFunction(__spreadProps(__spreadValues({}, options2), {
            pollingInterval: options2.polling === "raf" ? void 0 : options2.polling,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          }));
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      async title() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.title()).value;
        });
      }
    };
    exports.Frame = Frame;
    function verifyLoadState(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!_types.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
      return waitUntil;
    }
  }
});

// node_modules/playwright-core/lib/client/elementHandle.js
var require_elementHandle = __commonJS({
  "node_modules/playwright-core/lib/client/elementHandle.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.convertSelectOptionValues = convertSelectOptionValues;
    exports.convertInputFiles = convertInputFiles;
    exports.determineScreenshotType = determineScreenshotType;
    exports.ElementHandle = void 0;
    var _frame = require_frame();
    var _jsHandle = require_jsHandle();
    var _fs = _interopRequireDefault(__require("fs"));
    var mime = _interopRequireWildcard(require_mime());
    var _path = _interopRequireDefault(__require("path"));
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ElementHandle = class extends _jsHandle.JSHandle {
      static from(handle) {
        return handle._object;
      }
      static fromNullable(handle) {
        return handle ? ElementHandle.from(handle) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._elementChannel = void 0;
        this._elementChannel = this._channel;
      }
      asElement() {
        return this;
      }
      async ownerFrame() {
        return this._wrapApiCall(async (channel) => {
          return _frame.Frame.fromNullable((await channel.ownerFrame()).frame);
        });
      }
      async contentFrame() {
        return this._wrapApiCall(async (channel) => {
          return _frame.Frame.fromNullable((await channel.contentFrame()).frame);
        });
      }
      async getAttribute(name) {
        return this._wrapApiCall(async (channel) => {
          const value = (await channel.getAttribute({
            name
          })).value;
          return value === void 0 ? null : value;
        });
      }
      async inputValue() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.inputValue()).value;
        });
      }
      async textContent() {
        return this._wrapApiCall(async (channel) => {
          const value = (await channel.textContent()).value;
          return value === void 0 ? null : value;
        });
      }
      async innerText() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.innerText()).value;
        });
      }
      async innerHTML() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.innerHTML()).value;
        });
      }
      async isChecked() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isChecked()).value;
        });
      }
      async isDisabled() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isDisabled()).value;
        });
      }
      async isEditable() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isEditable()).value;
        });
      }
      async isEnabled() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isEnabled()).value;
        });
      }
      async isHidden() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isHidden()).value;
        });
      }
      async isVisible() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.isVisible()).value;
        });
      }
      async dispatchEvent(type, eventInit = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.dispatchEvent({
            type,
            eventInit: (0, _jsHandle.serializeArgument)(eventInit)
          });
        });
      }
      async scrollIntoViewIfNeeded(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.scrollIntoViewIfNeeded(options2);
        });
      }
      async hover(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.hover(options2);
        });
      }
      async click(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.click(options2);
        });
      }
      async dblclick(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.dblclick(options2);
        });
      }
      async tap(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.tap(options2);
        });
      }
      async selectOption(values, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.selectOption(__spreadValues(__spreadValues({}, convertSelectOptionValues(values)), options2));
          return result.values;
        });
      }
      async fill(value, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.fill(__spreadValues({
            value
          }, options2));
        });
      }
      async selectText(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.selectText(options2);
        });
      }
      async setInputFiles(files, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.setInputFiles(__spreadValues({
            files: await convertInputFiles(files)
          }, options2));
        });
      }
      async focus() {
        return this._wrapApiCall(async (channel) => {
          await channel.focus();
        });
      }
      async type(text, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.type(__spreadValues({
            text
          }, options2));
        });
      }
      async press(key, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.press(__spreadValues({
            key
          }, options2));
        });
      }
      async check(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.check(options2);
        });
      }
      async uncheck(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.uncheck(options2);
        });
      }
      async setChecked(checked, options2) {
        if (checked)
          await this.check(options2);
        else
          await this.uncheck(options2);
      }
      async boundingBox() {
        return this._wrapApiCall(async (channel) => {
          const value = (await channel.boundingBox()).value;
          return value === void 0 ? null : value;
        });
      }
      async screenshot(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const copy = __spreadValues({}, options2);
          if (!copy.type)
            copy.type = determineScreenshotType(options2);
          const result = await channel.screenshot(copy);
          const buffer = Buffer.from(result.binary, "base64");
          if (options2.path) {
            await (0, _utils.mkdirIfNeeded)(options2.path);
            await _fs.default.promises.writeFile(options2.path, buffer);
          }
          return buffer;
        });
      }
      async $(selector) {
        return this._wrapApiCall(async (channel) => {
          return ElementHandle.fromNullable((await channel.querySelector({
            selector
          })).element);
        });
      }
      async $$(selector) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.querySelectorAll({
            selector
          });
          return result.elements.map((h) => ElementHandle.from(h));
        });
      }
      async $eval(selector, pageFunction, arg) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evalOnSelector({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      async $$eval(selector, pageFunction, arg) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evalOnSelectorAll({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      async waitForElementState(state, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          return await channel.waitForElementState(__spreadValues({
            state
          }, options2));
        });
      }
      async waitForSelector(selector, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.waitForSelector(__spreadValues({
            selector
          }, options2));
          return ElementHandle.fromNullable(result.element);
        });
      }
    };
    exports.ElementHandle = ElementHandle;
    function convertSelectOptionValues(values) {
      if (values === null)
        return {};
      if (!Array.isArray(values))
        values = [values];
      if (!values.length)
        return {};
      for (let i = 0; i < values.length; i++)
        (0, _utils.assert)(values[i] !== null, `options[${i}]: expected object, got null`);
      if (values[0] instanceof ElementHandle)
        return {
          elements: values.map((v) => v._elementChannel)
        };
      if ((0, _utils.isString)(values[0]))
        return {
          options: values.map((value) => ({
            value
          }))
        };
      return {
        options: values
      };
    }
    async function convertInputFiles(files) {
      const items = Array.isArray(files) ? files : [files];
      const filePayloads = await Promise.all(items.map(async (item) => {
        if (typeof item === "string") {
          return {
            name: _path.default.basename(item),
            buffer: (await _fs.default.promises.readFile(item)).toString("base64")
          };
        } else {
          return {
            name: item.name,
            mimeType: item.mimeType,
            buffer: item.buffer.toString("base64")
          };
        }
      }));
      return filePayloads;
    }
    function determineScreenshotType(options2) {
      if (options2.path) {
        const mimeType = mime.getType(options2.path);
        if (mimeType === "image/png")
          return "png";
        else if (mimeType === "image/jpeg")
          return "jpeg";
        throw new Error(`path: unsupported mime type "${mimeType}"`);
      }
      return options2.type;
    }
  }
});

// node_modules/playwright-core/lib/client/worker.js
var require_worker = __commonJS({
  "node_modules/playwright-core/lib/client/worker.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Worker = void 0;
    var _events = require_events();
    var _channelOwner = require_channelOwner();
    var _jsHandle = require_jsHandle();
    var Worker = class extends _channelOwner.ChannelOwner {
      static from(worker) {
        return worker._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._context = void 0;
        this._channel.on("close", () => {
          if (this._page)
            this._page._workers.delete(this);
          if (this._context)
            this._context._serviceWorkers.delete(this);
          this.emit(_events.Events.Worker.Close, this);
        });
      }
      url() {
        return this._initializer.url;
      }
      async evaluate(pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      async evaluateHandle(pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
    };
    exports.Worker = Worker;
  }
});

// node_modules/playwright-core/lib/client/input.js
var require_input2 = __commonJS({
  "node_modules/playwright-core/lib/client/input.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Touchscreen = exports.Mouse = exports.Keyboard = void 0;
    var Keyboard = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      async down(key) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.keyboardDown({
            key
          });
        });
      }
      async up(key) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.keyboardUp({
            key
          });
        });
      }
      async insertText(text) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.keyboardInsertText({
            text
          });
        });
      }
      async type(text, options2 = {}) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.keyboardType(__spreadValues({
            text
          }, options2));
        });
      }
      async press(key, options2 = {}) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.keyboardPress(__spreadValues({
            key
          }, options2));
        });
      }
    };
    exports.Keyboard = Keyboard;
    var Mouse = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      async move(x, y, options2 = {}) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.mouseMove(__spreadValues({
            x,
            y
          }, options2));
        });
      }
      async down(options2 = {}) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.mouseDown(__spreadValues({}, options2));
        });
      }
      async up(options2 = {}) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.mouseUp(options2);
        });
      }
      async click(x, y, options2 = {}) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.mouseClick(__spreadValues({
            x,
            y
          }, options2));
        });
      }
      async dblclick(x, y, options2 = {}) {
        await this.click(x, y, __spreadProps(__spreadValues({}, options2), {
          clickCount: 2
        }));
      }
      async wheel(deltaX, deltaY) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.mouseWheel({
            deltaX,
            deltaY
          });
        });
      }
    };
    exports.Mouse = Mouse;
    var Touchscreen = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      async tap(x, y) {
        await this._page._wrapApiCall(async (channel) => {
          await channel.touchscreenTap({
            x,
            y
          });
        });
      }
    };
    exports.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright-core/lib/client/fileChooser.js
var require_fileChooser2 = __commonJS({
  "node_modules/playwright-core/lib/client/fileChooser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = void 0;
        this._elementHandle = void 0;
        this._isMultiple = void 0;
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
      async setFiles(files, options2) {
        return this._page._wrapApiCall(async () => {
          return this._elementHandle.setInputFiles(files, options2);
        });
      }
    };
    exports.FileChooser = FileChooser;
  }
});

// node_modules/playwright-core/lib/client/coverage.js
var require_coverage = __commonJS({
  "node_modules/playwright-core/lib/client/coverage.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Coverage = void 0;
    var Coverage = class {
      constructor(channel) {
        this._channel = void 0;
        this._channel = channel;
      }
      async startJSCoverage(options2 = {}) {
        await this._channel.startJSCoverage(options2);
      }
      async stopJSCoverage() {
        return (await this._channel.stopJSCoverage()).entries;
      }
      async startCSSCoverage(options2 = {}) {
        await this._channel.startCSSCoverage(options2);
      }
      async stopCSSCoverage() {
        return (await this._channel.stopCSSCoverage()).entries;
      }
    };
    exports.Coverage = Coverage;
  }
});

// node_modules/playwright-core/lib/client/video.js
var require_video = __commonJS({
  "node_modules/playwright-core/lib/client/video.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Video = void 0;
    var Video = class {
      constructor(page, connection) {
        this._artifact = null;
        this._artifactCallback = (artifact) => {
        };
        this._isRemote = false;
        this._isRemote = connection.isRemote();
        this._artifact = Promise.race([new Promise((f) => this._artifactCallback = f), page._closedOrCrashedPromise.then(() => null)]);
      }
      _artifactReady(artifact) {
        this._artifactCallback(artifact);
      }
      async path() {
        if (this._isRemote)
          throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
        const artifact = await this._artifact;
        if (!artifact)
          throw new Error("Page did not produce any video frames");
        return artifact._initializer.absolutePath;
      }
      async saveAs(path) {
        const artifact = await this._artifact;
        if (!artifact)
          throw new Error("Page did not produce any video frames");
        return artifact.saveAs(path);
      }
      async delete() {
        const artifact = await this._artifact;
        if (artifact)
          await artifact.delete();
      }
    };
    exports.Video = Video;
  }
});

// node_modules/playwright-core/lib/client/stream.js
var require_stream2 = __commonJS({
  "node_modules/playwright-core/lib/client/stream.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Stream = void 0;
    var _stream = __require("stream");
    var _channelOwner = require_channelOwner();
    var Stream2 = class extends _channelOwner.ChannelOwner {
      static from(Stream3) {
        return Stream3._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      stream() {
        return new StreamImpl(this._channel);
      }
    };
    exports.Stream = Stream2;
    var StreamImpl = class extends _stream.Readable {
      constructor(channel) {
        super();
        this._channel = void 0;
        this._channel = channel;
      }
      async _read(size) {
        const result = await this._channel.read({
          size
        });
        if (result.binary)
          this.push(Buffer.from(result.binary, "base64"));
        else
          this.push(null);
      }
      _destroy(error2, callback) {
        this._channel.close().catch((e) => null);
        super._destroy(error2, callback);
      }
    };
  }
});

// node_modules/playwright-core/lib/client/artifact.js
var require_artifact2 = __commonJS({
  "node_modules/playwright-core/lib/client/artifact.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Artifact = void 0;
    var fs2 = _interopRequireWildcard(__require("fs"));
    var _stream = require_stream2();
    var _utils = require_utils();
    var _channelOwner = require_channelOwner();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Artifact = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      async pathAfterFinished() {
        if (this._connection.isRemote())
          throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
        return this._wrapApiCall(async (channel) => {
          return (await channel.pathAfterFinished()).value || null;
        });
      }
      async saveAs(path) {
        return this._wrapApiCall(async (channel) => {
          if (!this._connection.isRemote()) {
            await channel.saveAs({
              path
            });
            return;
          }
          const result = await channel.saveAsStream();
          const stream = _stream.Stream.from(result.stream);
          await (0, _utils.mkdirIfNeeded)(path);
          await new Promise((resolve3, reject) => {
            stream.stream().pipe(fs2.createWriteStream(path)).on("finish", resolve3).on("error", reject);
          });
        });
      }
      async failure() {
        return this._wrapApiCall(async (channel) => {
          return (await channel.failure()).error || null;
        });
      }
      async createReadStream() {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.stream();
          if (!result.stream)
            return null;
          const stream = _stream.Stream.from(result.stream);
          return stream.stream();
        });
      }
      async cancel() {
        return this._wrapApiCall(async (channel) => {
          return channel.cancel();
        });
      }
      async delete() {
        return this._wrapApiCall(async (channel) => {
          return channel.delete();
        });
      }
    };
    exports.Artifact = Artifact;
  }
});

// node_modules/playwright-core/lib/client/page.js
var require_page2 = __commonJS({
  "node_modules/playwright-core/lib/client/page.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BindingCall = exports.Page = void 0;
    var _events = require_events();
    var _utils = require_utils();
    var _timeoutSettings = require_timeoutSettings();
    var _serializers = require_serializers();
    var _accessibility = require_accessibility2();
    var _channelOwner = require_channelOwner();
    var _consoleMessage = require_consoleMessage();
    var _dialog = require_dialog2();
    var _download = require_download2();
    var _elementHandle = require_elementHandle();
    var _worker = require_worker();
    var _frame = require_frame();
    var _input = require_input2();
    var _jsHandle = require_jsHandle();
    var _network = require_network2();
    var _fileChooser = require_fileChooser2();
    var _buffer = __require("buffer");
    var _coverage = require_coverage();
    var _waiter = require_waiter();
    var _fs = _interopRequireDefault(__require("fs"));
    var _path = _interopRequireDefault(__require("path"));
    var _clientHelper = require_clientHelper();
    var _errors = require_errors();
    var _video = require_video();
    var _artifact = require_artifact2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Page = class extends _channelOwner.ChannelOwner {
      static from(page) {
        return page._object;
      }
      static fromNullable(page) {
        return page ? Page.from(page) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._browserContext = void 0;
        this._ownedContext = void 0;
        this._mainFrame = void 0;
        this._frames = new Set();
        this._workers = new Set();
        this._closed = false;
        this._closedOrCrashedPromise = void 0;
        this._viewportSize = void 0;
        this._routes = [];
        this.accessibility = void 0;
        this.coverage = void 0;
        this.keyboard = void 0;
        this.mouse = void 0;
        this.request = void 0;
        this.touchscreen = void 0;
        this._bindings = new Map();
        this._timeoutSettings = void 0;
        this._video = null;
        this._opener = void 0;
        this._browserContext = parent;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(this._browserContext._timeoutSettings);
        this.accessibility = new _accessibility.Accessibility(this._channel);
        this.keyboard = new _input.Keyboard(this);
        this.mouse = new _input.Mouse(this);
        this.request = this._browserContext.request;
        this.touchscreen = new _input.Touchscreen(this);
        this._mainFrame = _frame.Frame.from(initializer.mainFrame);
        this._mainFrame._page = this;
        this._frames.add(this._mainFrame);
        this._viewportSize = initializer.viewportSize || null;
        this._closed = initializer.isClosed;
        this._opener = Page.fromNullable(initializer.opener);
        this._channel.on("bindingCall", ({
          binding
        }) => this._onBinding(BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("console", ({
          message
        }) => this.emit(_events.Events.Page.Console, _consoleMessage.ConsoleMessage.from(message)));
        this._channel.on("crash", () => this._onCrash());
        this._channel.on("dialog", ({
          dialog
        }) => {
          const dialogObj = _dialog.Dialog.from(dialog);
          if (!this.emit(_events.Events.Page.Dialog, dialogObj)) {
            if (dialogObj.type() === "beforeunload")
              dialog.accept({}).catch(() => {
              });
            else
              dialog.dismiss().catch(() => {
              });
          }
        });
        this._channel.on("domcontentloaded", () => this.emit(_events.Events.Page.DOMContentLoaded, this));
        this._channel.on("download", ({
          url,
          suggestedFilename,
          artifact
        }) => {
          const artifactObject = _artifact.Artifact.from(artifact);
          this.emit(_events.Events.Page.Download, new _download.Download(this, url, suggestedFilename, artifactObject));
        });
        this._channel.on("fileChooser", ({
          element,
          isMultiple
        }) => this.emit(_events.Events.Page.FileChooser, new _fileChooser.FileChooser(this, _elementHandle.ElementHandle.from(element), isMultiple)));
        this._channel.on("frameAttached", ({
          frame
        }) => this._onFrameAttached(_frame.Frame.from(frame)));
        this._channel.on("frameDetached", ({
          frame
        }) => this._onFrameDetached(_frame.Frame.from(frame)));
        this._channel.on("load", () => this.emit(_events.Events.Page.Load, this));
        this._channel.on("pageError", ({
          error: error2
        }) => this.emit(_events.Events.Page.PageError, (0, _serializers.parseError)(error2)));
        this._channel.on("route", ({
          route,
          request
        }) => this._onRoute(_network.Route.from(route), _network.Request.from(request)));
        this._channel.on("video", ({
          artifact
        }) => {
          const artifactObject = _artifact.Artifact.from(artifact);
          this._forceVideo()._artifactReady(artifactObject);
        });
        this._channel.on("webSocket", ({
          webSocket
        }) => this.emit(_events.Events.Page.WebSocket, _network.WebSocket.from(webSocket)));
        this._channel.on("worker", ({
          worker
        }) => this._onWorker(_worker.Worker.from(worker)));
        this.coverage = new _coverage.Coverage(this._channel);
        this._closedOrCrashedPromise = Promise.race([new Promise((f) => this.once(_events.Events.Page.Close, f)), new Promise((f) => this.once(_events.Events.Page.Crash, f))]);
      }
      _onFrameAttached(frame) {
        frame._page = this;
        this._frames.add(frame);
        if (frame._parentFrame)
          frame._parentFrame._childFrames.add(frame);
        this.emit(_events.Events.Page.FrameAttached, frame);
      }
      _onFrameDetached(frame) {
        this._frames.delete(frame);
        frame._detached = true;
        if (frame._parentFrame)
          frame._parentFrame._childFrames.delete(frame);
        this.emit(_events.Events.Page.FrameDetached, frame);
      }
      _onRoute(route, request) {
        for (const routeHandler of this._routes) {
          if (routeHandler.matches(request.url())) {
            if (routeHandler.handle(route, request)) {
              this._routes.splice(this._routes.indexOf(routeHandler), 1);
              if (!this._routes.length)
                this._wrapApiCall((channel) => this._disableInterception(channel), void 0, true).catch(() => {
                });
            }
            return;
          }
        }
        this._browserContext._onRoute(route, request);
      }
      async _onBinding(bindingCall) {
        const func = this._bindings.get(bindingCall._initializer.name);
        if (func) {
          await bindingCall.call(func);
          return;
        }
        await this._browserContext._onBinding(bindingCall);
      }
      _onWorker(worker) {
        this._workers.add(worker);
        worker._page = this;
        this.emit(_events.Events.Page.Worker, worker);
      }
      _onClose() {
        this._closed = true;
        this._browserContext._pages.delete(this);
        this._browserContext._backgroundPages.delete(this);
        this.emit(_events.Events.Page.Close, this);
      }
      _onCrash() {
        this.emit(_events.Events.Page.Crash, this);
      }
      context() {
        return this._browserContext;
      }
      async opener() {
        if (!this._opener || this._opener.isClosed())
          return null;
        return this._opener;
      }
      mainFrame() {
        return this._mainFrame;
      }
      frame(frameSelector) {
        const name = (0, _utils.isString)(frameSelector) ? frameSelector : frameSelector.name;
        const url = (0, _utils.isObject)(frameSelector) ? frameSelector.url : void 0;
        (0, _utils.assert)(name || url, "Either name or url matcher should be specified");
        return this.frames().find((f) => {
          if (name)
            return f.name() === name;
          return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, f.url(), url);
        }) || null;
      }
      frames() {
        return [...this._frames];
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._channel.setDefaultNavigationTimeoutNoReply({
          timeout
        });
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      _forceVideo() {
        if (!this._video)
          this._video = new _video.Video(this, this._connection);
        return this._video;
      }
      video() {
        if (!this._browserContext._options.recordVideo)
          return null;
        return this._forceVideo();
      }
      async $(selector, options2) {
        return this._mainFrame.$(selector, options2);
      }
      async waitForSelector(selector, options2) {
        return this._mainFrame.waitForSelector(selector, options2);
      }
      async dispatchEvent(selector, type, eventInit, options2) {
        return this._mainFrame.dispatchEvent(selector, type, eventInit, options2);
      }
      async evaluateHandle(pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
        return this._mainFrame.evaluateHandle(pageFunction, arg);
      }
      async $eval(selector, pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
        return this._mainFrame.$eval(selector, pageFunction, arg);
      }
      async $$eval(selector, pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
        return this._mainFrame.$$eval(selector, pageFunction, arg);
      }
      async $$(selector) {
        return this._mainFrame.$$(selector);
      }
      async addScriptTag(options2 = {}) {
        return this._mainFrame.addScriptTag(options2);
      }
      async addStyleTag(options2 = {}) {
        return this._mainFrame.addStyleTag(options2);
      }
      async exposeFunction(name, callback) {
        return this._wrapApiCall(async (channel) => {
          await channel.exposeBinding({
            name
          });
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      async exposeBinding(name, callback, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.exposeBinding({
            name,
            needsHandle: options2.handle
          });
          this._bindings.set(name, callback);
        });
      }
      async setExtraHTTPHeaders(headers) {
        return this._wrapApiCall(async (channel) => {
          (0, _network.validateHeaders)(headers);
          await channel.setExtraHTTPHeaders({
            headers: (0, _utils.headersObjectToArray)(headers)
          });
        });
      }
      url() {
        return this._mainFrame.url();
      }
      async content() {
        return this._mainFrame.content();
      }
      async setContent(html, options2) {
        return this._mainFrame.setContent(html, options2);
      }
      async goto(url, options2) {
        return this._mainFrame.goto(url, options2);
      }
      async reload(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          return _network.Response.fromNullable((await channel.reload(__spreadProps(__spreadValues({}, options2), {
            waitUntil
          }))).response);
        });
      }
      async waitForLoadState(state, options2) {
        return this._mainFrame.waitForLoadState(state, options2);
      }
      async waitForNavigation(options2) {
        return this._mainFrame.waitForNavigation(options2);
      }
      async waitForURL(url, options2) {
        return this._mainFrame.waitForURL(url, options2);
      }
      async waitForRequest(urlOrPredicate, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const predicate = (request) => {
            if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate))
              return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, request.url(), urlOrPredicate);
            return urlOrPredicate(request);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : void 0;
          return this._waitForEvent(channel, _events.Events.Page.Request, {
            predicate,
            timeout: options2.timeout
          }, logLine);
        });
      }
      async waitForResponse(urlOrPredicate, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const predicate = (response) => {
            if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate))
              return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, response.url(), urlOrPredicate);
            return urlOrPredicate(response);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : void 0;
          return this._waitForEvent(channel, _events.Events.Page.Response, {
            predicate,
            timeout: options2.timeout
          }, logLine);
        });
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        return this._wrapApiCall(async (channel) => {
          return this._waitForEvent(channel, event, optionsOrPredicate, `waiting for event "${event}"`);
        });
      }
      async _waitForEvent(channel, event, optionsOrPredicate, logLine) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = _waiter.Waiter.createForEvent(channel, event);
        if (logLine)
          waiter.log(logLine);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== _events.Events.Page.Crash)
          waiter.rejectOnEvent(this, _events.Events.Page.Crash, new Error("Page crashed"));
        if (event !== _events.Events.Page.Close)
          waiter.rejectOnEvent(this, _events.Events.Page.Close, new Error("Page closed"));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
      }
      async goBack(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          return _network.Response.fromNullable((await channel.goBack(__spreadProps(__spreadValues({}, options2), {
            waitUntil
          }))).response);
        });
      }
      async goForward(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          return _network.Response.fromNullable((await channel.goForward(__spreadProps(__spreadValues({}, options2), {
            waitUntil
          }))).response);
        });
      }
      async emulateMedia(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.emulateMedia({
            media: options2.media === null ? "null" : options2.media,
            colorScheme: options2.colorScheme === null ? "null" : options2.colorScheme,
            reducedMotion: options2.reducedMotion === null ? "null" : options2.reducedMotion,
            forcedColors: options2.forcedColors === null ? "null" : options2.forcedColors
          });
        });
      }
      async setViewportSize(viewportSize) {
        return this._wrapApiCall(async (channel) => {
          this._viewportSize = viewportSize;
          await channel.setViewportSize({
            viewportSize
          });
        });
      }
      viewportSize() {
        return this._viewportSize;
      }
      async evaluate(pageFunction, arg) {
        (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
        return this._mainFrame.evaluate(pageFunction, arg);
      }
      async addInitScript(script, arg) {
        return this._wrapApiCall(async (channel) => {
          const source = await (0, _clientHelper.evaluationScript)(script, arg);
          await channel.addInitScript({
            source
          });
        });
      }
      async route(url, handler, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          this._routes.unshift(new _network.RouteHandler(this._browserContext._options.baseURL, url, handler, options2.times));
          if (this._routes.length === 1)
            await channel.setNetworkInterceptionEnabled({
              enabled: true
            });
        });
      }
      async unroute(url, handler) {
        return this._wrapApiCall(async (channel) => {
          this._routes = this._routes.filter((route) => route.url !== url || handler && route.handler !== handler);
          if (!this._routes.length)
            await this._disableInterception(channel);
        });
      }
      async _disableInterception(channel) {
        await channel.setNetworkInterceptionEnabled({
          enabled: false
        });
      }
      async screenshot(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const copy = __spreadValues({}, options2);
          if (!copy.type)
            copy.type = (0, _elementHandle.determineScreenshotType)(options2);
          const result = await channel.screenshot(copy);
          const buffer = _buffer.Buffer.from(result.binary, "base64");
          if (options2.path) {
            await (0, _utils.mkdirIfNeeded)(options2.path);
            await _fs.default.promises.writeFile(options2.path, buffer);
          }
          return buffer;
        });
      }
      async title() {
        return this._mainFrame.title();
      }
      async bringToFront() {
        return this._wrapApiCall(async (channel) => {
          await channel.bringToFront();
        });
      }
      async close(options2 = {
        runBeforeUnload: void 0
      }) {
        try {
          await this._wrapApiCall(async (channel) => {
            if (this._ownedContext)
              await this._ownedContext.close();
            else
              await channel.close(options2);
          });
        } catch (e) {
          if ((0, _errors.isSafeCloseError)(e))
            return;
          throw e;
        }
      }
      isClosed() {
        return this._closed;
      }
      async click(selector, options2) {
        return this._mainFrame.click(selector, options2);
      }
      async dragAndDrop(source, target, options2) {
        return this._mainFrame.dragAndDrop(source, target, options2);
      }
      async dblclick(selector, options2) {
        return this._mainFrame.dblclick(selector, options2);
      }
      async tap(selector, options2) {
        return this._mainFrame.tap(selector, options2);
      }
      async fill(selector, value, options2) {
        return this._mainFrame.fill(selector, value, options2);
      }
      locator(selector) {
        return this.mainFrame().locator(selector);
      }
      frameLocator(selector) {
        return this.mainFrame().frameLocator(selector);
      }
      async focus(selector, options2) {
        return this._mainFrame.focus(selector, options2);
      }
      async textContent(selector, options2) {
        return this._mainFrame.textContent(selector, options2);
      }
      async innerText(selector, options2) {
        return this._mainFrame.innerText(selector, options2);
      }
      async innerHTML(selector, options2) {
        return this._mainFrame.innerHTML(selector, options2);
      }
      async getAttribute(selector, name, options2) {
        return this._mainFrame.getAttribute(selector, name, options2);
      }
      async inputValue(selector, options2) {
        return this._mainFrame.inputValue(selector, options2);
      }
      async isChecked(selector, options2) {
        return this._mainFrame.isChecked(selector, options2);
      }
      async isDisabled(selector, options2) {
        return this._mainFrame.isDisabled(selector, options2);
      }
      async isEditable(selector, options2) {
        return this._mainFrame.isEditable(selector, options2);
      }
      async isEnabled(selector, options2) {
        return this._mainFrame.isEnabled(selector, options2);
      }
      async isHidden(selector, options2) {
        return this._mainFrame.isHidden(selector, options2);
      }
      async isVisible(selector, options2) {
        return this._mainFrame.isVisible(selector, options2);
      }
      async hover(selector, options2) {
        return this._mainFrame.hover(selector, options2);
      }
      async selectOption(selector, values, options2) {
        return this._mainFrame.selectOption(selector, values, options2);
      }
      async setInputFiles(selector, files, options2) {
        return this._mainFrame.setInputFiles(selector, files, options2);
      }
      async type(selector, text, options2) {
        return this._mainFrame.type(selector, text, options2);
      }
      async press(selector, key, options2) {
        return this._mainFrame.press(selector, key, options2);
      }
      async check(selector, options2) {
        return this._mainFrame.check(selector, options2);
      }
      async uncheck(selector, options2) {
        return this._mainFrame.uncheck(selector, options2);
      }
      async setChecked(selector, checked, options2) {
        return this._mainFrame.setChecked(selector, checked, options2);
      }
      async waitForTimeout(timeout) {
        return this._mainFrame.waitForTimeout(timeout);
      }
      async waitForFunction(pageFunction, arg, options2) {
        return this._mainFrame.waitForFunction(pageFunction, arg, options2);
      }
      workers() {
        return [...this._workers];
      }
      on(event, listener) {
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: true
          });
        super.on(event, listener);
        return this;
      }
      addListener(event, listener) {
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: true
          });
        super.addListener(event, listener);
        return this;
      }
      off(event, listener) {
        super.off(event, listener);
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: false
          });
        return this;
      }
      removeListener(event, listener) {
        super.removeListener(event, listener);
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: false
          });
        return this;
      }
      async pause() {
        return this.context()._wrapApiCall(async (channel) => {
          await channel.pause();
        });
      }
      async pdf(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const transportOptions = __spreadValues({}, options2);
          if (transportOptions.margin)
            transportOptions.margin = __spreadValues({}, transportOptions.margin);
          if (typeof options2.width === "number")
            transportOptions.width = options2.width + "px";
          if (typeof options2.height === "number")
            transportOptions.height = options2.height + "px";
          for (const margin of ["top", "right", "bottom", "left"]) {
            const index = margin;
            if (options2.margin && typeof options2.margin[index] === "number")
              transportOptions.margin[index] = transportOptions.margin[index] + "px";
          }
          const result = await channel.pdf(transportOptions);
          const buffer = _buffer.Buffer.from(result.pdf, "base64");
          if (options2.path) {
            await _fs.default.promises.mkdir(_path.default.dirname(options2.path), {
              recursive: true
            });
            await _fs.default.promises.writeFile(options2.path, buffer);
          }
          return buffer;
        });
      }
    };
    exports.Page = Page;
    var BindingCall = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      async call(func) {
        try {
          const frame = _frame.Frame.from(this._initializer.frame);
          const source = {
            context: frame._page.context(),
            page: frame._page,
            frame
          };
          let result;
          if (this._initializer.handle)
            result = await func(source, _jsHandle.JSHandle.from(this._initializer.handle));
          else
            result = await func(source, ...this._initializer.args.map(_jsHandle.parseResult));
          this._channel.resolve({
            result: (0, _jsHandle.serializeArgument)(result)
          }).catch(() => {
          });
        } catch (e) {
          this._channel.reject({
            error: (0, _serializers.serializeError)(e)
          }).catch(() => {
          });
        }
      }
    };
    exports.BindingCall = BindingCall;
    function trimEnd(s2) {
      if (s2.length > 50)
        s2 = s2.substring(0, 50) + "\u2026";
      return s2;
    }
    function trimUrl(param) {
      if ((0, _utils.isRegExp)(param))
        return `/${trimEnd(param.source)}/${param.flags}`;
      if ((0, _utils.isString)(param))
        return `"${trimEnd(param)}"`;
    }
  }
});

// node_modules/playwright-core/lib/client/cdpSession.js
var require_cdpSession = __commonJS({
  "node_modules/playwright-core/lib/client/cdpSession.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CDPSession = void 0;
    var _channelOwner = require_channelOwner();
    var CDPSession = class extends _channelOwner.ChannelOwner {
      static from(cdpSession) {
        return cdpSession._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("event", ({
          method,
          params
        }) => {
          this.emit(method, params);
        });
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      async send(method, params) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.send({
            method,
            params
          });
          return result.result;
        });
      }
      async detach() {
        return this._wrapApiCall(async (channel) => {
          return channel.detach();
        });
      }
    };
    exports.CDPSession = CDPSession;
  }
});

// node_modules/playwright-core/lib/client/tracing.js
var require_tracing2 = __commonJS({
  "node_modules/playwright-core/lib/client/tracing.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Tracing = void 0;
    var _artifact = require_artifact2();
    var _fs = _interopRequireDefault(__require("fs"));
    var _path = _interopRequireDefault(__require("path"));
    var _yauzl = _interopRequireDefault(require_yauzl());
    var _yazl = _interopRequireDefault(require_yazl());
    var _utils = require_utils();
    var _async = require_async();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Tracing = class {
      constructor(channel) {
        this._context = void 0;
        this._sources = new Set();
        this._instrumentationListener = void 0;
        this._context = channel;
        this._instrumentationListener = {
          onApiCallBegin: (apiCall, stackTrace) => {
            for (const frame of (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.frames) || [])
              this._sources.add(frame.file);
          }
        };
      }
      async start(options2 = {}) {
        if (options2.sources)
          this._context._instrumentation.addListener(this._instrumentationListener);
        await this._context._wrapApiCall(async (channel) => {
          await channel.tracingStart(options2);
          await channel.tracingStartChunk({
            title: options2.title
          });
        });
      }
      async startChunk(options2 = {}) {
        this._sources = new Set();
        await this._context._wrapApiCall(async (channel) => {
          await channel.tracingStartChunk(options2);
        });
      }
      async stopChunk(options2 = {}) {
        await this._context._wrapApiCall(async (channel) => {
          await this._doStopChunk(channel, options2.path);
        });
      }
      async stop(options2 = {}) {
        await this._context._wrapApiCall(async (channel) => {
          await this._doStopChunk(channel, options2.path);
          await channel.tracingStop();
        });
      }
      async _doStopChunk(channel, filePath) {
        const sources = this._sources;
        this._sources = new Set();
        this._context._instrumentation.removeListener(this._instrumentationListener);
        const skipCompress = !this._context._connection.isRemote();
        const result = await channel.tracingStopChunk({
          save: !!filePath,
          skipCompress
        });
        if (!filePath) {
          return;
        }
        if (!skipCompress && !sources) {
          const artifact2 = _artifact.Artifact.from(result.artifact);
          await artifact2.saveAs(filePath);
          await artifact2.delete();
          return;
        }
        const promise = new _async.ManualPromise();
        const zipFile = new _yazl.default.ZipFile();
        zipFile.on("error", (error2) => promise.reject(error2));
        if (sources) {
          for (const source of sources) {
            try {
              if (_fs.default.statSync(source).isFile())
                zipFile.addFile(source, "resources/src@" + (0, _utils.calculateSha1)(source) + ".txt");
            } catch (e) {
            }
          }
        }
        await _fs.default.promises.mkdir(_path.default.dirname(filePath), {
          recursive: true
        });
        if (skipCompress) {
          for (const entry of result.entries)
            zipFile.addFile(entry.value, entry.name);
          zipFile.end(void 0, () => {
            zipFile.outputStream.pipe(_fs.default.createWriteStream(filePath)).on("close", () => promise.resolve());
          });
          return promise;
        }
        const artifact = _artifact.Artifact.from(result.artifact);
        const tmpPath = filePath + ".tmp";
        await artifact.saveAs(tmpPath);
        await artifact.delete();
        _yauzl.default.open(tmpPath, (err, inZipFile) => {
          if (err) {
            promise.reject(err);
            return;
          }
          (0, _utils.assert)(inZipFile);
          let pendingEntries = inZipFile.entryCount;
          inZipFile.on("entry", (entry) => {
            inZipFile.openReadStream(entry, (err2, readStream) => {
              if (err2) {
                promise.reject(err2);
                return;
              }
              zipFile.addReadStream(readStream, entry.fileName);
              if (--pendingEntries === 0) {
                zipFile.end(void 0, () => {
                  zipFile.outputStream.pipe(_fs.default.createWriteStream(filePath)).on("close", () => {
                    _fs.default.promises.unlink(tmpPath).then(() => {
                      promise.resolve();
                    });
                  });
                });
              }
            });
          });
        });
        return promise;
      }
    };
    exports.Tracing = Tracing;
  }
});

// node_modules/playwright-core/lib/client/clientInstrumentation.js
var require_clientInstrumentation = __commonJS({
  "node_modules/playwright-core/lib/client/clientInstrumentation.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createInstrumentation = createInstrumentation;
    function createInstrumentation() {
      const listeners = [];
      return new Proxy({}, {
        get: (obj, prop) => {
          if (prop === "addListener")
            return (listener) => listeners.push(listener);
          if (prop === "removeListener")
            return (listener) => listeners.splice(listeners.indexOf(listener), 1);
          if (prop === "removeAllListeners")
            return () => listeners.splice(0, listeners.length);
          if (!prop.startsWith("on"))
            return obj[prop];
          return async (...params) => {
            for (const listener of listeners) {
              var _prop, _ref;
              await ((_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, ...params));
            }
          };
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/client/browserContext.js
var require_browserContext2 = __commonJS({
  "node_modules/playwright-core/lib/client/browserContext.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.prepareBrowserContextParams = prepareBrowserContextParams;
    exports.BrowserContext = void 0;
    var _page = require_page2();
    var _frame = require_frame();
    var network = _interopRequireWildcard(require_network2());
    var _fs = _interopRequireDefault(__require("fs"));
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _browser = require_browser3();
    var _worker = require_worker();
    var _events = require_events();
    var _timeoutSettings = require_timeoutSettings();
    var _waiter = require_waiter();
    var _utils = require_utils();
    var _errors = require_errors();
    var _cdpSession = require_cdpSession();
    var _tracing = require_tracing2();
    var _artifact = require_artifact2();
    var _fetch = require_fetch2();
    var _clientInstrumentation = require_clientInstrumentation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContext = class extends _channelOwner.ChannelOwner {
      static from(context) {
        return context._object;
      }
      static fromNullable(context) {
        return context ? BrowserContext.from(context) : null;
      }
      constructor(parent, type, guid, initializer) {
        var _this$_browser;
        super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());
        this._pages = new Set();
        this._routes = [];
        this._browser = null;
        this._browserType = void 0;
        this._bindings = new Map();
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._ownerPage = void 0;
        this._closedPromise = void 0;
        this._options = {};
        this.request = void 0;
        this.tracing = void 0;
        this._backgroundPages = new Set();
        this._serviceWorkers = new Set();
        this._isChromium = void 0;
        if (parent instanceof _browser.Browser)
          this._browser = parent;
        this._isChromium = ((_this$_browser = this._browser) === null || _this$_browser === void 0 ? void 0 : _this$_browser._name) === "chromium";
        this.tracing = new _tracing.Tracing(this);
        this.request = _fetch.APIRequestContext.from(initializer.APIRequestContext);
        this._channel.on("bindingCall", ({
          binding
        }) => this._onBinding(_page.BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("page", ({
          page
        }) => this._onPage(_page.Page.from(page)));
        this._channel.on("route", ({
          route,
          request
        }) => this._onRoute(network.Route.from(route), network.Request.from(request)));
        this._channel.on("backgroundPage", ({
          page
        }) => {
          const backgroundPage = _page.Page.from(page);
          this._backgroundPages.add(backgroundPage);
          this.emit(_events.Events.BrowserContext.BackgroundPage, backgroundPage);
        });
        this._channel.on("serviceWorker", ({
          worker
        }) => {
          const serviceWorker = _worker.Worker.from(worker);
          serviceWorker._context = this;
          this._serviceWorkers.add(serviceWorker);
          this.emit(_events.Events.BrowserContext.ServiceWorker, serviceWorker);
        });
        this._channel.on("request", ({
          request,
          page
        }) => this._onRequest(network.Request.from(request), _page.Page.fromNullable(page)));
        this._channel.on("requestFailed", ({
          request,
          failureText,
          responseEndTiming,
          page
        }) => this._onRequestFailed(network.Request.from(request), responseEndTiming, failureText, _page.Page.fromNullable(page)));
        this._channel.on("requestFinished", (params) => this._onRequestFinished(params));
        this._channel.on("response", ({
          response,
          page
        }) => this._onResponse(network.Response.from(response), _page.Page.fromNullable(page)));
        this._closedPromise = new Promise((f) => this.once(_events.Events.BrowserContext.Close, f));
      }
      _setBrowserType(browserType) {
        this._browserType = browserType;
        browserType._contexts.add(this);
      }
      _onPage(page) {
        this._pages.add(page);
        this.emit(_events.Events.BrowserContext.Page, page);
        if (page._opener && !page._opener.isClosed())
          page._opener.emit(_events.Events.Page.Popup, page);
      }
      _onRequest(request, page) {
        this.emit(_events.Events.BrowserContext.Request, request);
        if (page)
          page.emit(_events.Events.Page.Request, request);
      }
      _onResponse(response, page) {
        this.emit(_events.Events.BrowserContext.Response, response);
        if (page)
          page.emit(_events.Events.Page.Response, response);
      }
      _onRequestFailed(request, responseEndTiming, failureText, page) {
        request._failureText = failureText || null;
        if (request._timing)
          request._timing.responseEnd = responseEndTiming;
        this.emit(_events.Events.BrowserContext.RequestFailed, request);
        if (page)
          page.emit(_events.Events.Page.RequestFailed, request);
      }
      _onRequestFinished(params) {
        const {
          responseEndTiming
        } = params;
        const request = network.Request.from(params.request);
        const response = network.Response.fromNullable(params.response);
        const page = _page.Page.fromNullable(params.page);
        if (request._timing)
          request._timing.responseEnd = responseEndTiming;
        this.emit(_events.Events.BrowserContext.RequestFinished, request);
        if (page)
          page.emit(_events.Events.Page.RequestFinished, request);
        if (response)
          response._finishedPromise.resolve();
      }
      _onRoute(route, request) {
        for (const routeHandler of this._routes) {
          if (routeHandler.matches(request.url())) {
            if (routeHandler.handle(route, request)) {
              this._routes.splice(this._routes.indexOf(routeHandler), 1);
              if (!this._routes.length)
                this._wrapApiCall((channel) => this._disableInterception(channel), void 0, true).catch(() => {
                });
            }
            return;
          }
        }
        route._internalContinue();
      }
      async _onBinding(bindingCall) {
        const func = this._bindings.get(bindingCall._initializer.name);
        if (!func)
          return;
        await bindingCall.call(func);
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._channel.setDefaultNavigationTimeoutNoReply({
          timeout
        });
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      browser() {
        return this._browser;
      }
      pages() {
        return [...this._pages];
      }
      async newPage() {
        return this._wrapApiCall(async (channel) => {
          if (this._ownerPage)
            throw new Error("Please use browser.newContext()");
          return _page.Page.from((await channel.newPage()).page);
        });
      }
      async cookies(urls) {
        if (!urls)
          urls = [];
        if (urls && typeof urls === "string")
          urls = [urls];
        return this._wrapApiCall(async (channel) => {
          return (await channel.cookies({
            urls
          })).cookies;
        });
      }
      async addCookies(cookies) {
        return this._wrapApiCall(async (channel) => {
          await channel.addCookies({
            cookies
          });
        });
      }
      async clearCookies() {
        return this._wrapApiCall(async (channel) => {
          await channel.clearCookies();
        });
      }
      async grantPermissions(permissions, options2) {
        return this._wrapApiCall(async (channel) => {
          await channel.grantPermissions(__spreadValues({
            permissions
          }, options2));
        });
      }
      async clearPermissions() {
        return this._wrapApiCall(async (channel) => {
          await channel.clearPermissions();
        });
      }
      async setGeolocation(geolocation) {
        return this._wrapApiCall(async (channel) => {
          await channel.setGeolocation({
            geolocation: geolocation || void 0
          });
        });
      }
      async setExtraHTTPHeaders(headers) {
        return this._wrapApiCall(async (channel) => {
          network.validateHeaders(headers);
          await channel.setExtraHTTPHeaders({
            headers: (0, _utils.headersObjectToArray)(headers)
          });
        });
      }
      async setOffline(offline) {
        return this._wrapApiCall(async (channel) => {
          await channel.setOffline({
            offline
          });
        });
      }
      async setHTTPCredentials(httpCredentials) {
        if (!(0, _utils.isUnderTest)())
          (0, _clientHelper.deprecate)(`context.setHTTPCredentials`, `warning: method |context.setHTTPCredentials()| is deprecated. Instead of changing credentials, create another browser context with new credentials.`);
        return this._wrapApiCall(async (channel) => {
          await channel.setHTTPCredentials({
            httpCredentials: httpCredentials || void 0
          });
        });
      }
      async addInitScript(script, arg) {
        return this._wrapApiCall(async (channel) => {
          const source = await (0, _clientHelper.evaluationScript)(script, arg);
          await channel.addInitScript({
            source
          });
        });
      }
      async exposeBinding(name, callback, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.exposeBinding({
            name,
            needsHandle: options2.handle
          });
          this._bindings.set(name, callback);
        });
      }
      async exposeFunction(name, callback) {
        return this._wrapApiCall(async (channel) => {
          await channel.exposeBinding({
            name
          });
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      async route(url, handler, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          this._routes.unshift(new network.RouteHandler(this._options.baseURL, url, handler, options2.times));
          if (this._routes.length === 1)
            await channel.setNetworkInterceptionEnabled({
              enabled: true
            });
        });
      }
      async unroute(url, handler) {
        return this._wrapApiCall(async (channel) => {
          this._routes = this._routes.filter((route) => route.url !== url || handler && route.handler !== handler);
          if (!this._routes.length)
            await this._disableInterception(channel);
        });
      }
      async _disableInterception(channel) {
        await channel.setNetworkInterceptionEnabled({
          enabled: false
        });
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        return this._wrapApiCall(async (channel) => {
          const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
          const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
          const waiter = _waiter.Waiter.createForEvent(channel, event);
          waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
          if (event !== _events.Events.BrowserContext.Close)
            waiter.rejectOnEvent(this, _events.Events.BrowserContext.Close, new Error("Context closed"));
          const result = await waiter.waitForEvent(this, event, predicate);
          waiter.dispose();
          return result;
        });
      }
      async storageState(options2 = {}) {
        return await this._wrapApiCall(async (channel) => {
          const state = await channel.storageState();
          if (options2.path) {
            await (0, _utils.mkdirIfNeeded)(options2.path);
            await _fs.default.promises.writeFile(options2.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
      backgroundPages() {
        return [...this._backgroundPages];
      }
      serviceWorkers() {
        return [...this._serviceWorkers];
      }
      async newCDPSession(page) {
        if (!(page instanceof _page.Page) && !(page instanceof _frame.Frame))
          throw new Error("page: expected Page or Frame");
        return this._wrapApiCall(async (channel) => {
          const result = await channel.newCDPSession(page instanceof _page.Page ? {
            page: page._channel
          } : {
            frame: page._channel
          });
          return _cdpSession.CDPSession.from(result.session);
        });
      }
      _onClose() {
        var _this$_browserType, _this$_browserType$_c;
        if (this._browser)
          this._browser._contexts.delete(this);
        (_this$_browserType = this._browserType) === null || _this$_browserType === void 0 ? void 0 : (_this$_browserType$_c = _this$_browserType._contexts) === null || _this$_browserType$_c === void 0 ? void 0 : _this$_browserType$_c.delete(this);
        this.emit(_events.Events.BrowserContext.Close, this);
      }
      async close() {
        try {
          await this._wrapApiCall(async (channel) => {
            var _this$_browserType2, _this$_browserType2$_;
            await ((_this$_browserType2 = this._browserType) === null || _this$_browserType2 === void 0 ? void 0 : (_this$_browserType2$_ = _this$_browserType2._onWillCloseContext) === null || _this$_browserType2$_ === void 0 ? void 0 : _this$_browserType2$_.call(_this$_browserType2, this));
            if (this._options.recordHar) {
              const har = await this._channel.harExport();
              const artifact = _artifact.Artifact.from(har.artifact);
              await artifact.saveAs(this._options.recordHar.path);
              await artifact.delete();
            }
            await channel.close();
            await this._closedPromise;
          });
        } catch (e) {
          if ((0, _errors.isSafeCloseError)(e))
            return;
          throw e;
        }
      }
      async _enableRecorder(params) {
        await this._channel.recorderSupplementEnable(params);
      }
    };
    exports.BrowserContext = BrowserContext;
    async function prepareBrowserContextParams(options2) {
      if (options2.videoSize && !options2.videosPath)
        throw new Error(`"videoSize" option requires "videosPath" to be specified`);
      if (options2.extraHTTPHeaders)
        network.validateHeaders(options2.extraHTTPHeaders);
      const contextParams = __spreadProps(__spreadValues({}, options2), {
        viewport: options2.viewport === null ? void 0 : options2.viewport,
        noDefaultViewport: options2.viewport === null,
        extraHTTPHeaders: options2.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options2.extraHTTPHeaders) : void 0,
        storageState: typeof options2.storageState === "string" ? JSON.parse(await _fs.default.promises.readFile(options2.storageState, "utf8")) : options2.storageState
      });
      if (!contextParams.recordVideo && options2.videosPath) {
        contextParams.recordVideo = {
          dir: options2.videosPath,
          size: options2.videoSize
        };
      }
      return contextParams;
    }
  }
});

// node_modules/playwright-core/lib/client/browser.js
var require_browser3 = __commonJS({
  "node_modules/playwright-core/lib/client/browser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Browser = void 0;
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _events = require_events();
    var _errors = require_errors();
    var _cdpSession = require_cdpSession();
    var Browser = class extends _channelOwner.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
      static fromNullable(browser) {
        return browser ? Browser.from(browser) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._contexts = new Set();
        this._isConnected = true;
        this._closedPromise = void 0;
        this._shouldCloseConnectionOnClose = false;
        this._browserType = void 0;
        this._name = void 0;
        this._name = initializer.name;
        this._channel.on("close", () => this._didClose());
        this._closedPromise = new Promise((f) => this.once(_events.Events.Browser.Disconnected, f));
      }
      _setBrowserType(browserType) {
        this._browserType = browserType;
        for (const context of this._contexts)
          context._setBrowserType(browserType);
      }
      async newContext(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          var _this$_browserType$_o, _this$_browserType;
          options2 = __spreadValues(__spreadValues({}, this._browserType._defaultContextOptions), options2);
          const contextOptions = await (0, _browserContext.prepareBrowserContextParams)(options2);
          const context = _browserContext.BrowserContext.from((await channel.newContext(contextOptions)).context);
          context._options = contextOptions;
          this._contexts.add(context);
          context._logger = options2.logger || this._logger;
          context._setBrowserType(this._browserType);
          await ((_this$_browserType$_o = (_this$_browserType = this._browserType)._onDidCreateContext) === null || _this$_browserType$_o === void 0 ? void 0 : _this$_browserType$_o.call(_this$_browserType, context));
          return context;
        });
      }
      contexts() {
        return [...this._contexts];
      }
      version() {
        return this._initializer.version;
      }
      async newPage(options2 = {}) {
        const context = await this.newContext(options2);
        const page = await context.newPage();
        page._ownedContext = context;
        context._ownerPage = page;
        return page;
      }
      isConnected() {
        return this._isConnected;
      }
      async newBrowserCDPSession() {
        return this._wrapApiCall(async (channel) => {
          return _cdpSession.CDPSession.from((await channel.newBrowserCDPSession()).session);
        });
      }
      async startTracing(page, options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          await channel.startTracing(__spreadProps(__spreadValues({}, options2), {
            page: page ? page._channel : void 0
          }));
        });
      }
      async stopTracing() {
        return this._wrapApiCall(async (channel) => {
          return Buffer.from((await channel.stopTracing()).binary, "base64");
        });
      }
      async close() {
        try {
          await this._wrapApiCall(async (channel) => {
            if (this._shouldCloseConnectionOnClose)
              this._connection.close(_errors.kBrowserClosedError);
            else
              await channel.close();
            await this._closedPromise;
          });
        } catch (e) {
          if ((0, _errors.isSafeCloseError)(e))
            return;
          throw e;
        }
      }
      _didClose() {
        this._isConnected = false;
        this.emit(_events.Events.Browser.Disconnected, this);
      }
    };
    exports.Browser = Browser;
  }
});

// node_modules/playwright-core/lib/client/browserType.js
var require_browserType2 = __commonJS({
  "node_modules/playwright-core/lib/client/browserType.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BrowserType = void 0;
    var _browser3 = require_browser3();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _connection = require_connection();
    var _events = require_events();
    var _clientHelper = require_clientHelper();
    var _utils = require_utils();
    var _errors = require_errors();
    var _async = require_async();
    var BrowserType = class extends _channelOwner.ChannelOwner {
      constructor(...args) {
        super(...args);
        this._serverLauncher = void 0;
        this._contexts = new Set();
        this._playwright = void 0;
        this._defaultContextOptions = {};
        this._defaultLaunchOptions = {};
        this._onDidCreateContext = void 0;
        this._onWillCloseContext = void 0;
      }
      static from(browserType) {
        return browserType._object;
      }
      executablePath() {
        if (!this._initializer.executablePath)
          throw new Error("Browser is not supported on current platform");
        return this._initializer.executablePath;
      }
      name() {
        return this._initializer.name;
      }
      async launch(options2 = {}) {
        const logger = options2.logger || this._defaultLaunchOptions.logger;
        return this._wrapApiCall(async (channel) => {
          (0, _utils.assert)(!options2.userDataDir, "userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead");
          (0, _utils.assert)(!options2.port, "Cannot specify a port without launching as a server.");
          options2 = __spreadValues(__spreadValues({}, this._defaultLaunchOptions), options2);
          const launchOptions = __spreadProps(__spreadValues({}, options2), {
            ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
            env: options2.env ? (0, _clientHelper.envObjectToArray)(options2.env) : void 0
          });
          const browser = _browser3.Browser.from((await channel.launch(launchOptions)).browser);
          browser._logger = logger;
          browser._setBrowserType(this);
          return browser;
        }, logger);
      }
      async launchServer(options2 = {}) {
        if (!this._serverLauncher)
          throw new Error("Launching server is not supported");
        options2 = __spreadValues(__spreadValues({}, this._defaultLaunchOptions), options2);
        return this._serverLauncher.launchServer(options2);
      }
      async launchPersistentContext(userDataDir, options2 = {}) {
        const logger = options2.logger || this._defaultLaunchOptions.logger;
        return this._wrapApiCall(async (channel) => {
          var _this$_onDidCreateCon;
          (0, _utils.assert)(!options2.port, "Cannot specify a port without launching as a server.");
          options2 = __spreadValues(__spreadValues(__spreadValues({}, this._defaultLaunchOptions), this._defaultContextOptions), options2);
          const contextParams = await (0, _browserContext.prepareBrowserContextParams)(options2);
          const persistentParams = __spreadProps(__spreadValues({}, contextParams), {
            ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
            env: options2.env ? (0, _clientHelper.envObjectToArray)(options2.env) : void 0,
            channel: options2.channel,
            userDataDir
          });
          const result = await channel.launchPersistentContext(persistentParams);
          const context = _browserContext.BrowserContext.from(result.context);
          context._options = contextParams;
          context._logger = logger;
          context._setBrowserType(this);
          await ((_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context));
          return context;
        }, logger);
      }
      async connect(optionsOrWsEndpoint, options2) {
        if (typeof optionsOrWsEndpoint === "string")
          return this._connect(optionsOrWsEndpoint, options2);
        (0, _utils.assert)(optionsOrWsEndpoint.wsEndpoint, "options.wsEndpoint is required");
        return this._connect(optionsOrWsEndpoint.wsEndpoint, optionsOrWsEndpoint);
      }
      async _connect(wsEndpoint, params = {}) {
        const logger = params.logger;
        return await this._wrapApiCall(async (channel) => {
          const deadline = params.timeout ? (0, _utils.monotonicTime)() + params.timeout : 0;
          let browser;
          const {
            pipe
          } = await channel.connect({
            wsEndpoint,
            headers: params.headers,
            slowMo: params.slowMo,
            timeout: params.timeout
          });
          const closePipe = () => pipe.close().catch(() => {
          });
          const connection = new _connection.Connection();
          connection.markAsRemote();
          connection.on("close", closePipe);
          const onPipeClosed = () => {
            var _browser2;
            for (const context of ((_browser = browser) === null || _browser === void 0 ? void 0 : _browser.contexts()) || []) {
              var _browser;
              for (const page of context.pages())
                page._onClose();
              context._onClose();
            }
            (_browser2 = browser) === null || _browser2 === void 0 ? void 0 : _browser2._didClose();
            connection.close(_errors.kBrowserClosedError);
          };
          pipe.on("closed", onPipeClosed);
          connection.onmessage = (message) => pipe.send({
            message
          }).catch(onPipeClosed);
          pipe.on("message", ({
            message
          }) => {
            try {
              connection.dispatch(message);
            } catch (e) {
              console.error(`Playwright: Connection dispatch error`);
              console.error(e);
              closePipe();
            }
          });
          const createBrowserPromise = new Promise(async (fulfill, reject) => {
            try {
              if (params.__testHookBeforeCreateBrowser)
                await params.__testHookBeforeCreateBrowser();
              const playwright3 = await connection.initializePlaywright();
              if (!playwright3._initializer.preLaunchedBrowser) {
                reject(new Error("Malformed endpoint. Did you use launchServer method?"));
                closePipe();
                return;
              }
              playwright3._setSelectors(this._playwright.selectors);
              browser = _browser3.Browser.from(playwright3._initializer.preLaunchedBrowser);
              browser._logger = logger;
              browser._shouldCloseConnectionOnClose = true;
              browser._setBrowserType(playwright3[browser._name]);
              browser.on(_events.Events.Browser.Disconnected, closePipe);
              fulfill(browser);
            } catch (e) {
              reject(e);
            }
          });
          const result = await (0, _async.raceAgainstDeadline)(createBrowserPromise, deadline);
          if (result.result) {
            return result.result;
          } else {
            closePipe();
            throw new Error(`Timeout ${params.timeout}ms exceeded`);
          }
        }, logger);
      }
      connectOverCDP(endpointURLOrOptions, options2) {
        if (typeof endpointURLOrOptions === "string")
          return this._connectOverCDP(endpointURLOrOptions, options2);
        const endpointURL = "endpointURL" in endpointURLOrOptions ? endpointURLOrOptions.endpointURL : endpointURLOrOptions.wsEndpoint;
        (0, _utils.assert)(endpointURL, "Cannot connect over CDP without wsEndpoint.");
        return this.connectOverCDP(endpointURL, endpointURLOrOptions);
      }
      async _connectOverCDP(endpointURL, params = {}) {
        if (this.name() !== "chromium")
          throw new Error("Connecting over CDP is only supported in Chromium.");
        const logger = params.logger;
        return this._wrapApiCall(async (channel) => {
          const paramsHeaders = Object.assign({
            "User-Agent": (0, _utils.getUserAgent)()
          }, params.headers);
          const headers = paramsHeaders ? (0, _utils.headersObjectToArray)(paramsHeaders) : void 0;
          const result = await channel.connectOverCDP({
            endpointURL,
            headers,
            slowMo: params.slowMo,
            timeout: params.timeout
          });
          const browser = _browser3.Browser.from(result.browser);
          if (result.defaultContext)
            browser._contexts.add(_browserContext.BrowserContext.from(result.defaultContext));
          browser._logger = logger;
          browser._setBrowserType(this);
          return browser;
        }, logger);
      }
    };
    exports.BrowserType = BrowserType;
  }
});

// node_modules/playwright-core/lib/utils/netUtils.js
var require_netUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/netUtils.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createSocket = createSocket;
    var _net = _interopRequireDefault(__require("net"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function createSocket(host, port) {
      return new Promise((resolve3, reject) => {
        const socket = _net.default.createConnection({
          host,
          port
        });
        socket.on("connect", () => resolve3(socket));
        socket.on("error", (error2) => reject(error2));
      });
    }
  }
});

// node_modules/playwright-core/lib/client/android.js
var require_android2 = __commonJS({
  "node_modules/playwright-core/lib/client/android.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AndroidWebView = exports.AndroidInput = exports.AndroidSocket = exports.AndroidDevice = exports.Android = void 0;
    var _fs = _interopRequireDefault(__require("fs"));
    var _utils = require_utils();
    var _events = require_events();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _timeoutSettings = require_timeoutSettings();
    var _waiter = require_waiter();
    var _events2 = __require("events");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Android = class extends _channelOwner.ChannelOwner {
      static from(android) {
        return android._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = void 0;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      async devices() {
        return this._wrapApiCall(async (channel) => {
          const {
            devices: devices2
          } = await channel.devices();
          return devices2.map((d) => AndroidDevice.from(d));
        });
      }
    };
    exports.Android = Android;
    var AndroidDevice = class extends _channelOwner.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = void 0;
        this._webViews = new Map();
        this.input = void 0;
        this.input = new AndroidInput(this);
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(parent._timeoutSettings);
        this._channel.on("webViewAdded", ({
          webView
        }) => this._onWebViewAdded(webView));
        this._channel.on("webViewRemoved", ({
          pid
        }) => this._onWebViewRemoved(pid));
      }
      _onWebViewAdded(webView) {
        const view = new AndroidWebView(this, webView);
        this._webViews.set(webView.pid, view);
        this.emit(_events.Events.AndroidDevice.WebView, view);
      }
      _onWebViewRemoved(pid) {
        const view = this._webViews.get(pid);
        this._webViews.delete(pid);
        if (view)
          view.emit(_events.Events.AndroidWebView.Close);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      serial() {
        return this._initializer.serial;
      }
      model() {
        return this._initializer.model;
      }
      webViews() {
        return [...this._webViews.values()];
      }
      async webView(selector, options2) {
        const webView = [...this._webViews.values()].find((v) => v.pkg() === selector.pkg);
        if (webView)
          return webView;
        return this.waitForEvent("webview", __spreadProps(__spreadValues({}, options2), {
          predicate: (view) => view.pkg() === selector.pkg
        }));
      }
      async wait(selector, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.wait(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options2));
        });
      }
      async fill(selector, text, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.fill(__spreadValues({
            selector: toSelectorChannel(selector),
            text
          }, options2));
        });
      }
      async press(selector, key, options2) {
        await this.tap(selector, options2);
        await this.input.press(key);
      }
      async tap(selector, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.tap(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options2));
        });
      }
      async drag(selector, dest, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.drag(__spreadValues({
            selector: toSelectorChannel(selector),
            dest
          }, options2));
        });
      }
      async fling(selector, direction, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.fling(__spreadValues({
            selector: toSelectorChannel(selector),
            direction
          }, options2));
        });
      }
      async longTap(selector, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.longTap(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options2));
        });
      }
      async pinchClose(selector, percent, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.pinchClose(__spreadValues({
            selector: toSelectorChannel(selector),
            percent
          }, options2));
        });
      }
      async pinchOpen(selector, percent, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.pinchOpen(__spreadValues({
            selector: toSelectorChannel(selector),
            percent
          }, options2));
        });
      }
      async scroll(selector, direction, percent, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.scroll(__spreadValues({
            selector: toSelectorChannel(selector),
            direction,
            percent
          }, options2));
        });
      }
      async swipe(selector, direction, percent, options2) {
        await this._wrapApiCall(async (channel) => {
          await channel.swipe(__spreadValues({
            selector: toSelectorChannel(selector),
            direction,
            percent
          }, options2));
        });
      }
      async info(selector) {
        return await this._wrapApiCall(async (channel) => {
          return (await channel.info({
            selector: toSelectorChannel(selector)
          })).info;
        });
      }
      async screenshot(options2 = {}) {
        return await this._wrapApiCall(async (channel) => {
          const {
            binary
          } = await channel.screenshot();
          const buffer = Buffer.from(binary, "base64");
          if (options2.path)
            await _fs.default.promises.writeFile(options2.path, buffer);
          return buffer;
        });
      }
      async close() {
        return this._wrapApiCall(async (channel) => {
          await channel.close();
          this.emit(_events.Events.AndroidDevice.Close);
        });
      }
      async shell(command) {
        return this._wrapApiCall(async (channel) => {
          const {
            result
          } = await channel.shell({
            command
          });
          return Buffer.from(result, "base64");
        });
      }
      async open(command) {
        return this._wrapApiCall(async (channel) => {
          return AndroidSocket.from((await channel.open({
            command
          })).socket);
        });
      }
      async installApk(file, options2) {
        return this._wrapApiCall(async (channel) => {
          await channel.installApk({
            file: await loadFile(file),
            args: options2 && options2.args
          });
        });
      }
      async push(file, path, options2) {
        return this._wrapApiCall(async (channel) => {
          await channel.push({
            file: await loadFile(file),
            path,
            mode: options2 ? options2.mode : void 0
          });
        });
      }
      async launchBrowser(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const contextOptions = await (0, _browserContext.prepareBrowserContextParams)(options2);
          const {
            context
          } = await channel.launchBrowser(contextOptions);
          return _browserContext.BrowserContext.from(context);
        });
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        return this._wrapApiCall(async (channel) => {
          const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
          const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
          const waiter = _waiter.Waiter.createForEvent(channel, event);
          waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
          if (event !== _events.Events.AndroidDevice.Close)
            waiter.rejectOnEvent(this, _events.Events.AndroidDevice.Close, new Error("Device closed"));
          const result = await waiter.waitForEvent(this, event, predicate);
          waiter.dispose();
          return result;
        });
      }
    };
    exports.AndroidDevice = AndroidDevice;
    var AndroidSocket = class extends _channelOwner.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("data", ({
          data
        }) => this.emit(_events.Events.AndroidSocket.Data, Buffer.from(data, "base64")));
        this._channel.on("close", () => this.emit(_events.Events.AndroidSocket.Close));
      }
      async write(data) {
        return this._wrapApiCall(async (channel) => {
          await channel.write({
            data: data.toString("base64")
          });
        });
      }
      async close() {
        return this._wrapApiCall(async (channel) => {
          await channel.close();
        });
      }
    };
    exports.AndroidSocket = AndroidSocket;
    async function loadFile(file) {
      if ((0, _utils.isString)(file))
        return _fs.default.promises.readFile(file, {
          encoding: "base64"
        }).toString();
      return file.toString("base64");
    }
    var AndroidInput = class {
      constructor(device) {
        this._device = void 0;
        this._device = device;
      }
      async type(text) {
        return this._device._wrapApiCall(async (channel) => {
          await channel.inputType({
            text
          });
        });
      }
      async press(key) {
        return this._device._wrapApiCall(async (channel) => {
          await channel.inputPress({
            key
          });
        });
      }
      async tap(point) {
        return this._device._wrapApiCall(async (channel) => {
          await channel.inputTap({
            point
          });
        });
      }
      async swipe(from, segments, steps) {
        return this._device._wrapApiCall(async (channel) => {
          await channel.inputSwipe({
            segments,
            steps
          });
        });
      }
      async drag(from, to, steps) {
        return this._device._wrapApiCall(async (channel) => {
          await channel.inputDrag({
            from,
            to,
            steps
          });
        });
      }
    };
    exports.AndroidInput = AndroidInput;
    function toSelectorChannel(selector) {
      const {
        checkable,
        checked,
        clazz,
        clickable,
        depth,
        desc,
        enabled,
        focusable,
        focused,
        hasChild,
        hasDescendant,
        longClickable,
        pkg,
        res,
        scrollable,
        selected,
        text
      } = selector;
      const toRegex = (value) => {
        if (value === void 0)
          return void 0;
        if (value instanceof RegExp)
          return value.source;
        return "^" + value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") + "$";
      };
      return {
        checkable,
        checked,
        clazz: toRegex(clazz),
        pkg: toRegex(pkg),
        desc: toRegex(desc),
        res: toRegex(res),
        text: toRegex(text),
        clickable,
        depth,
        enabled,
        focusable,
        focused,
        hasChild: hasChild ? {
          selector: toSelectorChannel(hasChild.selector)
        } : void 0,
        hasDescendant: hasDescendant ? {
          selector: toSelectorChannel(hasDescendant.selector),
          maxDepth: hasDescendant.maxDepth
        } : void 0,
        longClickable,
        scrollable,
        selected
      };
    }
    var AndroidWebView = class extends _events2.EventEmitter {
      constructor(device, data) {
        super();
        this._device = void 0;
        this._data = void 0;
        this._pagePromise = void 0;
        this._device = device;
        this._data = data;
      }
      pid() {
        return this._data.pid;
      }
      pkg() {
        return this._data.pkg;
      }
      async page() {
        if (!this._pagePromise)
          this._pagePromise = this._fetchPage();
        return this._pagePromise;
      }
      async _fetchPage() {
        return this._device._wrapApiCall(async (channel) => {
          const {
            context
          } = await channel.connectToWebView({
            pid: this._data.pid
          });
          return _browserContext.BrowserContext.from(context).pages()[0];
        });
      }
    };
    exports.AndroidWebView = AndroidWebView;
  }
});

// node_modules/playwright-core/lib/client/electron.js
var require_electron3 = __commonJS({
  "node_modules/playwright-core/lib/client/electron.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElectronApplication = exports.Electron = void 0;
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _events = require_events();
    var _jsHandle = require_jsHandle();
    var _waiter = require_waiter();
    var Electron = class extends _channelOwner.ChannelOwner {
      static from(electron) {
        return electron._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      async launch(options2 = {}) {
        return this._wrapApiCall(async (channel) => {
          const params = __spreadProps(__spreadValues({}, options2), {
            extraHTTPHeaders: options2.extraHTTPHeaders && (0, _utils.headersObjectToArray)(options2.extraHTTPHeaders),
            env: (0, _clientHelper.envObjectToArray)(options2.env ? options2.env : process.env)
          });
          return ElectronApplication.from((await channel.launch(params)).electronApplication);
        });
      }
    };
    exports.Electron = Electron;
    var ElectronApplication = class extends _channelOwner.ChannelOwner {
      static from(electronApplication) {
        return electronApplication._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._context = void 0;
        this._windows = new Set();
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._context = _browserContext.BrowserContext.from(initializer.context);
        for (const page of this._context._pages)
          this._onPage(page);
        this._context.on(_events.Events.BrowserContext.Page, (page) => this._onPage(page));
        this._channel.on("close", () => this.emit(_events.Events.ElectronApplication.Close));
      }
      _onPage(page) {
        this._windows.add(page);
        this.emit(_events.Events.ElectronApplication.Window, page);
        page.once(_events.Events.Page.Close, () => this._windows.delete(page));
      }
      windows() {
        return [...this._windows];
      }
      async firstWindow() {
        return this._wrapApiCall(async (channel) => {
          if (this._windows.size)
            return this._windows.values().next().value;
          return this.waitForEvent("window");
        });
      }
      context() {
        return this._context;
      }
      async close() {
        return this._wrapApiCall(async (channel) => {
          await channel.close();
        });
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        return this._wrapApiCall(async (channel) => {
          const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
          const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
          const waiter = _waiter.Waiter.createForEvent(channel, event);
          waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
          if (event !== _events.Events.ElectronApplication.Close)
            waiter.rejectOnEvent(this, _events.Events.ElectronApplication.Close, new Error("Electron application closed"));
          const result = await waiter.waitForEvent(this, event, predicate);
          waiter.dispose();
          return result;
        });
      }
      async browserWindow(page) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.browserWindow({
            page: page._channel
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      async evaluate(pageFunction, arg) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      async evaluateHandle(pageFunction, arg) {
        return this._wrapApiCall(async (channel) => {
          const result = await channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
    };
    exports.ElectronApplication = ElectronApplication;
  }
});

// node_modules/playwright-core/lib/client/selectors.js
var require_selectors2 = __commonJS({
  "node_modules/playwright-core/lib/client/selectors.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SelectorsOwner = exports.Selectors = void 0;
    var _clientHelper = require_clientHelper();
    var _channelOwner = require_channelOwner();
    var Selectors = class {
      constructor() {
        this._channels = new Set();
        this._registrations = [];
      }
      async register(name, script, options2 = {}) {
        const source = await (0, _clientHelper.evaluationScript)(script, void 0, false);
        const params = __spreadProps(__spreadValues({}, options2), {
          name,
          source
        });
        for (const channel of this._channels)
          await channel._channel.register(params);
        this._registrations.push(params);
      }
      _addChannel(channel) {
        this._channels.add(channel);
        for (const params of this._registrations) {
          channel._channel.register(params).catch((e) => {
          });
        }
      }
      _removeChannel(channel) {
        this._channels.delete(channel);
      }
    };
    exports.Selectors = Selectors;
    var SelectorsOwner = class extends _channelOwner.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
    };
    exports.SelectorsOwner = SelectorsOwner;
  }
});

// node_modules/playwright-core/lib/client/playwright.js
var require_playwright2 = __commonJS({
  "node_modules/playwright-core/lib/client/playwright.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Playwright = void 0;
    var _dns = _interopRequireDefault(__require("dns"));
    var _util = _interopRequireDefault(__require("util"));
    var _errors = require_errors();
    var _netUtils = require_netUtils();
    var _android2 = require_android2();
    var _browserType = require_browserType2();
    var _channelOwner = require_channelOwner();
    var _electron2 = require_electron3();
    var _fetch = require_fetch2();
    var _selectors = require_selectors2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var dnsLookupAsync = _util.default.promisify(_dns.default.lookup);
    var Playwright = class extends _channelOwner.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._android = void 0;
        this._electron = void 0;
        this.chromium = void 0;
        this.firefox = void 0;
        this.webkit = void 0;
        this.devices = void 0;
        this.selectors = void 0;
        this.request = void 0;
        this.errors = void 0;
        this._sockets = new Map();
        this._redirectPortForTest = void 0;
        this.request = new _fetch.APIRequest(this);
        this.chromium = _browserType.BrowserType.from(initializer.chromium);
        this.chromium._playwright = this;
        this.firefox = _browserType.BrowserType.from(initializer.firefox);
        this.firefox._playwright = this;
        this.webkit = _browserType.BrowserType.from(initializer.webkit);
        this.webkit._playwright = this;
        this._android = _android2.Android.from(initializer.android);
        this._electron = _electron2.Electron.from(initializer.electron);
        this.devices = {};
        for (const {
          name,
          descriptor
        } of initializer.deviceDescriptors)
          this.devices[name] = descriptor;
        this.selectors = new _selectors.Selectors();
        this.errors = {
          TimeoutError: _errors.TimeoutError
        };
        const selectorsOwner = _selectors.SelectorsOwner.from(initializer.selectors);
        this.selectors._addChannel(selectorsOwner);
        this._connection.on("close", () => {
          this.selectors._removeChannel(selectorsOwner);
          for (const uid of this._sockets.keys())
            this._onSocksClosed(uid);
        });
      }
      _setSelectors(selectors2) {
        const selectorsOwner = _selectors.SelectorsOwner.from(this._initializer.selectors);
        this.selectors._removeChannel(selectorsOwner);
        this.selectors = selectors2;
        this.selectors._addChannel(selectorsOwner);
      }
      _enablePortForwarding(redirectPortForTest) {
        this._redirectPortForTest = redirectPortForTest;
        this._channel.on("socksRequested", ({
          uid,
          host,
          port
        }) => this._onSocksRequested(uid, host, port));
        this._channel.on("socksData", ({
          uid,
          data
        }) => this._onSocksData(uid, Buffer.from(data, "base64")));
        this._channel.on("socksClosed", ({
          uid
        }) => this._onSocksClosed(uid));
      }
      async _onSocksRequested(uid, host, port) {
        if (host === "local.playwright")
          host = "localhost";
        try {
          if (this._redirectPortForTest)
            port = this._redirectPortForTest;
          const {
            address
          } = await dnsLookupAsync(host);
          const socket = await (0, _netUtils.createSocket)(address, port);
          socket.on("data", (data) => this._channel.socksData({
            uid,
            data: data.toString("base64")
          }).catch(() => {
          }));
          socket.on("error", (error2) => {
            this._channel.socksError({
              uid,
              error: error2.message
            }).catch(() => {
            });
            this._sockets.delete(uid);
          });
          socket.on("end", () => {
            this._channel.socksEnd({
              uid
            }).catch(() => {
            });
            this._sockets.delete(uid);
          });
          const localAddress = socket.localAddress;
          const localPort = socket.localPort;
          this._sockets.set(uid, socket);
          this._channel.socksConnected({
            uid,
            host: localAddress,
            port: localPort
          }).catch(() => {
          });
        } catch (error2) {
          this._channel.socksFailed({
            uid,
            errorCode: error2.code
          }).catch(() => {
          });
        }
      }
      _onSocksData(uid, data) {
        var _this$_sockets$get;
        (_this$_sockets$get = this._sockets.get(uid)) === null || _this$_sockets$get === void 0 ? void 0 : _this$_sockets$get.write(data);
      }
      static from(channel) {
        return channel._object;
      }
      _onSocksClosed(uid) {
        var _this$_sockets$get2;
        (_this$_sockets$get2 = this._sockets.get(uid)) === null || _this$_sockets$get2 === void 0 ? void 0 : _this$_sockets$get2.destroy();
        this._sockets.delete(uid);
      }
    };
    exports.Playwright = Playwright;
  }
});

// node_modules/playwright-core/lib/client/jsonPipe.js
var require_jsonPipe = __commonJS({
  "node_modules/playwright-core/lib/client/jsonPipe.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JsonPipe = void 0;
    var _channelOwner = require_channelOwner();
    var JsonPipe = class extends _channelOwner.ChannelOwner {
      static from(jsonPipe) {
        return jsonPipe._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      channel() {
        return this._channel;
      }
    };
    exports.JsonPipe = JsonPipe;
  }
});

// node_modules/playwright-core/lib/client/connection.js
var require_connection = __commonJS({
  "node_modules/playwright-core/lib/client/connection.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Connection = void 0;
    var _browser = require_browser3();
    var _browserContext = require_browserContext2();
    var _browserType = require_browserType2();
    var _channelOwner = require_channelOwner();
    var _elementHandle = require_elementHandle();
    var _frame = require_frame();
    var _jsHandle = require_jsHandle();
    var _network = require_network2();
    var _page = require_page2();
    var _worker = require_worker();
    var _consoleMessage = require_consoleMessage();
    var _dialog = require_dialog2();
    var _serializers = require_serializers();
    var _cdpSession = require_cdpSession();
    var _playwright = require_playwright2();
    var _electron2 = require_electron3();
    var _stream = require_stream2();
    var _debugLogger = require_debugLogger();
    var _selectors = require_selectors2();
    var _android2 = require_android2();
    var _artifact = require_artifact2();
    var _events = __require("events");
    var _jsonPipe = require_jsonPipe();
    var _fetch = require_fetch2();
    var Root2 = class extends _channelOwner.ChannelOwner {
      constructor(connection) {
        super(connection, "Root", "", {});
      }
      async initialize() {
        return _playwright.Playwright.from((await this._channel.initialize({
          sdkLanguage: "javascript"
        })).playwright);
      }
    };
    var Connection = class extends _events.EventEmitter {
      constructor() {
        super();
        this._objects = new Map();
        this._waitingForObject = new Map();
        this.onmessage = (message) => {
        };
        this._lastId = 0;
        this._callbacks = new Map();
        this._rootObject = void 0;
        this._closedErrorMessage = void 0;
        this._isRemote = false;
        this._rootObject = new Root2(this);
      }
      markAsRemote() {
        this._isRemote = true;
      }
      isRemote() {
        return this._isRemote;
      }
      async initializePlaywright() {
        return await this._rootObject.initialize();
      }
      pendingProtocolCalls() {
        return Array.from(this._callbacks.values()).map((callback) => callback.stackTrace);
      }
      getObjectWithKnownName(guid) {
        return this._objects.get(guid);
      }
      async sendMessageToServer(object, method, params, maybeStackTrace) {
        if (this._closedErrorMessage)
          throw new Error(this._closedErrorMessage);
        const guid = object._guid;
        const stackTrace = maybeStackTrace || {
          frameTexts: [],
          frames: [],
          apiName: "",
          allFrames: []
        };
        const {
          frames,
          apiName
        } = stackTrace;
        const id = ++this._lastId;
        const converted = {
          id,
          guid,
          method,
          params
        };
        _debugLogger.debugLogger.log("channel:command", converted);
        const metadata = {
          stack: frames,
          apiName,
          internal: !apiName
        };
        this.onmessage(__spreadProps(__spreadValues({}, converted), {
          metadata
        }));
        return await new Promise((resolve3, reject) => this._callbacks.set(id, {
          resolve: resolve3,
          reject,
          stackTrace
        }));
      }
      _debugScopeState() {
        return this._rootObject._debugScopeState();
      }
      dispatch(message) {
        if (this._closedErrorMessage)
          return;
        const {
          id,
          guid,
          method,
          params,
          result,
          error: error2
        } = message;
        if (id) {
          _debugLogger.debugLogger.log("channel:response", message);
          const callback = this._callbacks.get(id);
          if (!callback)
            throw new Error(`Cannot find command to respond: ${id}`);
          this._callbacks.delete(id);
          if (error2 && !result)
            callback.reject((0, _serializers.parseError)(error2));
          else
            callback.resolve(this._replaceGuidsWithChannels(result));
          return;
        }
        _debugLogger.debugLogger.log("channel:event", message);
        if (method === "__create__") {
          this._createRemoteObject(guid, params.type, params.guid, params.initializer);
          return;
        }
        if (method === "__dispose__") {
          const object2 = this._objects.get(guid);
          if (!object2)
            throw new Error(`Cannot find object to dispose: ${guid}`);
          object2._dispose();
          return;
        }
        const object = this._objects.get(guid);
        if (!object)
          throw new Error(`Cannot find object to emit "${method}": ${guid}`);
        object._channel.emit(method, object._type === "JsonPipe" ? params : this._replaceGuidsWithChannels(params));
      }
      close(errorMessage = "Connection closed") {
        this._closedErrorMessage = errorMessage;
        for (const callback of this._callbacks.values())
          callback.reject(new Error(errorMessage));
        this._callbacks.clear();
        this.emit("close");
      }
      _replaceGuidsWithChannels(payload) {
        if (!payload)
          return payload;
        if (Array.isArray(payload))
          return payload.map((p) => this._replaceGuidsWithChannels(p));
        if (payload.guid && this._objects.has(payload.guid))
          return this._objects.get(payload.guid)._channel;
        if (typeof payload === "object") {
          const result = {};
          for (const key of Object.keys(payload))
            result[key] = this._replaceGuidsWithChannels(payload[key]);
          return result;
        }
        return payload;
      }
      _createRemoteObject(parentGuid, type, guid, initializer) {
        const parent = this._objects.get(parentGuid);
        if (!parent)
          throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
        let result;
        initializer = this._replaceGuidsWithChannels(initializer);
        switch (type) {
          case "Android":
            result = new _android2.Android(parent, type, guid, initializer);
            break;
          case "AndroidSocket":
            result = new _android2.AndroidSocket(parent, type, guid, initializer);
            break;
          case "AndroidDevice":
            result = new _android2.AndroidDevice(parent, type, guid, initializer);
            break;
          case "APIRequestContext":
            result = new _fetch.APIRequestContext(parent, type, guid, initializer);
            break;
          case "Artifact":
            result = new _artifact.Artifact(parent, type, guid, initializer);
            break;
          case "BindingCall":
            result = new _page.BindingCall(parent, type, guid, initializer);
            break;
          case "Browser":
            result = new _browser.Browser(parent, type, guid, initializer);
            break;
          case "BrowserContext":
            result = new _browserContext.BrowserContext(parent, type, guid, initializer);
            break;
          case "BrowserType":
            result = new _browserType.BrowserType(parent, type, guid, initializer);
            break;
          case "CDPSession":
            result = new _cdpSession.CDPSession(parent, type, guid, initializer);
            break;
          case "ConsoleMessage":
            result = new _consoleMessage.ConsoleMessage(parent, type, guid, initializer);
            break;
          case "Dialog":
            result = new _dialog.Dialog(parent, type, guid, initializer);
            break;
          case "Electron":
            result = new _electron2.Electron(parent, type, guid, initializer);
            break;
          case "ElectronApplication":
            result = new _electron2.ElectronApplication(parent, type, guid, initializer);
            break;
          case "ElementHandle":
            result = new _elementHandle.ElementHandle(parent, type, guid, initializer);
            break;
          case "Frame":
            result = new _frame.Frame(parent, type, guid, initializer);
            break;
          case "JSHandle":
            result = new _jsHandle.JSHandle(parent, type, guid, initializer);
            break;
          case "JsonPipe":
            result = new _jsonPipe.JsonPipe(parent, type, guid, initializer);
            break;
          case "Page":
            result = new _page.Page(parent, type, guid, initializer);
            break;
          case "Playwright":
            result = new _playwright.Playwright(parent, type, guid, initializer);
            break;
          case "Request":
            result = new _network.Request(parent, type, guid, initializer);
            break;
          case "Response":
            result = new _network.Response(parent, type, guid, initializer);
            break;
          case "Route":
            result = new _network.Route(parent, type, guid, initializer);
            break;
          case "Stream":
            result = new _stream.Stream(parent, type, guid, initializer);
            break;
          case "Selectors":
            result = new _selectors.SelectorsOwner(parent, type, guid, initializer);
            break;
          case "WebSocket":
            result = new _network.WebSocket(parent, type, guid, initializer);
            break;
          case "Worker":
            result = new _worker.Worker(parent, type, guid, initializer);
            break;
          default:
            throw new Error("Missing type " + type);
        }
        const callback = this._waitingForObject.get(guid);
        if (callback) {
          callback(result);
          this._waitingForObject.delete(guid);
        }
        return result;
      }
    };
    exports.Connection = Connection;
  }
});

// node_modules/playwright-core/lib/remote/playwrightServer.js
var require_playwrightServer = __commonJS({
  "node_modules/playwright-core/lib/remote/playwrightServer.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PlaywrightServer = void 0;
    var _debug = _interopRequireDefault(require_src());
    var http2 = _interopRequireWildcard(__require("http"));
    var ws = _interopRequireWildcard(require_ws());
    var _dispatcher = require_dispatcher();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _playwright2 = require_playwright();
    var _processLauncher = require_processLauncher();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debugLog = (0, _debug.default)("pw:server");
    var PlaywrightServer = class {
      static async startDefault() {
        const cleanup = async () => {
          await (0, _processLauncher.gracefullyCloseAll)().catch((e) => {
          });
        };
        const delegate = {
          path: "/ws",
          allowMultipleClients: false,
          onClose: cleanup,
          onConnect: async (connection) => {
            let playwright3;
            new _dispatcher.Root(connection, async (rootScope) => {
              playwright3 = (0, _playwright2.createPlaywright)("javascript");
              const dispatcher = new _playwrightDispatcher.PlaywrightDispatcher(rootScope, playwright3);
              if (process.env.PW_SOCKS_PROXY_PORT)
                await dispatcher.enableSocksProxy();
              return dispatcher;
            });
            return () => {
              var _playwright;
              cleanup();
              (_playwright = playwright3) === null || _playwright === void 0 ? void 0 : _playwright.selectors.unregisterAll();
            };
          }
        };
        return new PlaywrightServer(delegate);
      }
      constructor(delegate) {
        this._wsServer = void 0;
        this._clientsCount = 0;
        this._delegate = void 0;
        this._delegate = delegate;
      }
      async listen(port = 0) {
        const server = http2.createServer((request, response) => {
          response.end("Running");
        });
        server.on("error", (error2) => debugLog(error2));
        const path = this._delegate.path;
        const wsEndpoint = await new Promise((resolve3, reject) => {
          server.listen(port, () => {
            const address = server.address();
            if (!address) {
              reject(new Error("Could not bind server socket"));
              return;
            }
            const wsEndpoint2 = typeof address === "string" ? `${address}${path}` : `ws://127.0.0.1:${address.port}${path}`;
            resolve3(wsEndpoint2);
          }).on("error", reject);
        });
        debugLog("Listening at " + wsEndpoint);
        this._wsServer = new ws.Server({
          server,
          path
        });
        this._wsServer.on("connection", async (socket) => {
          if (this._clientsCount && !this._delegate.allowMultipleClients) {
            socket.close();
            return;
          }
          this._clientsCount++;
          debugLog("Incoming connection");
          const connection = new _dispatcher.DispatcherConnection();
          connection.onmessage = (message) => {
            if (socket.readyState !== ws.CLOSING)
              socket.send(JSON.stringify(message));
          };
          socket.on("message", (message) => {
            connection.dispatch(JSON.parse(Buffer.from(message).toString()));
          });
          const forceDisconnect = () => socket.close();
          let onDisconnect = () => {
          };
          const disconnected = () => {
            this._clientsCount--;
            connection.onmessage = () => {
            };
            onDisconnect();
          };
          socket.on("close", () => {
            debugLog("Client closed");
            disconnected();
          });
          socket.on("error", (error2) => {
            debugLog("Client error " + error2);
            disconnected();
          });
          onDisconnect = await this._delegate.onConnect(connection, forceDisconnect);
        });
        return wsEndpoint;
      }
      async close() {
        if (!this._wsServer)
          return;
        debugLog("Closing server");
        await new Promise((f) => this._wsServer.close(f));
        await new Promise((f) => this._wsServer.options.server.close(f));
        this._wsServer = void 0;
        await this._delegate.onClose();
      }
    };
    exports.PlaywrightServer = PlaywrightServer;
  }
});

// node_modules/playwright-core/lib/browserServerImpl.js
var require_browserServerImpl = __commonJS({
  "node_modules/playwright-core/lib/browserServerImpl.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BrowserServerLauncherImpl = void 0;
    var _browser = require_browser2();
    var _ws = require_ws();
    var _dispatcher = require_dispatcher();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _clientHelper = require_clientHelper();
    var _utils = require_utils();
    var _selectorsDispatcher = require_selectorsDispatcher();
    var _selectors = require_selectors();
    var _instrumentation = require_instrumentation();
    var _playwright = require_playwright();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _playwrightServer = require_playwrightServer();
    var _browserContext = require_browserContext();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var BrowserServerLauncherImpl = class {
      constructor(browserName) {
        this._browserName = void 0;
        this._browserName = browserName;
      }
      async launchServer(options2 = {}) {
        const playwright3 = (0, _playwright.createPlaywright)("javascript");
        const browser = await playwright3[this._browserName].launch((0, _instrumentation.internalCallMetadata)(), __spreadProps(__spreadValues({}, options2), {
          ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
          ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
          env: options2.env ? (0, _clientHelper.envObjectToArray)(options2.env) : void 0
        }), toProtocolLogger(options2.logger));
        let path = `/${(0, _utils.createGuid)()}`;
        if (options2.wsPath)
          path = options2.wsPath.startsWith("/") ? options2.wsPath : `/${options2.wsPath}`;
        const delegate = {
          path,
          allowMultipleClients: true,
          onClose: () => {
          },
          onConnect: this._onConnect.bind(this, playwright3, browser)
        };
        const server = new _playwrightServer.PlaywrightServer(delegate);
        const wsEndpoint = await server.listen(options2.port);
        const browserServer = new _ws.EventEmitter();
        browserServer.process = () => browser.options.browserProcess.process;
        browserServer.wsEndpoint = () => wsEndpoint;
        browserServer.close = () => browser.options.browserProcess.close();
        browserServer.kill = () => browser.options.browserProcess.kill();
        browserServer._disconnectForTest = () => server.close();
        browser.options.browserProcess.onclose = async (exitCode, signal) => {
          server.close();
          browserServer.emit("close", exitCode, signal);
        };
        return browserServer;
      }
      async _onConnect(playwright3, browser, connection, forceDisconnect) {
        let browserDispatcher;
        new _dispatcher.Root(connection, async (scope) => {
          const selectors2 = new _selectors.Selectors();
          const selectorsDispatcher = new _selectorsDispatcher.SelectorsDispatcher(scope, selectors2);
          browserDispatcher = new ConnectedBrowserDispatcher(scope, browser, selectors2);
          browser.on(_browser.Browser.Events.Disconnected, () => {
            forceDisconnect();
          });
          return new _playwrightDispatcher.PlaywrightDispatcher(scope, playwright3, selectorsDispatcher, browserDispatcher);
        });
        return () => {
          var _browserDispatcher;
          (_browserDispatcher = browserDispatcher) === null || _browserDispatcher === void 0 ? void 0 : _browserDispatcher.cleanupContexts().catch((e) => {
          });
        };
      }
    };
    exports.BrowserServerLauncherImpl = BrowserServerLauncherImpl;
    var ConnectedBrowserDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browser, selectors2) {
        super(scope, browser, "Browser", {
          version: browser.version(),
          name: browser.options.name
        }, true);
        this._contexts = new Set();
        this._selectors = void 0;
        this._selectors = selectors2;
      }
      async newContext(params, metadata) {
        if (params.recordVideo)
          params.recordVideo.dir = this._object.options.artifactsDir;
        const context = await this._object.newContext(params);
        this._contexts.add(context);
        context._setSelectors(this._selectors);
        context.on(_browserContext.BrowserContext.Events.Close, () => this._contexts.delete(context));
        if (params.storageState)
          await context.setStorageState(metadata, params.storageState);
        return {
          context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
        };
      }
      async close() {
      }
      async killForTests() {
      }
      async newBrowserCDPSession() {
        if (!this._object.options.isChromium)
          throw new Error(`CDP session is only available in Chromium`);
        const crBrowser = this._object;
        return {
          session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, await crBrowser.newBrowserCDPSession())
        };
      }
      async startTracing(params) {
        if (!this._object.options.isChromium)
          throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        await crBrowser.startTracing(params.page ? params.page._object : void 0, params);
      }
      async stopTracing() {
        if (!this._object.options.isChromium)
          throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        const buffer = await crBrowser.stopTracing();
        return {
          binary: buffer.toString("base64")
        };
      }
      async cleanupContexts() {
        await Promise.all(Array.from(this._contexts).map((context) => context.close((0, _instrumentation.internalCallMetadata)())));
      }
    };
    function toProtocolLogger(logger) {
      return logger ? (direction, message) => {
        if (logger.isEnabled("protocol", "verbose"))
          logger.log("protocol", "verbose", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message), [], {});
      } : void 0;
    }
  }
});

// node_modules/playwright-core/lib/inProcessFactory.js
var require_inProcessFactory = __commonJS({
  "node_modules/playwright-core/lib/inProcessFactory.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createInProcessPlaywright = createInProcessPlaywright;
    var _dispatcher = require_dispatcher();
    var _playwright = require_playwright();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _connection = require_connection();
    var _browserServerImpl = require_browserServerImpl();
    function createInProcessPlaywright() {
      const playwright3 = (0, _playwright.createPlaywright)("javascript");
      const clientConnection = new _connection.Connection();
      const dispatcherConnection = new _dispatcher.DispatcherConnection();
      dispatcherConnection.onmessage = (message) => clientConnection.dispatch(message);
      clientConnection.onmessage = (message) => dispatcherConnection.dispatch(message);
      const rootScope = new _dispatcher.Root(dispatcherConnection);
      new _playwrightDispatcher.PlaywrightDispatcher(rootScope, playwright3);
      const playwrightAPI = clientConnection.getObjectWithKnownName("Playwright");
      playwrightAPI.chromium._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("chromium");
      playwrightAPI.firefox._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("firefox");
      playwrightAPI.webkit._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("webkit");
      dispatcherConnection.onmessage = (message) => setImmediate(() => clientConnection.dispatch(message));
      clientConnection.onmessage = (message) => setImmediate(() => dispatcherConnection.dispatch(message));
      playwrightAPI._toImpl = (x) => dispatcherConnection._dispatchers.get(x._guid)._object;
      return playwrightAPI;
    }
  }
});

// node_modules/playwright-core/lib/inprocess.js
var require_inprocess = __commonJS({
  "node_modules/playwright-core/lib/inprocess.js"(exports, module) {
    init_shims();
    "use strict";
    var _inProcessFactory = require_inProcessFactory();
    module.exports = (0, _inProcessFactory.createInProcessPlaywright)();
  }
});

// node_modules/playwright-core/index.js
var require_playwright_core = __commonJS({
  "node_modules/playwright-core/index.js"(exports, module) {
    init_shims();
    module.exports = require_inprocess();
  }
});

// node_modules/playwright-core/index.mjs
var import_index, chromium, firefox, webkit, selectors, devices, errors, _electron, _android;
var init_playwright_core = __esm({
  "node_modules/playwright-core/index.mjs"() {
    init_shims();
    import_index = __toModule(require_playwright_core());
    chromium = import_index.default.chromium;
    firefox = import_index.default.firefox;
    webkit = import_index.default.webkit;
    selectors = import_index.default.selectors;
    devices = import_index.default.devices;
    errors = import_index.default.errors;
    _electron = import_index.default._electron;
    _android = import_index.default._android;
  }
});

// .svelte-kit/output/server/chunks/capture-a677284b.js
var capture_a677284b_exports = {};
__export(capture_a677284b_exports, {
  get: () => get
});
var get;
var init_capture_a677284b = __esm({
  ".svelte-kit/output/server/chunks/capture-a677284b.js"() {
    init_shims();
    init_playwright_core();
    get = async ({ query }) => {
      const queryUrl = query.get("url");
      const queryFullscreen = query.get("fullscreen");
      const queryWidth = query.get("width");
      const queryHeight = query.get("height");
      const url = new URL(queryUrl);
      const browser = await chromium.launch();
      const page = await browser.newPage();
      await page.setViewportSize({ width: +queryWidth, height: +queryHeight });
      await page.goto(url.toString());
      const buffer = await page.screenshot({
        fullPage: queryFullscreen === "true"
      });
      await browser.close();
      return {
        body: {
          img: buffer.toString("base64")
        }
      };
    };
  }
});

// .svelte-kit/output/server/chunks/layout-24eb5348.js
var layout_24eb5348_exports = {};
__export(layout_24eb5348_exports, {
  default: () => Layout
});
var Layout;
var init_layout_24eb5348 = __esm({
  ".svelte-kit/output/server/chunks/layout-24eb5348.js"() {
    init_shims();
    init_app_33d456cf();
    Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${slots.default ? slots.default({}) : ``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/error-ab5fb8bf.js
var error_ab5fb8bf_exports = {};
__export(error_ab5fb8bf_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error2;
var init_error_ab5fb8bf = __esm({
  ".svelte-kit/output/server/chunks/error-ab5fb8bf.js"() {
    init_shims();
    init_app_33d456cf();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error2 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
        $$bindings.error(error2);
      return `<h1>${escape(status)}</h1>

<pre>${escape(error2.message)}</pre>



${error2.frame ? `<pre>${escape(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/index-953fe764.js
var index_953fe764_exports = {};
__export(index_953fe764_exports, {
  default: () => Routes
});
var Routes;
var init_index_953fe764 = __esm({
  ".svelte-kit/output/server/chunks/index-953fe764.js"() {
    init_shims();
    init_app_33d456cf();
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let url = "https://spotify.com";
      let fullscreen;
      let width = 1600;
      let height = 1200;
      return `<form><label style="${"display:block"}">URL
    <input type="${"text"}"${add_attribute("value", url, 0)}></label>

  <label style="${"display:block"}">Full Screen?
    <input type="${"checkbox"}"${add_attribute("checked", fullscreen, 1)}></label>

  <label style="${"display:block"}">Viewport Width
    <input type="${"number"}"${add_attribute("value", width, 0)}></label>
  <label style="${"display:block"}">Viewport Height
    <input type="${"number"}"${add_attribute("value", height, 0)}></label>

  <button ${""}>Submit</button>
  ${``}</form>

${``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/app-33d456cf.js
function get_single_valued_header(headers, key) {
  const value = headers[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function resolve(base2, path) {
  if (scheme.test(path))
    return path;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path) {
  return path[0] === "/" && path[1] !== "/";
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
async function render_endpoint(request, route, match) {
  const mod = await route.load();
  const handler = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler) {
    return;
  }
  const params = route.params(match);
  const response = await handler(__spreadProps(__spreadValues({}, request), { params }));
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = get_single_valued_header(headers, "content-type");
  const is_type_textual = is_content_type_textual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = __spreadProps(__spreadValues({}, headers), { "content-type": "application/json; charset=utf-8" });
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a2) {
            var k = _a2[0], v = _a2[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
function escape_json_string_in_html(str) {
  return escape$1(str, escape_json_string_in_html_dict, (code) => `\\u${code.toString(16).toUpperCase()}`);
}
function escape_html_attr(str) {
  return '"' + escape$1(str, escape_html_attr_dict, (code) => `&#${code};`) + '"';
}
function escape$1(str, dict, unicode_encoder) {
  let result = "";
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char in dict) {
      result += dict[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += unicode_encoder(code);
      }
    } else {
      result += char;
    }
  }
  return result;
}
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
    init2 += options2.service_worker ? '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>' : "";
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page && page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${page && page.path ? try_serialize(page.path, (error3) => {
      throw new Error(`Failed to serialize page.path: ${error3.message}`);
    }) : null},
						query: new URLSearchParams(${page && page.query ? s$1(page.query.toString()) : ""}),
						params: ${page && page.params ? try_serialize(page.params, (error3) => {
      throw new Error(`Failed to serialize page.params: ${error3.message}`);
    }) : null}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += options2.amp ? `<amp-install-serviceworker src="${options2.service_worker}" layout="nodisplay"></amp-install-serviceworker>` : `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url=${escape_html_attr(url)}`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize(__spreadProps(__spreadValues({}, error2), { name, message, stack }));
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  stuff,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = __spreadValues({
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity
          }, opts);
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const prefix = options2.paths.assets || options2.paths.base;
        const filename = (resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d) => d.file === filename || d.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page.host}/${asset.file}`, opts);
        } else if (is_root_relative(resolved)) {
          const relative = resolved;
          const headers = __spreadValues({}, opts.headers);
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = __spreadProps(__spreadValues({}, opts.headers), {
                cookie: request.headers.cookie
              });
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, _receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":"${escape_json_string_in_html(body)}"}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      stuff: __spreadValues({}, stuff)
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    stuff: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      stuff: loaded ? loaded.stuff : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options2.load_component(id) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {}
    };
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let stuff = {};
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
              node,
              stuff,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i === nodes.length - 1,
              is_error: false
            }));
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options2.handle_error(e, request);
            status = 500;
            error2 = e;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
                    node: error_node,
                    stuff: node_loaded.stuff,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  }));
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options2.handle_error(e, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = __spreadValues(__spreadValues({}, stuff), loaded.loaded.stuff);
        }
      }
    }
  try {
    return with_cookies(await render_response(__spreadProps(__spreadValues({}, opts), {
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    })), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error(__spreadProps(__spreadValues({}, opts), {
      status: 500,
      error: error3
    })), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const content_type = headers["content-type"];
  const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
  switch (type) {
    case "text/plain":
      return text();
    case "application/json":
      return JSON.parse(text());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = __spreadProps(__spreadValues({}, incoming), {
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  });
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        const decoded = decodeURI(request2.path);
        for (const route of options2.manifest.routes) {
          const match = route.pattern.exec(decoded);
          if (!match)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                let if_none_match_value = request2.headers["if-none-match"];
                if (if_none_match_value == null ? void 0 : if_none_match_value.startsWith('W/"')) {
                  if_none_match_value = if_none_match_value.substring(2);
                }
                const etag = `"${hash(response.body || "")}"`;
                if (if_none_match_value === etag) {
                  return {
                    status: 304,
                    headers: {}
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options2.handle_error(e, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
}
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
function set_paths(paths2) {
  base = paths2.base;
  assets = paths2.assets || base;
}
function set_prerendering(value) {
}
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-1dc30bdd.js",
      css: [assets + "/_app/assets/start-61d1577b.css"],
      js: [assets + "/_app/start-1dc30bdd.js", assets + "/_app/chunks/vendor-afeda487.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => assets + "/_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2, request) => {
      hooks.handleError({ error: error2, request });
      error2.stack = options.get_stack(error2);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
async function load_component(file) {
  const { entry, css: css2, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css2.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond(__spreadProps(__spreadValues({}, request), { host }), options, { prerender });
}
var __accessCheck2, __privateGet2, __privateAdd2, __privateSet2, _map, absolute, scheme, chars, unsafeChars, reserved, escaped$1, objectProtoOwnPropertyNames, subscriber_queue, escape_json_string_in_html_dict, escape_html_attr_dict, s$1, s, ReadOnlyFormData, current_component, escaped, missing_component, on_destroy, css, Root, base, assets, user_hooks, template, options, default_settings, empty, manifest, get_hooks, module_lookup, metadata_lookup;
var init_app_33d456cf = __esm({
  ".svelte-kit/output/server/chunks/app-33d456cf.js"() {
    init_shims();
    __accessCheck2 = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    __privateGet2 = (obj, member, getter) => {
      __accessCheck2(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    __privateAdd2 = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    __privateSet2 = (obj, member, value, setter) => {
      __accessCheck2(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    absolute = /^([a-z]+:)?\/?\//;
    scheme = /^[a-z]+:/;
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
    escaped$1 = {
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    Promise.resolve();
    subscriber_queue = [];
    escape_json_string_in_html_dict = {
      '"': '\\"',
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    escape_html_attr_dict = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    s$1 = JSON.stringify;
    s = JSON.stringify;
    ReadOnlyFormData = class {
      constructor(map) {
        __privateAdd2(this, _map, void 0);
        __privateSet2(this, _map, map);
      }
      get(key) {
        const value = __privateGet2(this, _map).get(key);
        return value && value[0];
      }
      getAll(key) {
        return __privateGet2(this, _map).get(key);
      }
      has(key) {
        return __privateGet2(this, _map).has(key);
      }
      *[Symbol.iterator]() {
        for (const [key, value] of __privateGet2(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield [key, value[i]];
          }
        }
      }
      *entries() {
        for (const [key, value] of __privateGet2(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield [key, value[i]];
          }
        }
      }
      *keys() {
        for (const [key] of __privateGet2(this, _map))
          yield key;
      }
      *values() {
        for (const [, value] of __privateGet2(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield value[i];
          }
        }
      }
    };
    _map = new WeakMap();
    Promise.resolve();
    escaped = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
    css = {
      code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
      map: null
    };
    Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { stores } = $$props;
      let { page } = $$props;
      let { components } = $$props;
      let { props_0 = null } = $$props;
      let { props_1 = null } = $$props;
      let { props_2 = null } = $$props;
      setContext("__svelte__", stores);
      afterUpdate(stores.page.notify);
      if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
        $$bindings.stores(stores);
      if ($$props.page === void 0 && $$bindings.page && page !== void 0)
        $$bindings.page(page);
      if ($$props.components === void 0 && $$bindings.components && components !== void 0)
        $$bindings.components(components);
      if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
        $$bindings.props_0(props_0);
      if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
        $$bindings.props_1(props_1);
      if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
        $$bindings.props_2(props_2);
      $$result.css.add(css);
      {
        stores.page.set(page);
      }
      return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
        default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
          default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
        })}` : ``}`
      })}

${``}`;
    });
    base = "";
    assets = "";
    user_hooks = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module"
    });
    template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="icon" href="/favicon.png" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>Scrapy</title>\n    ' + head + '\n  </head>\n  <body>\n    <div id="svelte">' + body + "</div>\n  </body>\n</html>\n";
    options = null;
    default_settings = { paths: { "base": "", "assets": "" } };
    empty = () => ({});
    manifest = {
      assets: [{ "file": "favicon.png", "size": 1571, "type": "image/png" }, { "file": "twitter.png", "size": 195063, "type": "image/png" }],
      layout: ".svelte-kit/build/components/layout.svelte",
      error: ".svelte-kit/build/components/error.svelte",
      routes: [
        {
          type: "page",
          pattern: /^\/$/,
          params: empty,
          a: [".svelte-kit/build/components/layout.svelte", "src/routes/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "endpoint",
          pattern: /^\/capture\/?$/,
          params: empty,
          load: () => Promise.resolve().then(() => (init_capture_a677284b(), capture_a677284b_exports))
        }
      ]
    };
    get_hooks = (hooks) => ({
      getSession: hooks.getSession || (() => ({})),
      handle: hooks.handle || (({ request, resolve: resolve22 }) => resolve22(request)),
      handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
      externalFetch: hooks.externalFetch || fetch
    });
    module_lookup = {
      ".svelte-kit/build/components/layout.svelte": () => Promise.resolve().then(() => (init_layout_24eb5348(), layout_24eb5348_exports)),
      ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(() => (init_error_ab5fb8bf(), error_ab5fb8bf_exports)),
      "src/routes/index.svelte": () => Promise.resolve().then(() => (init_index_953fe764(), index_953fe764_exports))
    };
    metadata_lookup = { ".svelte-kit/build/components/layout.svelte": { "entry": "layout.svelte-bd2e2d2c.js", "css": [], "js": ["layout.svelte-bd2e2d2c.js", "chunks/vendor-afeda487.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "error.svelte-85dfb8a4.js", "css": [], "js": ["error.svelte-85dfb8a4.js", "chunks/vendor-afeda487.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-5602aa14.js", "css": [], "js": ["pages/index.svelte-5602aa14.js", "chunks/vendor-afeda487.js"], "styles": [] } };
  }
});

// .svelte-kit/node/middlewares.js
init_shims();

// .svelte-kit/output/server/app.js
init_shims();
init_app_33d456cf();

// .svelte-kit/node/middlewares.js
import {
  createReadStream,
  existsSync,
  statSync
} from "fs";
import fs__default, { readdirSync, statSync as statSync2 } from "fs";
import { resolve as resolve2, join, normalize as normalize2, dirname } from "path";
import {
  parse
} from "querystring";
import { fileURLToPath } from "url";
function getRawBody(req) {
  return new Promise((fulfil, reject) => {
    const h = req.headers;
    if (!h["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h["content-length"]);
    if (isNaN(length) && h["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      fulfil(data);
    });
  });
}
function create_kit_middleware({ render: render2 }) {
  return async (req, res) => {
    let parsed;
    try {
      parsed = new URL(req.url || "", "http://localhost");
    } catch (e) {
      res.statusCode = 400;
      return res.end("Invalid URL");
    }
    let body;
    try {
      body = await getRawBody(req);
    } catch (err) {
      res.statusCode = err.status || 400;
      return res.end(err.reason || "Invalid request body");
    }
    const rendered = await render2({
      method: req.method,
      headers: req.headers,
      path: parsed.pathname,
      query: parsed.searchParams,
      rawBody: body
    });
    if (rendered) {
      res.writeHead(rendered.status, rendered.headers);
      if (rendered.body) {
        res.write(rendered.body);
      }
      res.end();
    } else {
      res.statusCode = 404;
      res.end("Not found");
    }
  };
}
function parse2(req) {
  let raw = req.url;
  if (raw == null)
    return;
  let prev = req._parsedUrl;
  if (prev && prev.raw === raw)
    return prev;
  let pathname = raw, search = "", query;
  if (raw.length > 1) {
    let idx = raw.indexOf("?", 1);
    if (idx !== -1) {
      search = raw.substring(idx);
      pathname = raw.substring(0, idx);
      if (search.length > 1) {
        query = parse(search.substring(1));
      }
    }
  }
  return req._parsedUrl = { pathname, search, query, raw };
}
function list(dir, callback, pre = "") {
  dir = resolve2(".", dir);
  let arr = readdirSync(dir);
  let i = 0, abs, stats;
  for (; i < arr.length; i++) {
    abs = join(dir, arr[i]);
    stats = statSync2(abs);
    stats.isDirectory() ? list(abs, callback, join(pre, arr[i])) : callback(join(pre, arr[i]), abs, stats);
  }
}
function Mime$1() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);
  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }
  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}
Mime$1.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();
    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];
      if (ext[0] === "*") {
        continue;
      }
      if (!force && ext in this._types) {
        throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
      }
      this._types[ext] = type;
    }
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
    }
  }
};
Mime$1.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, "").toLowerCase();
  let ext = last.replace(/^.*\./, "").toLowerCase();
  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;
  return (hasDot || !hasPath) && this._types[ext] || null;
};
Mime$1.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};
var Mime_1 = Mime$1;
var standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma", "es"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/mrb-consumer+xml": ["*xdf"], "application/mrb-publish+xml": ["*xdf"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["*xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-error+xml": ["xer"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
var Mime = Mime_1;
var lite = new Mime(standard);
var noop2 = () => {
};
function isMatch(uri, arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i].test(uri))
      return true;
  }
}
function toAssume(uri, extns) {
  let i = 0, x, len = uri.length - 1;
  if (uri.charCodeAt(len) === 47) {
    uri = uri.substring(0, len);
  }
  let arr = [], tmp = `${uri}/index`;
  for (; i < extns.length; i++) {
    x = extns[i] ? `.${extns[i]}` : "";
    if (uri)
      arr.push(uri + x);
    arr.push(tmp + x);
  }
  return arr;
}
function viaCache(cache, uri, extns) {
  let i = 0, data, arr = toAssume(uri, extns);
  for (; i < arr.length; i++) {
    if (data = cache[arr[i]])
      return data;
  }
}
function viaLocal(dir, isEtag, uri, extns) {
  let i = 0, arr = toAssume(uri, extns);
  let abs, stats, name, headers;
  for (; i < arr.length; i++) {
    abs = normalize2(join(dir, name = arr[i]));
    if (abs.startsWith(dir) && existsSync(abs)) {
      stats = statSync(abs);
      if (stats.isDirectory())
        continue;
      headers = toHeaders(name, stats, isEtag);
      headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
      return { abs, stats, headers };
    }
  }
}
function is404(req, res) {
  return res.statusCode = 404, res.end();
}
function send(req, res, file, stats, headers) {
  let code = 200, tmp, opts = {};
  headers = __spreadValues({}, headers);
  for (let key in headers) {
    tmp = res.getHeader(key);
    if (tmp)
      headers[key] = tmp;
  }
  if (tmp = res.getHeader("content-type")) {
    headers["Content-Type"] = tmp;
  }
  if (req.headers.range) {
    code = 206;
    let [x, y] = req.headers.range.replace("bytes=", "").split("-");
    let end = opts.end = parseInt(y, 10) || stats.size - 1;
    let start = opts.start = parseInt(x, 10) || 0;
    if (start >= stats.size || end >= stats.size) {
      res.setHeader("Content-Range", `bytes */${stats.size}`);
      res.statusCode = 416;
      return res.end();
    }
    headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
    headers["Content-Length"] = end - start + 1;
    headers["Accept-Ranges"] = "bytes";
  }
  res.writeHead(code, headers);
  createReadStream(file, opts).pipe(res);
}
function isEncoding(name, type, headers) {
  headers["Content-Encoding"] = type;
  headers["Content-Type"] = lite.getType(name.replace(/\.([^.]*)$/, "")) || "";
}
function toHeaders(name, stats, isEtag) {
  let headers = {
    "Content-Length": stats.size,
    "Content-Type": lite.getType(name) || "",
    "Last-Modified": stats.mtime.toUTCString()
  };
  if (isEtag)
    headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
  if (/\.br$/.test(name))
    isEncoding(name, "br", headers);
  if (/\.gz$/.test(name))
    isEncoding(name, "gzip", headers);
  return headers;
}
function sirv(dir, opts = {}) {
  dir = resolve2(dir || ".");
  let isNotFound = opts.onNoMatch || is404;
  let setHeaders = opts.setHeaders || noop2;
  let extensions = opts.extensions || ["html", "htm"];
  let gzips = opts.gzip && extensions.map((x) => `${x}.gz`).concat("gz");
  let brots = opts.brotli && extensions.map((x) => `${x}.br`).concat("br");
  const FILES = {};
  let fallback = "/";
  let isEtag = !!opts.etag;
  let isSPA = !!opts.single;
  if (typeof opts.single === "string") {
    let idx = opts.single.lastIndexOf(".");
    fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
  }
  let ignores = [];
  if (opts.ignores !== false) {
    ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
    if (opts.dotfiles)
      ignores.push(/\/\.\w/);
    else
      ignores.push(/\/\.well-known/);
    [].concat(opts.ignores || []).forEach((x) => {
      ignores.push(new RegExp(x, "i"));
    });
  }
  let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
  if (cc && opts.immutable)
    cc += ",immutable";
  else if (cc && opts.maxAge === 0)
    cc += ",must-revalidate";
  if (!opts.dev) {
    list(dir, (name, abs, stats) => {
      if (/\.well-known[\\+\/]/.test(name))
        ;
      else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name))
        return;
      let headers = toHeaders(name, stats, isEtag);
      if (cc)
        headers["Cache-Control"] = cc;
      FILES["/" + name.normalize().replace(/\\+/g, "/")] = { abs, stats, headers };
    });
  }
  let lookup = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
  return function(req, res, next) {
    let extns = [""];
    let pathname = parse2(req).pathname;
    let val = req.headers["accept-encoding"] || "";
    if (gzips && val.includes("gzip"))
      extns.unshift(...gzips);
    if (brots && /(br|brotli)/i.test(val))
      extns.unshift(...brots);
    extns.push(...extensions);
    if (pathname.indexOf("%") !== -1) {
      try {
        pathname = decodeURIComponent(pathname);
      } catch (err) {
      }
    }
    let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
    if (!data)
      return next ? next() : isNotFound(req, res);
    if (isEtag && req.headers["if-none-match"] === data.headers["ETag"]) {
      res.writeHead(304);
      return res.end();
    }
    if (gzips || brots) {
      res.setHeader("Vary", "Accept-Encoding");
    }
    setHeaders(res, pathname, data.stats);
    send(req, res, data.abs, data.stats, data.headers);
  };
}
var __dirname2 = dirname(fileURLToPath(import.meta.url));
var noop_handler = (_req, _res, next) => next();
var paths = {
  assets: join(__dirname2, "/assets"),
  prerendered: join(__dirname2, "/prerendered")
};
var prerenderedMiddleware = fs__default.existsSync(paths.prerendered) ? sirv(paths.prerendered, {
  etag: true,
  maxAge: 0,
  gzip: true,
  brotli: true
}) : noop_handler;
var assetsMiddleware = fs__default.existsSync(paths.assets) ? sirv(paths.assets, {
  setHeaders: (res, pathname) => {
    if (pathname.startsWith("/_app/")) {
      res.setHeader("cache-control", "public, max-age=31536000, immutable");
    }
  },
  gzip: true,
  brotli: true
}) : noop_handler;
var kitMiddleware = function() {
  init();
  return create_kit_middleware({ render });
}();
export {
  assetsMiddleware,
  kitMiddleware,
  prerenderedMiddleware
};
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
